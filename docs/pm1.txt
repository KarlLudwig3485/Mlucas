Some factors q = 2.k.p+1 of small M(p) useful for p-1 bc-algo testing:
p	q				factorization of (q-1)
---	------------	----------------------
199	164504919713	2^5.7.199.3690437
191	383				2.191
	7068569257		2^3.3^2.7.97.191.757
""	39940132241		2^4.5.191.2613883				<*** Thus can completely factor M191 using b1 = 10^3, b2 = 3*10^6
""	332584516519201	2^5.3^2.5^2.11.23.131.191.7297
87274497124602996457
===================================
*** Sep 2021: See about using PLM's (p+1)-method idea about using Lucas seqs to reduce #modmul needed to up-multiply
the stage 2 per-bigstep loop multiplier from 2 to 1:

First cartoonify the finding of the above 2nd-smallest factor of 2^191-1, 7068569257 = 1 + 2^3.3^2.7.97.191.757 .
Stage 1: need all primes < 10 and exponent-as-seed, since this version of S2 mults captures pow^:
	b1 = 10; p = 191; n = 2^p-1;
	tmp = s1_ppow_prod(b1,p);
	pow = modpow_lr(3,tmp,n);
	gcd1 = abs(gcd(pow-1,n));
	print "Stage 1 residue A = ",pow,", gcd(A-1,n) = ",gcd1,"\n";
...gives pow = 2887311629500234812370277648848447825871473936996717773602, gcd1 = 383
Stage 2: need to capture the primes 97 and 757 = (427 -+ 330):
	a = 427; b = 330;
	asq = modpow_lr(pow,a^2,n);
	bsq = modpow_lr(pow,b^2,n);
	pow2 = pow*(asq - bsq) % n;
	gcd2 = abs(gcd(pow2,n))/gcd1;
	print "Stage 2 residue B = ",pow2,", gcd(B,n) = ",gcd2,"\n";
...gives B = 734507924635104636316008894873215872056074027539152312501, gcd2 = 7068569257

PLM suggests replacing pow^(a^2) % n with (pow^a + pow^-a) in the above, where pow^-1 is the mod-inverse of pow.
Here the s2 powering captures at most 1 outlier-prime, so need b1 = 100:
	b1 = 100; p = 191; n = 2^p-1;
	tmp = s1_ppow_prod(b1,p);
	pow = modpow_lr(3,tmp,n);
	gcd1 = abs(gcd(pow-1,n));
...gives pow = 128769258292776737605522125681498085343532977178760115477, gcd1 = 383
	print "Stage 1 residue A = ",pow,", gcd(A-1,n) = ",gcd1,"\n";
	a = 427; b = 330;
	ipow = modinv(pow,n);
	asq = modpow_lr(pow,a,n) + modpow_lr(ipow,a,n);
	bsq = modpow_lr(pow,b,n) + modpow_lr(ipow,b,n);
	pow2 = pow*(asq - bsq) % n;
	gcd2 = abs(gcd(pow2,n))/gcd1;
	print "Stage 2 residue B = ",pow2,", gcd(B,n) = ",gcd2,"\n";
...and that finds the expected larger-factor.
Q: Does the above work if we reset pow = pow^D - pow^-D ?
	...
	a = 427; b = 330;
	pow = modpow_lr(pow,a,n);
	ipow = modinv(pow,n);
	...
...also works.

=================================
Oct 2021: Try reproducing the actual code flow, with s2 starting at a multiple of a smooth bigstep, D = 210:

/* m = prime-pairing window-multiplicity: */
define pm3(n,seed,b1,b2,m) {	/*** Use N < 0 as a proxy for "enable debug-print diagnostics": ***/
	auto b,gcd1,gcd2,pow,nq,np,ns,p1,p2,q,q0,q1,q2,qlo,i,j,k,num_b,m2,lo,hi,tmp;
	/* Set seed = 1 for moduli of no special form, p for M(p), 2^(m+2) for F(m): */
	debug = 0;
	if(n < 0) {
		n = -n;	/* N must be >= 0 to keep ispow2 from oo-looping */
		print "Modulus < 0 ... enabling debug-printing.\n";
		debug = 1;
	}
	if(seed) {
		print "User set stage 1 prime-powers-product seed = ",seed,"\n";
	} else {
		seed = 1;
		if(ispow2(n+1)) {
			i = bits(n); seed = i;
			print "Modulus is a Mersenne number M(",i,"); setting stage 1 prime-powers-product seed = ",seed,"\n";
		}
		if(ispow2(n-1)) {
			i = bits(n)-1;
			if(ispow2(i)) {
				j = bits(i); seed = 2^(j+2);
				print "Modulus is a Fermat number F(",j,"); setting stage 1 prime-powers-product seed = 2^(",j,"+2) = ",seed,"\n";
			}
		}
	}
	/* Stick to D = 2.3.5.7 for now, with adjustable 'windowing' in multiples of the resulting num_b = 24 buffers: */
	d = 210; num_b = 24;
	if(!is_odd(m) || m < 1 || m > 99) { print "M must be odd in [1,99].\n"; return; }
	tmp = s1_ppow_prod(b1,seed);
	pow = modpow_lr(3,tmp,n);	/* Fix base = 3 */
	gcd1 = abs(gcd(pow-1,n));
	print "Stage 1 residue A = ",pow,", gcd(A-1,n) = ",gcd1,"\n";
	if(gcd1 > 1) {
		if(is_prp(gcd1)) {
			print "This factor is a probable prime.\n";
		} else {
			print "This factor is composite.\n";
		}
	}
	print "Stage 2 interval = [",b1,",",b2,"]:\n";
	/* For our product-of-small-primes D giant-step, find all coprime b in [1,M*D/2-1]: */
	tmp = 0;
	for(i = 1; i < m*d/2; i++) {
		if(gcd(d,i) == 1) b[tmp++] = i;
	}
	if(tmp != m*num_b) {
		print "Error: #ints coprime to D should == M*",num_b,", instead got ",tmp,"\n";
		return(0);
	}
	print "Using base= 3; Initializing M*",num_b," = ",m*num_b," [base^(A^d + A^-d) % n] buffers for Stage 2...\n";
	/* [a] Generate a set of precomputed buffers (A^b + A^-b) for the set of b-values corr. to our choice of D: */
	j = modinv(pow,n);	/* A^-1 */
	print "A^-1 = ",j,"\n";
	for(i = 0; i < m*num_b; i++) {
		buf[i] = modpow_lr(pow,b[i],n) + modpow_lr(j,b[i],n);	/* Note: full-length multiplicands here and below: LR no faster than RL */
		print "b[i] = ",i,": buf = ",buf[i],"\n";
	}
	/* [b] Stage 2 starts at q0, the smallest multiple of D nearest but not exceeding b1 + D/2;
	once have that, compute k0 = q0/D: */
	q0 = b1 + d - b1%d;
	/* The 1st clause is is to ensure that Stage 2 lower bound > D/2, otherwise we get negative q's: */
	if(b1 > d/2 && q0 > (b1 + d/2)) {
		q0 -= d;
	}
	k = q0/d;	/* Now set k to its 'real' value */
	print "Stage 2 q0 = ",q0,", k0 = ",k,"\n";
	/* Expanded-match-window scheme needs us to precompute singleton-prime-q's bitmap M D-intervals wide centered on q0:
	Init M 2*num_b-bit words of pairing bitmap = 0; e.g. for D = 210 we have M 48-bit words. The low num_b bits
	of each word correspond to singleton (in the sense that the corr. q2 is composite) q1 = (q - b[i])'s relative
	to the center of each of the M D-intervals, the hi bits to the q2 = (q + b[i])'s.
	*/
	m2 = m/2;	/* m odd, so m2 = (m-1)/2, # of D-interval on either side of the central 0-interval */
	for(i = 0; i < m; i++) { map[i] = 0; }	/* init words of extended-window pairing bitmap = 0 */
	/*
	We save ourself some awkward preprocessing by starting the stage 2 loop such that at end of the first loop pass,
	the D-interval centered on q0 enters the as the new upper-interval. We only start actual 0-interval and extended-
	window pairing when said interval has shifted to the middle of the extended pairing window, i.e. is the 0-interval:
	*/
	qlo = q0 - (m2+1)*d;
	/*
	Bigstep-loop-multiplier up-multiply uses Lucas sequence of 2nd kind:
		V[n+j] = V[n]*V[j] - V[n-j] . [*]
	Here,
		V[n  ] = A^(k*D) + A^-(k*D), stored in mult[0];
		V[n-j] = A^((k-1)*D) + A^-((k-1)*D), stored in mult[1].
		V[  j] = A^D + A^-D, stored in mult[2];
	The result V[n+j] = A^((k+1)*D) + A^-((k+1)*D) overwrites mult[0], so must save copy of it first,
	since the old value must end up in mult[1]:
	*/
	mult[2] = (modpow_lr(pow,      d,n) + modpow_lr(j,      d,n)) % n;	/* A^D + A^-D */
	mult[0] = (modpow_lr(pow, k   *d,n) + modpow_lr(j, k   *d,n)) % n;	/* A^(k0*D)     + A^-(k0*D))    */
if(debug) print "V[k*D]: v1 = ",modpow_lr(mult[2],k,n),"; v2 = ",mult[0],"\n";
	mult[1] = modpow_lr(mult[2],k-1,n);	/* A^((k0-1)*D) + A^-((k0-1)*D) */
/*	print "Stage 2 mult0,1,2 = ",mult[0],",",mult[1],",",mult[2],"\n";*/
	pow = mult[0];	/* Init stage 2 accumulator (re-use same var as for stage 1 accum, since done with that) */
	nq = np = 0;	/* nq = # of stage 2 q's processed; np = # of those which end up getting as part of a prime-pair */
	ns = 0;			/* ns = # singleton-prime q's, i.e. prime q which end up getting paired with a composite */
	for(q = qlo; q < b2+d; q += d)
	{
		/* Only start actual 0-interval and extended-window pairing when q hits q0: */
		if(q >= q0) {
			if(debug) print "k = ",k,": q = ",q,"; mult0 = ",mult[0],"\n";
			/* [d] 0-interval q's were already computed once when said interval entered at upper end of expanded-match
			window, but that pass simply set bitmap bits corr. to singleton-prime-q's = 1. Once interval has shifted to
			center of the expanded-match window, recompute same batch of stage 2 powering pairs q1,q2[i] = k*D +- b[i]
			and process the both-q1-and-q2-prime pairs: */
			if(debug) print "Processing 0-interval prime pairs:\n";
			for(i = 0; i < num_b; i++) {
				q1 = q - b[i]; q2 = q + b[i]; nq += 2;
				p1 = pprimef(q1,2); p2 = pprimef(q2,2);	/* Run q1,q2 through a base-2 Fermat-composite test */
				/* Skip a given value of i if one or both of q1,q2[i] are composite according to a 2-prp test: */
				j = p1+p2;
				if(j < 2) {
					if(j < m) {	/* For M = 1, must process 1-primes here; this == (!j || (m == 1)) */
						if(debug) print "\tq1 = ",q1,"[",p1,"], q2 = ",q2,"[",p2,"]\n";
						continue;
					}
					if(debug) print "\tq1 = ",q1,"[",p1,"], q2 = ",q2,"[",p2,"], 1-prime\n";
					ns += 1;
				} else {
					if(debug) print "\tq1 = ",q1,"[",p1,"], q2 = ",q2,"[",p2,"], both prime\n";
					if(!pow) { print "stage 2 accumulator = 0 ... aborting.\n"; return(0); }
					np += 2;
				}
				/* [e] For each prime-pair q1,q2 = -+ b[i], update stage 2 accumulator as *= A^((k*D)^2) - buf[i]: */
				pow = pow*(mult[0] - buf[i]) % n;
			}
			/* Loop over the m2 interval-pairs symmetric about the 0-interval and process any resulting pairings: */
			for(i = 1; i <= m2; i++) {	/* start with pair bracketing 0-interval and work outward */
				if(debug) print "Extended-window pair [",i,"]\n";
				/* In context of extended-window bitmap word-pairs, lo,hi refer to entire [2*num_b]-bit map words: */
				lo = map[m2-i];	hi = map[m2+i];
				/* In b[]-index terms, LSB of low word [i]th pair this far left of 0-interval ctr: */
				tmp = (2*i-1)*num_b;
				/* Testing bits of lo,hi starting with 0-bits corr. to working outward through paired D-intervals: */
				q2 = 1;	/* Use q2 here as repeated-add-to-double accumulator used to clear selected 1-bits of the 2 map words */
				for(j = 0; j < 2*num_b; j++) {
					/* bc has no multibit AND, only 1-bit boolean &&, so this amounts to a bitwise on-the-fly one: */
					p1 = lo % 2; p2 = hi % 2;
					/* For thus-paired prime-q's, update stage 2 accumulator: */
					if(p1 && p2) {
						np += 2; pow = pow*(mult[0] - buf[tmp+j]) % n;
						if(debug) print "\tq = ",q," -+ ",b[tmp+j],": q1 = ",q-b[tmp+j],"[",p1,"], q2 = ",q+b[tmp+j],"[",p2,"], paired singles\n";
						if(!pow) { print "stage 2 accumulator = 0 ... aborting.\n"; return(0); }
						map[m2-i] -= q2;	map[m2+i] -= q2;	/* Clear the paired 1-bits from the map words */
					}
					lo /= 2; hi /= 2; q2 += q2;
				}
			}
		}	/* endif(q == q0) */
		/* Process remaining q-singles in map[0], which is about to get shifted off. Remember, since we are
		left of 0-interval, 0-bit of bitmap word corr. to rightmost q of interval (closest to 0-interval): */
		if(m > 1) {	/* code below assumes an expanded-match window, i.e. m >= 3 */
			if(map[0]) {
				lo = map[0];
				/* In b[]-index terms, LSB of low word [m2]th pair this far left of 0-interval ctr: */
				tmp = (m-2)*num_b;
				/* Testing bits of lo,hi starting with 0-bits corr. to working outward through paired D-intervals: */
				if(debug) print "Word 0, processing remaining p1-prime singletons:\n";
				for(i = 0; i < 2*num_b; i++) {
					p1 = lo % 2;
					/* Pair remaining prime-singles in map[0] with corr. high-interval map[M-1] composites: */
					if(p1) {
						ns += 1; pow = pow*(mult[0] - buf[tmp+i]) % n;
						if(debug) print "\tq = ",q," -+ ",b[tmp+i],": q1 = ",q-b[tmp+i],"[",p1,"], q2 = ",q+b[tmp+i],"[",p2,"], 1-prime\n";
						if(!pow) { print "stage 2 accumulator = 0 ... aborting.\n"; return(0); }
					}
					lo /= 2;
				}
			}
			/* Since current 0-interval will end up leftward of new one after shift, bit-reverse its map word: */
			if(map[m2]) {
				map[m2] = reverse(map[m2],2*num_b);
			}
			/* shift words in map down one slot, vacating the upper-interval slot: */
			for(i = 0; i < m-1; i++) {
				map[i] = map[i+1];
			}
			/* shift in new upper-interval and tag its within-interval singletons: */
			tmp = q + (m2+1)*d;	/* midpoint of new upper-interval */
			lo = hi = 0;	/* Since working outward from middle of interval, init separate num_b-bit
							accumulators for lo,hi halves of bitmap word and then combine post-loop */
		/*	print "New high Word[",m-1,"], center of subinterval q = ",tmp,", tagging within-interval singletons:\n";*/
			for(i = 0; i < num_b; i++) {
				q1 = tmp - b[i]; q2 = tmp + b[i];
				p1 = pprimef(q1,2); p2 = pprimef(q2,2);	/* Run q1,q2 through a base-2 Fermat-composite test */
			/*	print "\tq = ",tmp," -+ ",b[i],": q1 = ",tmp-b[i],"[",p1,"], q2 = ",tmp+b[i],"[",p2,"]";*/
				/* Skip a given value of i if both of q1,q2[i] are probable-prime according to a 2-prp test: */
				if((p1+p2) == 2) {
				/*	print "\tskip both-prime\n";*/
					p1 = p2 = 0;	/* No 'continue' since still need to update lo,hi */
				} else {
				/*	print "\n";*/
				}
				/* Since skip both-prime instances, at most one of the 0-bits of lo,hi will get set here: */
				lo += lo+p1;	/* lo = 2*lo + isprp(q1) */
				hi += hi+p2;	/* hi = 2*hi + isprp(q2) */
			}
			/* lo ends up with q nearest the 0-interval in 0-bit, just as we want; hi needs bit-reversing: */
			if(debug) print "hi24 = ",hi,", lo24 = ",lo,"\n";
			tmp = 2^num_b;
			map[m-1] = reverse(hi,num_b)*tmp + lo;
			if(debug) print "New map[",m-1,"] = ",map[m-1],"\n";
		}
		/* Only update mults once start actual 0-interval and extended-window pairing above: */
		if(q >= q0) {
			/* [f] Each ensuing k++ needs just 1 modmul to update A^(k*D) + A^-(k*D) for the incremented k: */
			tmp = mult[0];	/* Save copy of V[n] = A^(k*D) + A^-(k*D) */
			mult[0] = mult[0]*mult[2] % n;		/* V[n] *= V[j] overwrites mult[0] */
			mult[0] = (mult[0] - mult[1]) % n;	/* Subtract mult[0] -= V[n-1], yielding V[n+1] = V[n]*V[j] - V[n-1] */
			mult[1] = tmp;	/* Copy of V[n] = A^(k*D) + A^-(k*D) overwrites mult[1] */
			k += 1;
			if(k%1000 == 0) print "At q = ",q,"\n";
		}
	}
	gcd2 = abs(gcd(pow,n))/gcd1;	/* Divide out any factors found in Stage 1 */
	print "Stage 2: did ",k - q0/d," loop passes. Residue B = ",pow,", gcd(B,n) = ",abs(gcd2),"\n";
	if(gcd2 > 1) {
		if(is_prp(gcd2)) {
			print "This factor is a probable prime.\n";
		} else {
			print "This factor is composite.\n";
		}
	}
	/* nq includes non-prime q's, replace with #primes for pairing-stats computation: */
	nq = 2*np + ns;
	print "Processed ",nq," stage 2 primes, including ",np," prime-pairs and ",ns," prime-singles [",200*np/nq,".",20000*np/nq%100," % paired].\n";
}

(p+1)-multiplier-debug Testcase:

n = 2^191-1
pm3(-n,0,100,1000,1)	<*** -n enables debug; '0' means no externally provided s1 prime-powers-product seed

Modulus < 0 ... enabling debug-printing.
User set stage 1 prime-powers-product seed = 3
Stage 1 prime-powers seed = 3
Stage 1 residue A = 1137101692395410290750355207037324182166068596845130588206, gcd(A-1,n) = 1
Stage 2 interval = [100,1000]:
Using base= 3; Initializing M*24 = 24 [base^(A^d + A^-d) % n] buffers for Stage 2...
A^-1 = -1461740151708545785069461454381812409241949453173153266311
b[i] = 0: buf = -324638459313135494319106247344488227075880856328022678105
b[i] = 1: buf = 546637297837178381940648769020974123678246325018332579925
b[i] = 2: buf = 559374515524615066045667908344238604682235070556976555444
b[i] = 3: buf = 440445579562208552049538415189038849143713094784544643805
b[i] = 4: buf = -76188978301220057589285622030486185867562095498364620124
b[i] = 5: buf = -1235078158726068723953030034677707889718102529243142494033
b[i] = 6: buf = 322523908081000861806160161353640839466355957915499059054
b[i] = 7: buf = 180530676969528442360928096557410391048357199728581082143
b[i] = 8: buf = -802326071722006105683981870162774848376967074849455970553
b[i] = 9: buf = 981562360320054023455539863842915462531295575221564026087
b[i] = 10: buf = -1052212608830739427363164008168732867944860826537978621301
b[i] = 11: buf = 432225118387512335184204949743624868929761674072380872252
b[i] = 12: buf = -1519782963791634718805241178158925317417054311192598000236
b[i] = 13: buf = 965249996066627134494992803221889257312778520623583735701
b[i] = 14: buf = -406585366269744636355591381712617707513837659254532195839
b[i] = 15: buf = 806831632680555146298461747646007220913037341167577645843
b[i] = 16: buf = 596952972827225144182006182209641800201364702442599666141
b[i] = 17: buf = -669451813129461449065912379806124685199618977223156326225
b[i] = 18: buf = -793725174606041221326449141641044394117573518013259317286
b[i] = 19: buf = -2162647630508244926645541931194023087994110078452956666341
b[i] = 20: buf = 1594267247830980204717192202895084728557394760778776203878
b[i] = 21: buf = -382646685243690791067085925955776790014110528133599479326
b[i] = 22: buf = -871471325565565246682312081297963185485209100627080999879
b[i] = 23: buf = 2362539837176384121328377589295455927855930261178112866262
Stage 2 q0 = 210, k0 = 1
V[k*D]: v1 = 2836608674761150096112041293760722368524158152284909842105; v2 = 2836608674\
761150096112041293760722368524158152284909842105
k = 1: q = 210; mult0 = 2836608674761150096112041293760722368524158152284909842105
...
	q1 = 947[1], q2 = 1153[1], both prime
Stage 2: did 5 loop passes. Residue B = -1347285255287485229149608730072364769461288271450136290678, gcd(B,n) = 383
This factor is a probable prime.

===================================
*** Oct 2020: Refresher on p-1 factoring method ***

o For work modulo M(p) or F(m) need powering to base != 2, say 3, since e.g. for M(p) = 2^p-1 any stage 1 prime product which is a multiple of 2*p, i.e. which is capable of revealing a factor f = 2*p*k+1 is == 1 mod 2^p-1.

o Crandall & Pomerance exercise 5.8, find the factors of n = 67030883744037259 using p-1 with stage 1 bound b1 = 1000:
Note n = f1.f2, with f1 = 179424673 = 2^5.3.7^3.5449 + 1, f2 = 373587883 = 2.3.31.59^2.577 + 1.

define s1_ppow_prod_OBSOLETE(b1) {
	auto accum,p,j;
	p = 0;
	accum = 1;	/* Accumulator of all the small-prime powers used for the stage 1 modexp */
	while(p < b1) {
		p = next_prp(p,1);
		prod = p; j = 1;
		while(prod <= b1) {
			j += 1;
			prod *= p;
		}
		accum *= prod;
		print p,"^",j,".";
	}
	print "\n";
	return(accum);
}

gives (unmodded) stage-1 prime-powers product c =
2^10.3^7.5^5.7^4.11^3.13^3.17^3.19^3.23^3.29^3.31^3.37^2.41^2.43^2.47^2.53^2.59^2.61^2.67^2.71^2.73^2.79^2.83^2.89^2.97^2.101^2.103^2.107^2.109^2.113^2.127^2.131^2.137^2.139^2.149^2.151^2.157^2.163^2.167^2.173^2.179^2.181^2.191^2.193^2.197^2.199^2.211^2.223^2.227^2.229^2.233^2.239^2.241^2.251^2.257^2.263^2.269^2.271^2.277^2.281^2.283^2.293^2.307^2.311^2.313^2.317^2.331^2.337^2.347^2.349^2.353^2.359^2.367^2.373^2.379^2.383^2.389^2.397^2.401^2.409^2.419^2.421^2.431^2.433^2.439^2.443^2.449^2.457^2.461^2.463^2.467^2.479^2.487^2.491^2.499^2.503^2.509^2.521^2.523^2.541^2.547^2.557^2.563^2.569^2.571^2.577^2.587^2.593^2.599^2.601^2.607^2.613^2.617^2.619^2.631^2.641^2.643^2.647^2.653^2.659^2.661^2.673^2.677^2.683^2.691^2.701^2.709^2.719^2.727^2.733^2.739^2.743^2.751^2.757^2.761^2.769^2.773^2.787^2.797^2.809^2.811^2.821^2.823^2.827^2.829^2.839^2.853^2.857^2.859^2.863^2.877^2.881^2.883^2.887^2.907^2.911^2.919^2.929^2.937^2.941^2.947^2.953^2.967^2.971^2.977^2.983^2.991^2.997^2.1009^1

= 140913811235281074251071984655086916929823318012291339253563074997320882899088620155798937878414405188890891289181103809039280458112666222529194731723296673657513286482492706123116566244448507488523084557201722711135540022520380312620259795874869630805087363420863904046550724744835336859444264283416844404471891215597440651659712306822893995400969509113823356788099006540291181610019117275697333868870965426256607496903688829347702258877584265985024071519981762544339911877440486583457286283279940824534909846880536041346477472996008034214756988918416760378922383968973207573852668639842641141827744237923767627905983007946225451936116391254955215371127280075659140582704896018459756490484972531905074448313651989808939146927778615771028394420235822850759399659220656579618322757191871579441539048666159462048329091629877249445254004157089876028800000

with m = c%n = 14841381970898382	<*** No! Must use full small-p product for ensuing modpow ***

pow = modpow_lr(3,m,n) = 58968898919687488, but gcd(pow-1,n) = 1. WTF?
Aha ... Want 3^c % n, not 3^(c%n) % n:
pow = modpow_lr(3,c,n) = 29278896065119175, gcd(pow-1,n) = 373587883, finds the expected p-1-smooth factor f2.

Try single-prime Stage 2 to see if find f1: raise Stage 1 modpow to the single-prime power 5449:

	pow = modpow_lr(pow,5449,n) = 1. WTF?

Try powering using just the prime powers appearing in the factorization of f1-1:

pow = 3^(2^5*3*7^3*5449) %n = 32737450658588758, and gcd(pow-1,n) = f1, as expected.

pow = 3^(2^5*3*7^3) %n = 65996598761327758, then ^= 5449 %n = 32737450658588758and gcd(pow-1,n) = f1, as expected.

So why did the above, using the full set of prime powers < 1000, fail in the stage 2 single-prime powering?
Maybe the problem is that powering to the (c*5449)th power gives a result which includes both factors of n ...
try fiddling s1_ppow_prod() to include only the 1st power of the primes >= sqrt(b1) ... also fix the control
logic for the loop-over-primes to not include the first prime > b1, as the above version of the function does:

/* Set seed = 1 for moduli of no special form, p for M(p), 2^(m+2) for F(m): */
define s1_ppow_prod(b1,seed) {
	auto accum,p,j;
	p = 0;
	if(seed <= 0) {
		print "s1_ppow_prod requires a seed >= 1! Setting = 1.\n";
		seed = 1;
	}
	accum = seed;	/* Accumulator of all the small-prime powers used for the stage 1 modexp */
	print "Stage 1 exponent = ",seed,"*";
	while(1) {
		p = next_prp(p,1);
		if(p > b1) break;
		prod = p; j = 1;
		while(prod*p <= b1) {	/* prod.p here to include only the 1st power of the primes >= sqrt(b1) */
			j += 1;
			prod *= p;
		}
		accum *= prod;
		print p,"^",j,".";
	}
	print "\n";
	return(accum);
}

gives (unmodded) stage-1 prime-powers product c = 2^9.3^6.5^4.7^3.11^2.13^2.17^2.19^2.23^2.29^2.31^2.37^1.41^1.43^1.47^1.53^1.59^1.61^1.67^1.71^1.73^1.79^1.83^1.89^1.97^1.101^1.103^1.107^1.109^1.113^1.127^1.131^1.137^1.139^1.149^1.151^1.157^1.163^1.167^1.173^1.179^1.181^1.191^1.193^1.197^1.199^1.211^1.223^1.227^1.229^1.233^1.239^1.241^1.251^1.257^1.263^1.269^1.271^1.277^1.281^1.283^1.293^1.307^1.311^1.313^1.317^1.331^1.337^1.347^1.349^1.353^1.359^1.367^1.373^1.379^1.383^1.389^1.397^1.401^1.409^1.419^1.421^1.431^1.433^1.439^1.443^1.449^1.457^1.461^1.463^1.467^1.479^1.487^1.491^1.499^1.503^1.509^1.521^1.523^1.541^1.547^1.557^1.563^1.569^1.571^1.577^1.587^1.593^1.599^1.601^1.607^1.613^1.617^1.619^1.631^1.641^1.643^1.647^1.653^1.659^1.661^1.673^1.677^1.683^1.691^1.701^1.709^1.719^1.727^1.733^1.739^1.743^1.751^1.757^1.761^1.769^1.773^1.787^1.797^1.809^1.811^1.821^1.823^1.827^1.829^1.839^1.853^1.857^1.859^1.863^1.877^1.881^1.883^1.887^1.907^1.911^1.919^1.929^1.937^1.941^1.947^1.953^1.967^1.971^1.977^1.983^1.991^1.997^1

= 7128865274665093053166384155714272920668358861885893040452001991154324087581111499476444151913871586911717817019575256512980264067621009251465871004305131072686268143200196609974862745937188343705015434452523739745298963145674982128236956232823794011068809262317708861979540791247754558049326475737829923352751796735248042463638051137034331214781746850878453485678021888075373249921995672056932029099390891687487672697950931603520000

11/19: get this, which is 3^2.5.11^2.17.31.43 * the above because we do simple Fermat-base-2-PRP in next_prp(), thus allowing pseudoprimes like 341 = 11.13:
2^9.3^6.5^4.7^3.11^2.13^2.17^2.19^2.23^2.29^2.31^2.37^1.41^1.43^1.47^1.53^1.59^1.61^1.67^1.71^1.73^1.79^1.83^1.89^1.97^1.101^1.103^1.107^1.109^1.113^1.127^1.131^1.137^1.139^1.149^1.151^1.157^1.163^1.167^1.173^1.179^1.181^1.191^1.193^1.197^1.199^1.211^1.223^1.227^1.229^1.233^1.239^1.241^1.251^1.257^1.263^1.269^1.271^1.277^1.281^1.283^1.293^1.307^1.311^1.313^1.317^1.331^1.337^1.341^1.347^1.349^1.353^1.359^1.367^1.373^1.379^1.383^1.389^1.397^1.401^1.409^1.419^1.421^1.431^1.433^1.439^1.443^1.449^1.457^1.461^1.463^1.467^1.479^1.487^1.491^1.499^1.503^1.509^1.521^1.523^1.541^1.547^1.557^1.561^1.563^1.569^1.571^1.577^1.587^1.593^1.599^1.601^1.607^1.613^1.617^1.619^1.631^1.641^1.643^1.645^1.647^1.653^1.659^1.661^1.673^1.677^1.683^1.691^1.701^1.709^1.719^1.727^1.733^1.739^1.743^1.751^1.757^1.761^1.769^1.773^1.787^1.797^1.809^1.811^1.821^1.823^1.827^1.829^1.839^1.853^1.857^1.859^1.863^1.877^1.881^1.883^1.887^1.907^1.911^1.919^1.929^1.937^1.941^1.947^1.953^1.967^1.971^1.977^1.983^1.991^1.997^1.
=
879624591061115993175639683715130999977921628521273429822822939226829612219538466070066391544902728748830051923311839164292316185177978515575463819901501442171691479430209823536696785713541893433727986668900447339374956831931346492693438386970548878681900911045462814838578545724683918087559261667154078397911577596376047322511992719264943964238731105536334874520080866060906000863746362668805234393688962146106711132240008702511811790400000

pow = modpow_lr(3,c,n) = 4869165307189032, gcd(pow-1,n) = 1, as expected.

Try single-prime Stage 2 to see if find f1: raise Stage 1 modpow to the single-prime power 5449:

pow = modpow_rl(pow,5449,n) = 5711050738956709 - better! - and gcd(pow-1,n) = f1, as expected.

Similarly, raising pow to the 59th power finds f2, and further raising that to the 5449th again lands us on 1.

************* Prime-diff-based Stage 2 **************

/* Pollard p-1 algorithm to base [base]: b2 must be > b1 and capture at least 2 primes in [b1,b2]: */
define pm1(n,base,b1,b2) {
	auto c,d,pow1,pow2,mult,p,q,i,max_diff;
	c = s1_ppow_prod(b1);
	pow1 = modpow_lr(base,c,n);
	/* Find max prime diff in [b1,b2]: */
	q = p; max_diff = 0;
	while(q < b2) {
		q = next_prp(p,1);	d = q-p;
		if(d > max_diff) max_diff = d;
		p = q;
	}
	print "Stage 1 residue A = ",pow1,", gcd(A-1,n) = ",gcd(pow1-1,n),"\n";
	print "Stage 2 interval = [",b1,",",b2,"]: max prime diff = ",max_diff,"\n";
	/* Square the stage 1 residue: */
	s1_even_pows[0] = pow1*pow1 % n;
	/* ...and use to init remaining elements of table of stage 1 residue raised to successive even powers: */
	for(i = 1; i < max_diff/2; i++) {
		s1_even_pows[i] = s1_even_pows[i-1]*s1_even_pows[0] % n;
	}
	/* Raise stage 1 residue to the first prime in the stage 2 range: */
	p = q = next_prp(b1,1);	/* A.k.a. q1, if index stage 2 primes as q1,q2,... */
	/* Init mult = pow1^q1; this will be raised to even-prime-gap powers in loop below */
	mult = modpow_lr(pow1,p,n);
	pow2 = mult-1;
	print "Stage 2 starting residue = ",pow2,"\n";
	/* Accumulate-modmul by (pow1^qj - 1) where qj = (j)th prime in [b1,b2]: */
	while(q < b2) {
		q = next_prp(p,1);	d = q-p;
		/* (gap/2)-1 reflects 0-offset indexing of table: */
		mult = mult * s1_even_pows[d/2-1] % n;
		pow2 = pow2 * (mult - 1) % n;
		p = q;
	}
	print "Stage 2 residue B = ",pow2,", gcd(B,n) = ",gcd(pow2,n),"\n";
}

There are 2 modmuls in the stage 2 accumulation loop: the first is by an element of the precomputed table of stage 1 residue raised to successive even powers, in an actual bignum-code implementation these are stored in forward-transformed form, thus the mult-update modmul costs the same as a mod-autosquare. The second modmul to update the stage 2 product accumulator needs 2 forward transforms, one of each input, thus costs the same as 1.5 modsquares.

===================================
Oct 2020: Gather stats about prime gaps for eventual p-1 stage implementation:

define prime_gap_stats(b1,b2) {
	auto i,n;
	/* bounds properly specified? */
	if((b1 < 0) || (b1 > b2)) {
		print "Bounds must me nonnegative, with b2 > b1\n";
		return(0);
	}
	/* b1 must be odd: */
	if(!(b1%2)) {
		b1 += 1;
	}
	/* Init gap-stats array elts = 0: We gather detailed states for gaps 2,4,...,198 in array slots 0-98;
	all gaps >= 200 lumped together in slot 99: */
	for(i = 0; i < 100; i++) {
		gap[i] = 0;
	}
	i = 0; n = b1;
	while(n < b2) {
		j = next_prp(n,1);
		i += 1;
		if((j - n) >= 200) {
			gap[99] += 1;
		} else {
			gap[(j - n - 2)/2] += 1;
		}
		if(!(i%1000)) {
			print "PRP #",i," = ",j,"\n";
		}
		n = j;
	}
	print "Found ",i," PRPs between ",b1," and ",n,". Gap counts:\n";
	for(i = 0; i < 100; i++) {
		print gap[i],",";
	}
	print "\n";
}

===================================

Discussion re. p-1 on F33 - I asked Mihai re. estimated penalty for stage 2 using ~30 residue-sized
buffers and "as many buffers as we like", he replied

I estimate the penalty for P2 between "lots of memory" and "30 residue memory" to be about 25-30%.

My reply:

I wrote a little script to gather stats about prime gaps. With a view toward super-deep stage 1,
I used b1 = 10^9, here the stats for strong PRPs up to the first PRP > (b1+10^6). I binned the
resulting prime gaps into 100 bins corresponding to gaps 2,4,..., with any gaps >= 200 lumped
into the uppermost bin. Here the run output:

	Found 48156 PRPs between 1000000001 and 1001000027. Gap counts:
	3037,3067,5544,2393,3068,4125,2204,1762,3215,1762,1503,2288,1064,1210,2169,682,698,1169,550,
	645,970,407,309,635,344,261,435,239,206,419,130,137,242,101,121,161,70,55,110,70,30,94,44,35,
	65,24,24,39,30,20,25,12,10,25,10,10,11,3,2,12,4,7,4,3,4,7,2,2,1,0,0,3,3,1,6,1,3,2,0,0,0,0,0,
	0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0.

Breaking those gap stats in 10-per-line fashion and for each such 10-bin adding "% of total gaps" at left:
%
62.7	3037+3067+5544+2393+3068+4125+2204+1762+3215+1762
24.9	1503+2288+1064+1210+2169+682+698+1169+550+645
 8.8	970+407+309+635+344+261+435+239+206+419
 2.5	130+137+242+101+121+161+70+55+110+70
 0.8	30+94+44+35+65+24+24+39+30+20
 0.2	25+12+10+25+10+10+11+3+2+12
 .07	4+7+4+3+4+7+2+2+1+0
 .04	0+3+3+1+6+1+3+2+0+0
  --	0+0+0+0+0+0+0+1+0+0
  --	0+0+0+0+0+0+0+0+0+0

Thus, say we used the first 30 gaps in our stage 2, meaning perhaps 32 residue-sized arrays in total.
For this example stage 2 subinterval that captures 96.3% of prime gaps. 3.6% of stage 2 primes would
require a second modmul to cover the gap, and a mere ~0.1% would need a third. That suggests a
performance penalty of just 7-8%. Whence the discrepancy between your estimate and mine?

On 10/09/20, Mihai Preda wrote:

I do stage-2 in a different way, not directly using prime gaps. (I think mprime does the same, it's
the classic way of doing stage-2). (What I describe below corresponds to E = 2, but the same lines
extend to other E values).

It uses the "big-steps/small-steps" (maybe called "giant steps") trick.

Basically a set of precomputed 24 buffers is used (24 == 1*2*4*6 / 2), the step between these buffers
is 2 (the "small step"). Also a rolling residue is incremented in steps of 210 (210 == 2*3*5*7) ("big step").

Now any prime can be covered by a value of the form a^2 - b^2 = (a-b)*(a+b), where "a" comes from the
"big step" set, and "b" from the precomputed "small step" buffers.

This saves one multiplication per prime (i.e. halves the muls).

Above, 24 (210) comes from using as big-step the primorial up to 7. Moving to more buffers, we can take
the primorial up to 11 (2310) which requires 240 buffers instead of 24. The perf difference between
D = 210 and D = 2310 is about 20%.

- Mihai


On Mon, 12 Oct 2020 at 17:50, Mihai Preda <mpreda@gmail.comwrote:

Hi George, I just realized today that I was doing/understanding the P-1 second-stage plan suboptimally.

To simplify, let's compare only these two options: D = 210 (J = 24) and D = 2310 (J = 240).
Each requires at least J buffers, and climbs the primes in big-steps of size D.

My naive idea was that a higher D is always more efficient. So, if there is enough space for 240 buffers,
I would always choose D = 2310.

OTOH a lower D allows a better pairing (using more than J buffers). It seems that in some situations it
is actually better to run with a lower D than the buffers afford, in order to take advantage of the
improved pairing.

As an example, I was running 102227777 with B1 = 13000 and B2 = 1000000 (which BTW should find a factor).
The two plans are:

	D = 2310: 77091 primes in [12697, 1001393], selected 62554 (81.1%) (14537 doubles + 48017 singles)
	428 blocks starting at 6

	D = 210: 76972 primes in [12899, 1000141], selected 44161 (57.4%) (32811 doubles + 11350 singles)
	4693 blocks starting at 66

As you see, running the lower-D allows much better pairing, keeping only 57% vs. 81% of the primes. The
flip side is that the lower-D needs 10x as many blocks (4693 vs. 428). The cost of each block transition
depends on E. I run with E = 2 and the cost of one block is 2 MULs. If running with higher E, the increase
in the number of blocks may dwarf the pairing benefit.

Anyway, just curious whether you were aware of this tradeoff, and also of the rather surprisingly high
pairing (57% -- i.e. 85% of the primes are paired!) that can be achieved using more than the minimal
number (J) of buffers.

Regards,
Mihai

p.s.: The pairing algorithm is in the function makePlan() here https://github.com/preda/gpuowl/blob/master/Pm1Plan.h

On 10/12/20 9:54 AM, George Woltman wrote:
Hi Mihai,

If I understand what you are proposing, that is a very interesting idea!  In short, you are proposing
a big step (D) of 210, but use the extra buffers to look for pairs from a wider area than D-105 to D+105.
This gives more opportunities for a prime below D to find a pairing prime above D.  Finding an optimal
pairing strategy is a difficult problem (probably with little gain over any simple pairing algorithm).

I cannot say I understood your code, so I'll just assume it is working.

The next question is what is the optimal number value of D.  It can be any multiple of 210.  For example,
if you have 10x the minimum number of buffers for a D = 210 second stage, are you better off using D = 210
(ten opportunities to find a pairing prime) or by D = 420 (five opportunities to pair, but less costs for
stepping by D).

Well done Mihai!

Best regards,
George

On 10/13/20 6:51 PM, Mihai Preda wrote:

Hi George, yes I think your description is correct. I did a few more experiments, added one tiny improvement (called "fancy pairs" in code, which consists in pairing one prime with a *multiple* of another prime), and cleaned up a bit the code and added comments hoping to make the pairing code clearer; the pairing algo is rather simple (although probably rather slow too, but fast enough for me).

https://github.com/preda/gpuowl/blob/master/Pm1Plan.h
https://github.com/preda/gpuowl/blob/master/Pm1Plan.cpp

In my implementation it seems D=210, 330, 420 offer similar performance over a wide range of "number of buffers", while higher D values are worse. Of course this observation is heavily affected by my using E=2, the situation changes for higher E values (favoring a smaller number of buffers, thus higher D).

One more observation: the number of buffers (precomputed) does not need to be a whole multiple of J. I simply take all the memory there is, and simply fill the buffers with values that are relatively-prime to D.

Best regards,
Mihai

The pairing algo is in the function makePlan() https://github.com/preda/gpuowl/blob/1a175eb383be857e9b1d74f1eb25fc36dddd3fa8/Pm1Plan.cpp#L162

On 10/14/20 9:30 AM, George Woltman wrote:

I checked prime95.  It is doing "fancy pairing" for P-1.  Strangely. it is not for ECM.

Also, prime95 starts B2 at B2/11.  All primes from B1 to B2/11 are moved into the B2/11 to B2 range whether they pair or not.  This saves a few mul-by-D at the start of second stage.

I have a few ideas on ways to eek out maybe a few percent more in pairing.  It will be a while until I have time to measure.  Basically, your
pairing algorithm is a "greedy" algorithm -- taking the first match and using it.  Greedy is usually the fastest approach.  What if we did one pass to find out how many
possible matches each prime has, then any that have only one (or fewest) matches use those pairs, iterate until done?  The idea is that the greedy algorithm can
"steal" another prime's only match when other options are available.  This is complicated by the moving of primes from B1 to B2/11 as those have multiple possible
"replacement primes".

If you investigate this at all, I'd be interested in the results.  Also, any data you have on your current algorithm's match % as you go from minimum, to 2x, 3x, 4x would be great.

On 10/15/20 9:40 PM, Mihai Preda wrote:

Hi George, I added a small utility "D" in gpuowl for exploring pairing at different "D" values and various number-of-buffers.
It should be buildable with either "scons" or "make D" in gpuowl's folder, and use it like this:
D <B1> <B2> <nBuf>
(see a redacted example output at the end).

About the pairing algorithm, it seems it's an instance of this problem: https://en.wikipedia.org/wiki/Set_cover_problem
What I implemented right now is a variant that does this:

- for each remaining prime, count how many pairs cover it.
- select the pairs that cover primes with *one* cover only (i.e not multiple covers, let's call these "forced" pairs)
- repeat the above a number of times.
- afterwards select the remaining pairs
- afterwards generate "singles" for the remaining primes.

This seems to produce good results, but (at least in my implementation) is rather slow (as running the "D" utility shows).

The outcome of the experiments is:
- in general D=330 is overall good over a wide range of number-of-buffers (100 .. 600)
- for small number-of-buffers (<=100), D=210 may be good.
- if using E>2 larger D values become optimal. OTOH E=6 seems to have a rather large overhead compared to E=2 (20%?) that is hard to justify.

With around 300 buffers at least 75% of the primes are paired. At such a high pairing rate, the relative cost of big-steps (i.e. number of blocks) increases, so the relative cost of E>2 increases.

One more "rule of thumb" is that a doubling of the number-of-buffers brings about 10% reduction in cost. (this benefit is larger for small number-of-buffers).

Based on these results, I plan to run at the wavefront (TF=76) P-1 with B1=5M,B2=150M.

Best regards,
Mihai

$ D 5000000 150000000 313

nBuf = 313
D=210: 8095883 primes in [5000011, 149999957]: cost 5.94M (pair: 3453902, single: 1188079, (85% paired), blocks: 649340)
D=330: 8095883 primes in [5000011, 149999957]: cost 5.72M (pair: 3151372, single: 1793139, (78% paired), blocks: 389604)
D=420: 8095883 primes in [5000011, 149999957]: cost 5.74M (pair: 3003013, single: 2089857, (74% paired), blocks: 324671)
D=462: 8095883 primes in [5000011, 149999957]: cost 5.81M (pair: 2802581, single: 2490721, (69% paired), blocks: 259737)
D=660: 8095883 primes in [5000011, 149999957]: cost 5.96M (pair: 2522405, single: 3051073, (62% paired), blocks: 194803)
D=770: 8095883 primes in [5000011, 149999957]: cost 6.27M (pair: 2085857, single: 3924169, (52% paired), blocks: 129869)
D=924: 8095883 primes in [5000011, 149999957]: cost 6.27M (pair: 2088086, single: 3919711, (52% paired), blocks: 129870)
D=1540: 8095883 primes in [5000011, 149999957]: cost 6.84M (pair: 1388020, single: 5319843, (34% paired), blocks: 64935)
D=2310: 8095883 primes in [5000011, 149999957]: cost 6.79M (pair: 1427029, single: 5241825, (35% paired), blocks: 59941)

I also added a set of error checks to P2, that I described briefly here
https://mersenneforum.org/showpost.php?p=560047&postcount=98
I don't know if you'd find any of these ideas useful on a CPU; but hopefully they'd help on the flimsy GPUs.

Also, I don't know if you agree with my statement there that an error in the GCD accumulator multiplication is self-contained (i.e. it affects only the region of the accumulator before the error, but not after); I'm not 100% sure myself of that statement, although it should be true.

Let me know if you'd like me to go into more detail into any of those points.
Best regards,
Mihai

===================================
Mihai leads me through the details of the abve scheme:

On 10/18/20 3:42 PM, Mihai Preda wrote:

this is the outline:

We'll use the exponent E=2. (E=2 is the simplest case. E=4,6,12 can also be used and represents "BS-extension").
Let's call "base" the output of stage-1.
let M = base^(a^2) - base^(b^2) = base^(b^2) * (base^(a^2 - b^2) - 1)
And both base^(a-b) - 1, and base^(a+b) - 1 divide M. (because a-b, a+b divide a^2-b^2)

At this point, given a set of stage-2 primes "p", we want to "cover" them with values a,b such that a+/-b == p, or even a+/-b == a multiple of p.

Below is how to generate pairs (a,b) to efficiently cover the primes:

Choose a highly-composite small number "D". D can be a primorial such as D=210, or other highly-composite e.g. D=330.
The values "a" will be of the form k*D for successive "k".

Let's look at "b". If GCD(D, b) > 1, then a+/-b can't be prime. [ewm: because in that case a,b share a factor]
So to cover primes we only need to consider the values "b" such that GCD(D, b)==1. (this is the reason we want D highly composite, because the set of values "b" that are relative-prime with D is smaller).

Generate the set of "b" covering the range [1 .. D/2-1] and GCD(D,b)==1. Then any prime p can be written as p==k*D + b, for some k and b. I.e. the set (k*D, b) covers all the primes.
**** Q: does he mean [1 .. D-1]? No, based  on his stated buffer counts ITHM p = k*D +- b, and forgot the minus.
	Ah wait, the minus-set is implied, it is the (a-b) portion of the (a^2 - b^2) = (a - b)*(a + b) trick.
****
Generate a set of precomputed buffers base^(b^2) for the set of "b" above. The size of the set "b" determines the number of precomputed buffers needed.

Walk the values base^((k*D)^2) by iterating over "k".

For every stage-2 prime "p", multiply the accumulator "Acc" with the difference base^((k*D)^2) - precomputed[i], for some (k,i).

And that's pretty much it. The trick was that instead of 2 MULs, we now have only one MUL (for the accumulation). Also every such MUL has the potential to cover 2 primes (because of the +/- due to E=2).

Generating the precomputed buffers is the "small steps" or baby-steps, while "walking" D is giant-steps because we iterate with multiples of D.

- Mihai

EWM: bc mini-script:

define find_b(d) {
	auto i,imax,n;
	/* Enumerate the primes in [d+1,2d-1]: */
	print "Primes in [d+1,2d-1]:\n";
	imax = d+d-1; n = 0;
	for(i = d+1; i < imax; i+=2) {
		if(is_prp(i)) {
			print i,","; n += 1;
		}
	}
	print "There are ",n," primes i this interval.\n";
	imax = d; n = 0;
	for(i = 1; i < imax; i++) {
		if(gcd(i,d) == 1) {
			print i,","; n += 1;
		}
	}
	print "There are ",n," b's.\n";
	return(n);
}

For D = 210 = 2.3.5.7, the set of 24 b in [1 .. D/2-1] such that GCD(D,b)==1 is (all are prime, being < 11^2)
	  1, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103.
Here are the 48 numbers of form k*D +- b, with k = 1; * notes composites, which account for 10 of the 48:
+:	211,221*223,227,229,233,239,241,247*251,253*257,263,269,271,277,281,283,289*293,299*307,311,313;
-:	209*199,197,193,191,187*181,179,173,169*167,163,157,151,149,143*139,137,131,127,121*113,109,107
The 5 composites in each list have factorizations:
+:	11^2,13.19,11.23,17^2,13.23
-:	11.19,11.17,13^2,11.13,11^2
For D = 330 = 2.3.5.11, there are 40 b.
For D = 2310 = 2.3.5.7.11, there are 240 b.

How to use these in stage 2? In 2 ways:

1. As a small-prime sieve - loop over next length-D interval, find the 48 candidates of form k*D +- b,
	subject those to a cheap 2-prp test, use the survivors in the stage 2 accumulator update.
	WAIT - since for a given k (and thus value of a := k*D) we'll be covering both the +- branches
	of q = k*D +- b[i] by exploiting the identity (a^2 - b[i]^2) = (a - b[i])*(a + b[i]), we can't
	cull our candidates using a further PRP check because the cpomposites in the +- lists are uncorrelated,
	e.g. 221(composite) and 199(prime) in the above example. The only time we could skip a value of the
	index i is if *both* of q = a +- b[i] are composite.

2. For the stage 2 product accumulation ... let's use a concrete example, b1 = 10^3, and call our stage 1,2
accumulators pow1,pow2:

	[a] Generate a set of precomputed buffers pow1^(b^2) for the set of b-values corr. to our choice of D;

	[b] Stage 2 starts at q0, the smallest multiple of D (=210 here) nearest but not exceeding b1 + D/2;
	once have that, compute k0 = q0/D.

	[c] Our pow1^(a^2) values = pow1^((k*D)^2) and we'll be incrementing k between sweeps over the set of b's.
	(k+1)^2 = k^2 + 2*k + 1, so for some starting value k0 must precompute the following set of forward-FFTed
	multipliers (all mod n):

		mult0 = pow1^(k0*D)^2)
		mult1 = pow1^(2*k0*D + 1)
		mult2 = pow1^2 .

	pow2 = mult0;	/* Init stage 2 accumulator */
	for(q = q0; q < b2; q += D)
	{
		[d] For the resulting next batch of stage 2 powering pairs q1,q2[i] = k*D +- b[i],
		skip a given value of i only if both of q1,q2[i] are composite according to a 2-prp test.

		[inner loop:
			[e] For each of the (#buf) b[i], update the stage 2 accumulator by the difference pow1^((k*D)^2) - buf[i]:
			pow2 *= (mult0 - buf[i]);
		]
		[f] Each ensuing k++ needs 2 modmuls to update pow1^((k*D)^2) for the incremented k ... again all (mod n):
			1. mult0 *= mult1;	/* k^2 += 2*k + 1 */
			2. mult1 *= mult2;	/* 2*k++ */
		Note, these 2 extra modmuls only occur once per D-increment, i.e. each such k++ step needs (#bufs + 2) modmul.
***WAIT***:
Have: pow1^((k*D)^2)	, exp1 = D^2*(k^2)
Want: pow1^(((k+1)*D)^2), exp2 = D^2*((k+1)^2) = D^2*(k^2 + (2*k + 1)) = exp1 + D^2*(2*k + 1),
	thus need modmul by mult = pow1^(D^2*(2*k + 1))
If we precompute the following multipliers prior to entering the Stage 2 loop:
	mult1 = pow1^(D^2*(2*k0 + 1))
	mult2 = pow1^(2*D^2)
then after the first (k = k0) pass thru the loop, we want to update mult1 to increment k = k0 to k = k0+1,
which means mult1 *= mult2 (mod n).
	}

Let's try it out in bc:

/* Pollard p-1 algorithm to base [base] with difference-of-squares-enhanced stage 2: */
define pm1(n,base,b1,b2,d) {
	auto a,b,gcd1,gcd2,pow1,pow2,mult0,mult1,mult2,nq,np,ns,p1,p2,psum,q,q0,q1,q2,i,k,num_b;
	a = s1_ppow_prod(b1);
	pow1 = modpow_lr(base,a,n);
	gcd1 = gcd(pow1-1,n);
	print "Stage 1 residue A = ",pow1,", gcd(A-1,n) = ",abs(gcd1),"\n";
	print "Stage 2 interval = [",b1,",",b2,"]:\n";
	/* For our product-of-small-primes D giant-step, find all coprime b in [1,D/2-1]: */
	num_b = 0;
	for(i = 1; i < d/2; i++) {
		if(gcd(d,i) == 1) b[num_b++] = i;
	}
	print "Initializing ",num_b," [base^(pow1^(b^2)) % n] buffers for Stage 2...\n";
	/* [a] Generate a set of precomputed buffers pow1^(b^2) for the set of b-values corr. to our choice of D: */
	for(i = 0; i < num_b; i++) {
		buf[i] = modpow_lr(pow1,b[i]^2,n);
	/*	print "b[i] = ",i,": buf = ",buf[i],"\n";*/
	}
	/* [b] Stage 2 starts at q0, the smallest multiple of D nearest but not exceeding b1 + D/2;
	once have that, compute k0 = q0/D: */
	q0 = b1 + d - b1%d;
	if(q0 > b1 + d/2) q0 -= d;
	k = q0/d;
	print "Stage 2 q0 = ",q0,", k0 = ",k,"\n";
	/*
	[c] Our pow1^(a^2) values = pow1^((k*D)^2) and we'll be incrementing k between sweeps over the set of b's.
	(k+1)^2 = k^2 + 2*k + 1, so for a given starting value k0 precompute the following set of multipliers (all mod n):
	*/
	mult0 = modpow_lr(pow1,(k*d)^2,n);		/* pow1^(k0*D)^2) */
	mult1 = modpow_lr(pow1,(2*k+1)*d^2,n);	/* pow1^(D^2*(2*k0 + 1)) */
	mult2 = modpow_lr(pow1,2*d^2,n);		/* pow1^(2*D^2) */
/*	print "Stage 2 mult0,1,2 = ",mult0,",",mult1,",",mult2,"\n";*/
	pow2 = mult0;	/* Init stage 2 accumulator */
	nq = np = 0;	/* nq = # of stage 2 q's processed; np = # of those which end up getting as part of a prime-pair */
	ns = 0;			/* ns = # singleton-prime q's, i.e. prime q which end up getting paired with a composite */
	for(q = q0; q < b2; q += d)
	{
	/*	print "k = ",k,": q = ",q,"; mult0 = ",mult0,"\n";	*/
		/* [d] Generate next batch of stage 2 powering pairs q1,q2[i] = k*D +- b[i]: */
		for(i = 0; i < num_b; i++) {
			q1 = q - b[i]; q2 = q + b[i]; nq += 2;
			p1 = pprimef(q1,2); p2 = pprimef(q2,2);	/* Run q1,q2 through a base-2 Fermat-composite test */
			psum = p1+p2; np += psum;
		/*	if(q == q0) print "q1 = ",q1,"[",p1,"], q2 = ",q2,"[",p2,"]\n";	*/
			/* Skip a given value of i if both of q1,q2[i] are composite according to a 2-prp test: */
			if(!psum) continue;
			ns += 1;
			/* [e] For each prime-pair-or-single q, update stage 2 accumulator as *= pow1^((k*D)^2) - buf[i]: */
			pow2 = pow2*(mult0 - buf[i]) % n;
			if(!pow2) {
				print "k = ",k,": q = ",q,"; stage 2 accumulator = 0 ... aborting.\n";
				return(0);
			}
		}
		/* [f] Each ensuing k++ needs 2 modmuls to update pow1^((k*D)^2) for the incremented k ... again all (mod n): */
		mult0 = mult0*mult1 % n;	/* 1. k^2 += 2*k + 1 */
		mult1 = mult1*mult2 % n;	/* 2. 2*k++ */
		k += 1;
	}
	gcd2 = gcd(pow2,n)/gcd1;	/* Divide out any factors found in Stage 1 */
	print "Stage 2 residue B = ",pow2,", gcd(B,n) = ",gcd2,"\n";
	print "Processed ",nq," stage 2 q, including ",np," in prime-pairs and ",ns," prime-singletons.\n";
	print "Processed ",nq-np-ns," composite q.\n";
}

===================================
10/22: sent e-mail to Mihai/George re. the above scheme; gist:

	...in terms of cost, recall that I noted that the simple prime-gaps-based Stage 2 needs the equivalent of 2.5 modsquares (5 FFTs) per q, its advantages being that composite q are trivial to weed out and the performance drops very gracefully with the number of precomputed stage 2 buffers.

	For the (a^2 - b^2) scheme, we need around 30 buffers** for the smallest D that makes sense, D = 210. But processing each q1,q2 pair needs just a single modsquare-equivalent, so in a perfect world where all of said q's were prime, the resulting stage 2 would run 5x faster than the one based on prime gaps. Even with actual composite-q fractions and just using the dumb-as-dirt optimization of skipping pairs for which both of q1,q2 are composite, it's going to be a roughly 3x speedup. But clearly, the name of the game is now to to weed out as many of the composite q's as one can do with reasonable expense. It seems all of your & George's discussion re. 'pairing' is about this aspect, so now I need to work through that for the details.

	**(More precisely 28: Using my notation, mult2 can point to the same memory as the stage 1 residue, since the latter is no longer needed after computation of the former. So we need 3 buffers for mult0,1,2, 24 more for the precomputed pow1^(b^2) and at least one more for scratch storage.)

On 10/23/20 2:48 AM, Mihai Preda wrote:
Hi Ernst,
yes I agree with all your points. Now on the "optimization" aspect, concerned with how to minimize the "total cost" while covering all the primes in the interval..

The GpuOwl code that does that is located in
https://github.com/preda/gpuowl/blob/master/Pm1Plan.h
https://github.com/preda/gpuowl/blob/master/Pm1Plan.cpp
But it may not be readable.

My approach is to generate a large bitmap which has a set-bit for each prime that needs to be covered. Then, for each pair of values q1/q2 that I select, I can mark-off the primes that are "covered", and continue until the bitmap is clear meaning all primes of interest have been covered. In order to minimize the number of MULs there is the question of the order of selection of these pairs (q1/q2). I start by selecting pairs that cover two primes at once, and even that is done in multiple rounds (for a small benefit), and at the end I select MULs that cover only one prime each to finish clearing off all the primes.

A trick that I realized recently was that instead of using the "minimal" number of buffers that works for a given D (e.g. for D=210, that would be 24 = 1*2*4*6/2), it's beneficial (if memory allows) to allocate more buffers to get better pairing between primes -- this is what was discussed in the previous emails.

There is a small utility "D" in GpuOwl's source code that allows to see what numbers GpuOwl produces, run it like this:
./D 1000000 30000000 300
with the bounds B1, B2, and the number of precomputed buffers to use.

Are you looking into implementing a general-case P2, or in particular for the huge Fermat numbers case?
Cheers,
Mihai

EWM: Let's consider D=210, but instead of the minimal 24-bufs we use 48 and now find all coprime b in [1,D-1] as opposed to the minimal-bufs scheme where we find all coprime b in [1,D/2-1]. So in place of the original 24-coprime set

	k.D +- 1,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,
we now have
	k.D +- 1,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,
		107,109,113,121,127,131,137,139,143,149,151,157,163,167,169,173,179,181,187,191,193,197,199,209,
where, restricting ourselves to the + branch for now, the 2nd row are just a run-in-reverse version of row 1 for k+1, i.e. equal
 (k+1).D - reverse(1,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103).
Code:
/* W = window width, e.g. W=1 is just the original 24-buffer corr. to Stage 2 with D = 210, W = 2 is 2x that, etc. */
define test(w) {
	auto d,i;
	d = 210;
	if(w < 1 || w > 10) { print "Min W = 1; Max W = 10.\n"; return; }
	/* Find all ints coprime to D in [1,W*D-1]: */
	print "D = ",d,", W = ",w,"; finding all ints coprime to D in [1,W*D/2-1]: ";
	for(i = 1; i < w*d/2; i++) {
		if(gcd(d,i) == 1) {
			print i;
			if(!is_prp(i)) print "*";
			print ".";
		}
	}
	print "\n";
}

D = 210, W = 10; finding all ints coprime to D in [1,W*D/2-1]:
  1, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103,
107,109,113,121,127,131,137,139,143,149,151,157,163,167,169,173,179,181,187,191,193,197,199,209, = D-reverse(1,...,103)
211,221,223,227,229,233,239,241,247,251,253,257,263,269,271,277,281,283,289,293,299,307,311,313,   D+       (1,...,103)
317,319,323,331,337,341,347,349,353,359,361,367,373,377,379,383,389,391,397,401,403,407,409,419, 2*D-reverse(1,...,103)
421,431,433,437,439,443,449,451,457,461,463,467,473,479,481,487,491,493,499,503,509,517,521,523, 2*D+       (1,...,103)
527,529,533,541,547,551,557,559,563,569,571,577,583,587,589,593,599,601,607,611,613,617,619,629,	etc.
631,641,643,647,649,653,659,661,667,671,673,677,683,689,691,697,701,703,709,713,719,727,731,733,
737,739,743,751,757,761,767,769,773,779,781,787,793,797,799,803,809,811,817,821,823,827,829,839,
841,851,853,857,859,863,869,871,877,881,883,887,893,899,901,907,911,913,919,923,929,937,941,943,
947,949,953,961,967,971,977,979,983,989,991,997,1003,1007,1009,1013,1019,1021,1027,1031,1033,1037,1039,1049,

Now let's print out the q-pairs for 3 successive k-sweeps for a typical stage 2, and see which unpaired-prime q2's in sweep 1 could be paired with unpaired-prime q1's in sweep 3:
code:
define test(b1,d) {
	auto num_b,i,q0,q,k0,k,p1,p2,q1,q2;
	num_b = 0;
	for(i = 1; i < d/2; i++) {
		if(gcd(d,i) == 1) b[num_b++] = i;
	}
	q0 = b1 + d - b1%d;
	if(q0 > b1 + d/2) q0 -= d;
	k0 = q0/d;
	print "Stage 2 q0 = ",q0,", k0 = ",k,"\n";
	q = q0;
	for(k = k0; k < k0+5; k++)
	{
		print "k = ",k,": q = ",q,"\n";
		/* [e] Generate next batch of stage 2 powering pairs q1,q2[i] = k*D +- b[i]: */
		for(i = 0; i < num_b; i++) {
			q1 = q - b[i]; q2 = q + b[i]; nq += 2;
			p1 = pprimef(q1,2); p2 = pprimef(q2,2);	/* Run q1,q2 through a base-2 Fermat-composite test */
			print "q1 = ",q1,"[",p1,"], q2 = ",q2,"[",p2,"]\n";
		}
		q += d;
	}
}

Results: Mark unpaired q2's in the first k-batch and q1's in the third k-batch with "*":
test(10^6,210)
Stage 2 q0 = 1000020, k0 = 0
k = 4762: q = 1000020 +- 105
q1 = 1000019[0], q2 = 1000021[0]	<=== unpaired q2 = 1000230 - [109,113,131,149,191,193,197]
q1 = 1000009[0], q2 = 1000031[0]
q1 = 1000007[0], q2 = 1000033[1]*
q1 = 1000003[1], q2 = 1000037[1]*
q1 = 1000001[0], q2 = 1000039[1]*
q1 =  999997[0], q2 = 1000043[0]
q1 =  999991[0], q2 = 1000049[0]
q1 =  999989[0], q2 = 1000051[0]
q1 =  999983[1], q2 = 1000057[0]
q1 =  999979[1], q2 = 1000061[0]
q1 =  999977[0], q2 = 1000063[0]
q1 =  999973[0], q2 = 1000067[0]
q1 =  999967[0], q2 = 1000073[0]
q1 =  999961[1], q2 = 1000079[0]
q1 =  999959[1], q2 = 1000081[1]*
q1 =  999953[1], q2 = 1000087[0]
q1 =  999949[0], q2 = 1000091[0]
q1 =  999947[0], q2 = 1000093[0]
q1 =  999941[0], q2 = 1000099[1]*
q1 =  999937[0], q2 = 1000103[0]
q1 =  999931[1], q2 = 1000109[0]
q1 =  999923[0], q2 = 1000117[1]*
q1 =  999919[0], q2 = 1000121[1]*
q1 =  999917[1], q2 = 1000123[0]
k = 4763: q = 1000230 +- 105
q1 = 1000229[0], q2 = 1000231[1]*<=== unpaired q1 = 1000230 - [17,31,37,47,71,79,97]
q1 = 1000219[0], q2 = 1000241[0] <=== unpaired q2 = 1000230 + [1,23,61,73,83,103]
q1 = 1000217[0], q2 = 1000243[0]					1000335 - [2,22,32,44,82,104]
q1 = 1000213[1]* q2 = 1000247[0]					1000440 - [107,127,137,149,187,209]
q1 = 1000211[1], q2 = 1000249[1]
q1 = 1000207[0], q2 = 1000253[1]*
q1 = 1000201[0], q2 = 1000259[0]
q1 = 1000199[1]* q2 = 1000261[0]
q1 = 1000193[1]* q2 = 1000267[0]
q1 = 1000189[0], q2 = 1000271[0]
q1 = 1000187[1], q2 = 1000273[1]
q1 = 1000183[1]* q2 = 1000277[0]
q1 = 1000177[0], q2 = 1000283[0]
q1 = 1000171[1], q2 = 1000289[1]
q1 = 1000169[0], q2 = 1000291[1]*
q1 = 1000163[0], q2 = 1000297[0]
q1 = 1000159[1]* q2 = 1000301[0]
q1 = 1000157[0], q2 = 1000303[1]*
q1 = 1000151[1]* q2 = 1000309[0]
q1 = 1000147[0], q2 = 1000313[1]*
q1 = 1000141[0], q2 = 1000319[0]
q1 = 1000133[1]* q2 = 1000327[0]
q1 = 1000129[0], q2 = 1000331[0]	In terms of unpaired-q1-and-q2 24-bit subfields:
q1 = 1000127[0], q2 = 1000333[1]*	100010100100000000100001[q2]001001010000100110001000[q1]
k = 4764: q = 1000440 +- 105
q1 = 1000439[0], q2 = 1000441[0] <=== unpaired q1 = 1000440 - [11,31,37,43,47,59,73,83]
q1 = 1000429[1]* q2 = 1000451[0]					1000230 + [127,137,151,163,167,173,179,199]
q1 = 1000427[1], q2 = 1000453[1] <=== unpaired q2 = 1000440 + [67,97,101]
q1 = 1000423[1], q2 = 1000457[1]					1000650 - [109,113,143]
q1 = 1000421[0], q2 = 1000459[0]	bitmap = [00|10|00|00|00|00|00|10|10|00|10|10|00|10|00|01|00|10|00|10|00|01|01|00]
q1 = 1000417[0], q2 = 1000463[0]
q1 = 1000411[0], q2 = 1000469[0]
q1 = 1000409[1]* q2 = 1000471[0]
q1 = 1000403[1]* q2 = 1000477[0]
q1 = 1000399[0], q2 = 1000481[0]
q1 = 1000397[1]* q2 = 1000483[0]
q1 = 1000393[1]* q2 = 1000487[0]
q1 = 1000387[0], q2 = 1000493[0]
q1 = 1000381[1]* q2 = 1000499[0]
q1 = 1000379[0], q2 = 1000501[0]
q1 = 1000373[0], q2 = 1000507[1]*
q1 = 1000369[0], q2 = 1000511[0]
q1 = 1000367[1]* q2 = 1000513[0]
q1 = 1000361[0], q2 = 1000519[0]
q1 = 1000357[1]* q2 = 1000523[0]
q1 = 1000351[0], q2 = 1000529[0]
q1 = 1000343[0], q2 = 1000537[1]*
q1 = 1000339[0], q2 = 1000541[1]*	In terms of unpaired-q1-and-q2 24-bit subfields:
q1 = 1000337[0], q2 = 1000543[0]	011000001000000000000000[q2]000010100010110110000010[q1]
Set A has unpaired q2 = 1000230 - [109,113,131,149,191,193,197]
Set B has unpaired q1 = 1000230 + [127,137,151,163,167,173,179,199]
None of these indindices match, so advance our window to next k-value [Set A has k=4763, Set B has k=4765]:
k = 4765: q = 1000650
q1 = 1000649[0], q2 = 1000651[1]*<=== unpaired q1 = 1000650 - [11,31,61,103]
q1 = 1000639[1]* q2 = 1000661[0] <=== unpaired q2 = 1000650 + [1,17,19,47]
q1 = 1000637[0], q2 = 1000663[0]
q1 = 1000633[0], q2 = 1000667[1]*
q1 = 1000631[0], q2 = 1000669[1]*
q1 = 1000627[0], q2 = 1000673[0]
q1 = 1000621[1], q2 = 1000679[1]
q1 = 1000619[1]* q2 = 1000681[0]
q1 = 1000613[0], q2 = 1000687[0]
q1 = 1000609[1], q2 = 1000691[1]
q1 = 1000607[0], q2 = 1000693[0]
q1 = 1000603[0], q2 = 1000697[1]*
q1 = 1000597[0], q2 = 1000703[0]
q1 = 1000591[0], q2 = 1000709[0]
q1 = 1000589[1]* q2 = 1000711[0]
q1 = 1000583[0], q2 = 1000717[0]
q1 = 1000579[1], q2 = 1000721[1]
q1 = 1000577[1], q2 = 1000723[1]
q1 = 1000571[0], q2 = 1000729[0]
q1 = 1000567[0], q2 = 1000733[0]
q1 = 1000561[0], q2 = 1000739[0]
q1 = 1000553[0], q2 = 1000747[0]
q1 = 1000549[0], q2 = 1000751[0]	In terms of unpaired-q1-and-q2 24-bit subfields:
q1 = 1000547[1]* q2 = 1000753[0]	000000000000100000011001[q2]100000000100000010000010[q1]
Set A has unpaired q2 = 1000440 - [107,127,137,149,187,209]
Set B has unpaired q1 = 1000440 + [107,149,179,199]
This gives us 2 match-pairs, 1000440 +- [107,149]. Yay!
Try one more: advance our window to next k-value [Set A has k=4764, Set B has k=4766]:
k = 4766: q = 1000860
q1 = 1000859[1], q2 = 1000861[1] <=== unpaired q1 = 1000650 + [113,127,143,179,197,199]
q1 = 1000849[1]* q2 = 1000871[0]	bitmap = [00|10|10|00|00|00|01|10|00|00|00|01|00|01|01|10|01|00|00|10|00|10|00|00]
q1 = 1000847[1]* q2 = 1000873[0]
q1 = 1000843[0], q2 = 1000877[0]
q1 = 1000841[0], q2 = 1000879[0]
q1 = 1000837[0], q2 = 1000883[0]
q1 = 1000831[0], q2 = 1000889[1]
q1 = 1000829[1]* q2 = 1000891[0]
q1 = 1000823[0], q2 = 1000897[0]
q1 = 1000819[0], q2 = 1000901[0]
q1 = 1000817[0], q2 = 1000903[0]
q1 = 1000813[0], q2 = 1000907[1]
q1 = 1000807[0], q2 = 1000913[0]
q1 = 1000801[0], q2 = 1000919[1]
q1 = 1000799[0], q2 = 1000921[1]
q1 = 1000793[1]* q2 = 1000927[0]
q1 = 1000789[0], q2 = 1000931[1]
q1 = 1000787[0], q2 = 1000933[0]
q1 = 1000781[0], q2 = 1000939[0]
q1 = 1000777[1]* q2 = 1000943[0]
q1 = 1000771[0], q2 = 1000949[0]
q1 = 1000763[1]* q2 = 1000957[0]
q1 = 1000759[0], q2 = 1000961[0]
q1 = 1000757[0], q2 = 1000963[0]
Set A has unpaired q2 = 1000650 - [109,113,143]
Set B has unpaired q1 = 1000650 + [113,127,143,179,197,199]
This gives us 2 match-pairs, 1000650 +- [113,143].

So, now turn to generalizing this to arbitrary window widths (each extra multiple-of-D adds as many buffers as 1st):

o Consider only D=210 for now, since the bitmap for unpaired q1 and q2 for each D-width window = 24*2 = 48 bits,
  thus fits in a 64-bit word, which is convenient for advancing the extra-pairings window, no awkward 16,32,48-bit
  shift and mask ops needed, just shift-by-whole-word;

o Define W = window width, e.g. W=1 is just the original 24-buf, W = 2 is the above which needs 48-buf, etc.

o During Stage 2 setup, init a W-word pairing bitmap = 0, each word's low 48 bits encode 24 bitpairs corresponding
  to a q1,q2 pair for the D-window/k-value in question. A bit = 1 means the corr. q is an as-yet-unpaired prime.
  [0 can mean either a composite or a paired-prime; in either case there is no still-needs pairing issue.]
  The most obvious layout is e.g. bits 0:1 corr. to q1,q2 = q -+ 1, bits 2:3 corr. to q1,q2 = q -+ 11, but we are
  open to considering alternate layouts which make it easier to check for match-pairs.
  We are trying to match unpaired-q2s from k = 4764 with unpaired-q1s from k = 4766, so >>= 1 the k = 4764 bitmap:
	[For convenience, write the bitpairs in ascending order, so <<= 1 in terms of our notation]
	k = 4764: bitmap >>= 1: [0|10|00|00|00|00|00|10|10|00|10|10|00|10|00|01|00|10|00|10|00|01|01|00]
	k = 4766: bitmap:       [00|10|10|00|00|00|01|10|00|00|00|01|00|01|01|10|01|00|00|10|00|10|00|00]
  Mask off q1s from k = 4764 and q2s from k = 4766 by ANDing each bitmap with mask = 01|01|01|...|01:
	k = 4764: bitmap >>= 1: [0|-0|-0|-0|-0|-0|-0|-0|-0|-0|-0|-0|-0|-0|-0|-1|-0|-0|-0|-0|-0|-1|-1|-0]
	k = 4766: bitmap:       [0-|1-|1-|0-|0-|0-|0-|1-|0-|0-|0-|0-|0-|0-|0-|1-|0-|0-|0-|1-|0-|1-|0-|0-]
  Now AND the resulting bitmaps together and add whitespace to ease overlap against offset-list below:
	[ 0 |-0 |-0 |-0 |-0 |-0 |-0 |-0 |-0 |-0 |-0 |-0 |-0 |-0 |-0 |-1 |-0 |-0 |-0 |-0 |-0 |-1 |-0 |-0 ]
	 209,199,197,193,191,187,181,179,173,169,167,163,157,151,149,143,139,137,131,127,121,113,109,107,
  The 2 remaining 1s represent bit-pairings for pairs 1000650 +- [113,143]. Very nice!

**** need to process q-singles before they roll off the low-k end of the moving window ****
**** gather stats re. factors of stage 2 composites paired with prime-singles - what % of stage 1 primes do they cover?

10/30/2020: Need a simpler bitmap scheme, which does not differentiate between q1,q2 and allows for for prime q's from any desired D/2-interval to be matched up against multiple other such intervals in the search for prime-q-pair matches:

========================================
11/09/2020: Extended-pairing-window scheme:

Using M = 11 as an example, label the D/2-width half-intervals of the 11 words consecutively as 0,1,...,k,l.
The current loop-exec starts with the middle word and looks for pairings of prime q's in the hi and lo halves
of same, a.k.a. "0-interval pairings", then we work outward. In our notation below the bitmap is fixed and the
0-interval moves D rightward with each loop-exec::
Current loop-exec:
	0 1	2 3 4 5 6 7|8 9|A B C D E F G H I J K L		0-interval pairing of prime q1 from 8 with prime q2 from 9
Next loop-exec:
	0 1	2 3 4 5 6 7 8 9|A B|C D E F G H I J K L		0-interval pairing of prime q1 from A with prime q2 from B;
		Pvsly-unpaired q1 in 8 and q2 in 9 have another shot at pairing, with prime q2 in D and q1 in C, resp.
In this scheme, e.g. qA can possibly pair with q[1,3,5,7,9,B,D,F,H,J,L], thus M = 11 pairing opportunities, but
Note that for reasons of easing the loop logistics, we restrict ourselves to seeking pairings betwen the q1 of
a given D-subinterval with the q2 of another (or of itself, in the 0-interval case).
*/
Bitmap scheme: label q's with bits in same order as the q's appear along the number line, e.g.:

o The smallest q, the one most leftward of the 0-interval center (q_mid), given by q_mid - b[M*num_b-1],
is represented in the map via the high bit of 	map[0], corr. to the leftmost D-interval;

o The largest q, the one most rightward of the 0-interval center (q_mid), given by q_mid + b[M*num_b-1], is
represented in the map via the high bit of 	map[M-1], corr. to the leftmost D-interval;

When a given interval gets shifted from the right to the left of the 0-interval, we bit-reverse its map word.
Then, to identify remaining q-singletons in bitmap word-pairs symmetric about the 0-interval we simply AND
together said words (the word for the one left of the 0-interval having been bit-reversed).

To illustrate, let's say our current 0-interval is [A B], with its q1,q2 = given by
	q1,q2 = q -+ [1,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103],
and we attempt pairing between its neighbors [8 9] and [C D] above. Use some bits taken from actual test data.
Here are the 3 subintervals [8 9],[A B],C D], with unpaired-bits ordered as on-initial-entry -
MSB at left, and we use * to mark the 4 extended-window matches between [8 9] and [C D]:

In terms of this scheme, out test-data-based numerical example looks like this:
[8 9]:	001001010000100110001000[q1]100001000000001001010001[q2]
	unpaired q1 = 1000230 - [97,79,71,47,37,31,17] = 1000440 - [307,289,281,257*,247,241,227*]
	unpaired q2 = 1000230 + [1,23,61,73,83,103]    = 1000440 - [209,187,149*,137,127,107*]
[A B]:	000000000000000100000110[q2]000010100010110110000010[q1]	<*** Note that to do within-0-interval
	unpaired q1 = 1000440 - [83,73,59,47,43,37,31,11]	pairing using the bitmap we'd need to reverse the bits
	unpaired q2 = 1000440 + [67,97,101];	of q2 and compute AND(q1,br(q2)), but we use q's directly in 0-interval.
[C D]:	100110000001000000000000[q2]100000000100000010000010[q1]
1000650 - 103 is leftmost q of interval, closest to 0-interval, thus rightmost set bit of bitmap word.
1000650 + 47 is rightmost q of interval, farthest from 0-interval, thus leftmost set bit of bitmap word.
	unpaired q2 = 1000650 + [47,19,17,1]           = 1000440 + [257*,229,227*,211]
	unpaired q1 = 1000650 - [11,31,61,103]         = 1000440 + [199,179,149*,107*]
Now AND the 48-bit bitmap words corr. to the q's in [8 9] and [C D]:
[8 9]:	001001010000100110001000[q1]100001000000001001010001[q2]
[C D]:	000000000000100000011001[q2]010000010000001000000001[q1]
AND:	            1       1                     1        1 , the remaining 4 set-bits corr. to matches between
		1000440  -+257   -+227                 -+149    -+107

Let's convert these to indexing into the extended-window offsets array:
b[i]= 1, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103,
	107,109,113,121,127,131,137,139,143,149,151,157,163,167,169,173,179,181,187,191,193,197,199,209,
	211,221,223,227,229,233,239,241,247,251,253,257,263,269,271,277,281,283,289,293,299,307,311,313,...
[8 9] and [C D] are neighbors of the current 0-interval [A B], whose +- offsets range from 0-23;
thus we expect the 48 q's in each of [8 9] and [C D] to have offsets of form (q -+ b[i]) with i in [24,72).
In the context of the above ANDed pair of bitmap words corr. to [8 9] and [C D] the surviving 1-bits are in
positions i = 24 + [0,9,27,35], corr. to b[i] = 107,149,227,257. Thus, a set-bit [i] in word [k] of such an
ANDed result - with k ranging from 0 (the 0-interval, which whose pairing we handle separately) to (M-1)/2 -
corresponds to (q -+ b[24 + 48*(k-1) + i]). Since our specific value 24 here is more generally 'num_b' in
our notation-in-code, this is (q -+ b[num_b*(2*k-1) + i]) .
E.g. for low/high window word-pair, k = (M-1)/2, 24 = num_b, thus bit [i] corr. to (q -+ b[num_b*(M-2) + i]) .

========================================

/* Pollard p-1 algorithm to base [base] with difference-of-squares-enhanced stage 2.
M = multiplicity of the base (minimal) set of buffers, e.g. M = 1 is just the original 24-buffer corresponding
to Stage 2 with D = 210, M = 2 is 2x that, etc -- note that in out implementation, M must be odd. A given M
can be thought of as yielding an expanded "match window" for unpaired (singleton) prime q-values of width --
in terms of k-index span -- M, e.g. M = 1 just gives the basic current-k-only match window, where we do a modmul-
accumulate for each pairing of prime q's in the upper and lower halves of the current-k width-D-interval.
M = 3 gives match window expanded to [k-1,k,k+1], where the primes q's in the hi/lo halves of each of the 3
width-D subintervals has 3 chances to pair up:
	1. When a given subinterval - call it X - has just been shifted in at right of the window, its singleton
		prime q's can pair up with the corresponding prime q's in the leftmost (X-2) subinterval;
	2. When X gets shifted into the middle of the window, its prime q's are handled just as for M = 1, i.e.
		we look for pairings of prime q's in the upper and lower halves of X;
	3. When X gets shifted tot he leftmost part of the window, its prime q's
		can pair up with the corresponding prime q's in the rightmost (X+2) subinterval;
M describes both the number of pairing opportunities for each prime q and the multiplicity of residue-length
memory buffers needed, relative to the minimal M = 1 scheme.
*/
[Apr 2021: moved pm2() to bc_samp.txt]
n=2^191-1
pm2(n,3,10^3,3*10^6,3)

pm2(m,3,10^3,10^4,3)
pm2(m,3,10^3,3*10^6,3)

Original D=210 24-buf scheme:
	pm1(m,3,10^3,10^4,210)
	Processed 2064 stage 2 q, including 1079 in prime-pairs and 793 prime-singletons.
	Processed 192 composite q.
Extended-window-pairing scheme, with various M:
M = 1:	Processed 2064 stage 2 q, including 572 primes-in-pairs and 507 prime-singles [68.03 % prime].
M = 3:	Processed 2064 stage 2 q, including 772 primes-in-pairs and 299 prime-singles [78.17 % prime].
M = 5:	Processed 2064 stage 2 q, including 870 primes-in-pairs and 201 prime-singles [84.19 % prime].
M = 7:	Processed 2064 stage 2 q, including 924 primes-in-pairs and 146 prime-singles [87.99 % prime].
M = 9:	Processed 2064 stage 2 q, including 952 primes-in-pairs and 120 prime-singles [89.93 % prime].
M = 11:	Processed 2064 stage 2 q, including 970 primes-in-pairs and 101 prime-singles [91.38 % prime].

Now try b1 = 10^3, b2 = 3*10^6:
M = 1:	Processed 685488 stage 2 q, including 68730 primes-in-pairs and 148226 prime-singles [59.41 % prime].
M = 3:	Processed 685488 stage 2 q, including 123366 primes-in-pairs and 93581 prime-singles [69.86 % prime].
M = 5:	Processed 685488 stage 2 q, including 148546 primes-in-pairs and 68400 prime-singles [76.02 % prime].
M = 7:	Processed 685488 stage 2 q, including 163522 primes-in-pairs and 53421 prime-singles [80.24 % prime].
M = 9:	Processed 685488 stage 2 q, including 173486 primes-in-pairs and 43455 prime-singles [83.31 % prime].
M = 11:	Processed 685488 stage 2 q, including 180342 primes-in-pairs and 36600 prime-singles [85.56 % prime].
...
M = 99: Processed 685488 stage 2 q, including 213940 primes-in-pairs and 3031 prime-singles [98.62 % prime].

================================

On 11/14/20 2:24 AM, Mihai Preda wrote:
> Hi Ernst,
> yes, the numbers look reasonable to me (meaning that I don't see any obvious problem :)
>
> I did extract one datapoint from a plan used by GpuOwl when doing B1=5M, B2=150M:
> D=330, nBuf=327
> P2(5M,150M) D=330: 8095883 primes in [5000011, 149999957]: cost 5.69M (pair: 3184138, single: 1727607, (79% paired), blocks: 389604)
> The "cost" is the total cost in millions of MULs. The "blocks" is the number of big-steps.
> cost should be something like:
> cost := doubles + singles + 2*blocks.
>
> Cheers,
> Mihai
>

11/16:
Hi, Mihai -
Thanks for the numbers. My script-based p-1 code is too slow to handle such large bounds in a reasonable time even after commenting out the actual modmuls, so over the weekend I recoded things in C - again no modmuls yet, that will be the next task - to compare q-stats to yours for b1 = 5e6, b2 = 150e6.

My summary data for various extended-pairing-window multipliers M are below. Your example used D = 330 and 327 buffers, for my D = 210 the two bracketing values in terms of #bufs are M = 13 and 15.
[Mar 2021: filled in complete data]
M =  1: #buf =   24, #pairs:  985444, #single: 6126528 (24.34% paired), #blocks: 690476, #modmul: 8492924
M =  3: #buf =   72, #pairs: 1966026, #single: 4165361 (48.56% paired), #blocks: 690476, #modmul: 7512339
M =  5: #buf =  120, #pairs: 2473492, #single: 3150422 (61.09% paired), #blocks: 690476, #modmul: 7004866
M =  7: #buf =  168, #pairs: 2787971, #single: 2521462 (68.86% paired), #blocks: 690476, #modmul: 6690385
M =  9: #buf =  216, #pairs: 3001075, #single: 2095249 (74.12% paired), #blocks: 690476, #modmul: 6477276
M = 11: #buf =  264, #pairs: 3153849, #single: 1789701 (77.90% paired), #blocks: 690476, #modmul: 6324502
M = 13: #buf =  312, #pairs: 3269514, #single: 1558375 (80.75% paired), #blocks: 690476, #modmul: 6208841
M = 15: #buf =  360, #pairs: 3359292, #single: 1378821 (82.97% paired), #blocks: 690476, #modmul: 6119065<***
M = 17: #buf =  408, #pairs: 3431130, #single: 1235138 (84.75% paired), #blocks: 690476, #modmul: 6047220
M = 19: #buf =  456, #pairs: 3490302, #single: 1116792 (86.21% paired), #blocks: 690476, #modmul: 5988046
M = 21: #buf =  504, #pairs: 3539157, #single: 1019089 (87.41% paired), #blocks: 690476, #modmul: 5939198
M = 23: #buf =  552, #pairs: 3578677, #single:  940045 (88.39% paired), #blocks: 690476, #modmul: 5899674
M = 25: #buf =  600, #pairs: 3615255, #single:  866890 (89.29% paired), #blocks: 690476, #modmul: 5863097
M = 27: #buf =  648, #pairs: 3645541, #single:  806315 (90.04% paired), #blocks: 690476, #modmul: 5832808
M = 29: #buf =  696, #pairs: 3673495, #single:  750409 (90.73% paired), #blocks: 690476, #modmul: 5804856
M = 31: #buf =  744, #pairs: 3698102, #single:  701188 (91.34% paired), #blocks: 690476, #modmul: 5780242
M = 33: #buf =  792, #pairs: 3719302, #single:  658791 (91.86% paired), #blocks: 690476, #modmul: 5759045
M = 35: #buf =  840, #pairs: 3737727, #single:  621937 (92.32% paired), #blocks: 690476, #modmul: 5740616
M = 37: #buf =  888, #pairs: 3755002, #single:  587387 (92.75% paired), #blocks: 690476, #modmul: 5723341
M = 39: #buf =  936, #pairs: 3770227, #single:  556938 (93.12% paired), #blocks: 690476, #modmul: 5708117
M = 41: #buf =  984, #pairs: 3784692, #single:  528012 (93.48% paired), #blocks: 690476, #modmul: 5693656
M = 43: #buf = 1032, #pairs: 3797563, #single:  502271 (93.80% paired), #blocks: 690476, #modmul: 5680786
M = 45: #buf = 1080, #pairs: 3808658, #single:  480086 (94.07% paired), #blocks: 690476, #modmul: 5669696
M = 47: #buf = 1128, #pairs: 3819513, #single:  458372 (94.34% paired), #blocks: 690476, #modmul: 5658837
M = 49: #buf = 1176, #pairs: 3829638, #single:  438122 (94.59% paired), #blocks: 690476, #modmul: 5648712
M = 51: #buf = 1224, #pairs: 3838828, #single:  419745 (94.82% paired), #blocks: 690476, #modmul: 5639525
M = 53: #buf = 1272, #pairs: 3847164, #single:  403074 (95.02% paired), #blocks: 690476, #modmul: 5631190
M = 55: #buf = 1320, #pairs: 3855401, #single:  386603 (95.23% paired), #blocks: 690476, #modmul: 5622956
M = 57: #buf = 1368, #pairs: 3862906, #single:  371593 (95.41% paired), #blocks: 690476, #modmul: 5615451
M = 59: #buf = 1416, #pairs: 3869746, #single:  357911 (95.58% paired), #blocks: 690476, #modmul: 5608609
M = 61: #buf = 1464, #pairs: 3876151, #single:  345098 (95.74% paired), #blocks: 690476, #modmul: 5602201
M = 63: #buf = 1512, #pairs: 3882219, #single:  332962 (95.89% paired), #blocks: 690476, #modmul: 5596133
M = 65: #buf = 1560, #pairs: 3887944, #single:  321507 (96.03% paired), #blocks: 690476, #modmul: 5590403
M = 67: #buf = 1608, #pairs: 3893039, #single:  311321 (96.16% paired), #blocks: 690476, #modmul: 5585312
M = 69: #buf = 1656, #pairs: 3897962, #single:  301471 (96.28% paired), #blocks: 690476, #modmul: 5580385
M = 71: #buf = 1704, #pairs: 3902822, #single:  291748 (96.40% paired), #blocks: 690476, #modmul: 5575522
M = 73: #buf = 1752, #pairs: 3907320, #single:  282754 (96.51% paired), #blocks: 690476, #modmul: 5571026
M = 75: #buf = 1800, #pairs: 3911517, #single:  274360 (96.61% paired), #blocks: 690476, #modmul: 5566829
M = 77: #buf = 1848, #pairs: 3915459, #single:  266477 (96.71% paired), #blocks: 690476, #modmul: 5562888
M = 79: #buf = 1896, #pairs: 3919250, #single:  258894 (96.80% paired), #blocks: 690476, #modmul: 5559096
M = 81: #buf = 1944, #pairs: 3922918, #single:  251555 (96.89% paired), #blocks: 690476, #modmul: 5555425
M = 83: #buf = 1992, #pairs: 3926395, #single:  244597 (96.98% paired), #blocks: 690476, #modmul: 5551944
M = 85: #buf = 2040, #pairs: 3929750, #single:  237891 (97.06% paired), #blocks: 690476, #modmul: 5548593
M = 87: #buf = 2088, #pairs: 3932851, #single:  231693 (97.14% paired), #blocks: 690476, #modmul: 5545496
M = 89: #buf = 2136, #pairs: 3935705, #single:  225989 (97.21% paired), #blocks: 690476, #modmul: 5542646
M = 91: #buf = 2184, #pairs: 3938615, #single:  220172 (97.28% paired), #blocks: 690476, #modmul: 5539739
M = 93: #buf = 2232, #pairs: 3941394, #single:  214612 (97.35% paired), #blocks: 690476, #modmul: 5536958
M = 95: #buf = 2280, #pairs: 3943969, #single:  209461 (97.41% paired), #blocks: 690476, #modmul: 5534382
M = 97: #buf = 2328, #pairs: 3946598, #single:  204205 (97.48% paired), #blocks: 690476, #modmul: 5531755
M = 99: #buf = 2376, #pairs: 3949051, #single:  199293 (97.54% paired), #blocks: 690476, #modmul: 5529296

So our numbers are similar, my version needs ~8% more total modmuls, which excess is more than accounted for by the extra modmuls (~500000 more than D=330 needs for the same bounds) resulting from the small bigstep-D value. The nice thing about this scheme is that it gives a nicely scalable 'tuning knob' - low-mem systems like the ARM-core devices some folks run Mlucas on will still be able to do p-1, just with a proportional performance hit to stage 2 (e.g. a 2GB-RAM device would use the minimal M=1 scheme, at 6M FFT that would need ~1.5GB and incur 8.54M modmuls), and bigmem-system owners will get close-to-ideal throughput (128GB-RAM system could use M = 99 at 6M FFT, the resulting stage 2 for these bounds would incur just 5.58M modmul, and of course D = 330 is also in play once we have a decent amount of RAM to work with.)

Here are the #s for D = 330 - better for pretty much any #bufs, only good reason to offer D = 210 is low-mem systems:

M =  1: #buf =   40, #pairs:  936295, #single: 6224872 (23.13% paired), #blocks: 439394, #modmul: 8039955
M =  3: #buf =  120, #pairs: 1905663, #single: 4286127 (47.07% paired), #blocks: 439394, #modmul: 7070578
M =  5: #buf =  200, #pairs: 2423119, #single: 3251210 (59.85% paired), #blocks: 439394, #modmul: 6553117
M =  7: #buf =  280, #pairs: 2742942, #single: 2611560 (67.75% paired), #blocks: 439394, #modmul: 6233290
M =  9: #buf =  360, #pairs: 2958255, #single: 2180931 (73.07% paired), #blocks: 439394, #modmul: 6017974
M = 11: #buf =  440, #pairs: 3115218, #single: 1867007 (76.94% paired), #blocks: 439394, #modmul: 5861013
M = 13: #buf =  520, #pairs: 3233469, #single: 1630505 (79.86% paired), #blocks: 439394, #modmul: 5742762
M = 15: #buf =  600, #pairs: 3320697, #single: 1456046 (82.02% paired), #blocks: 439394, #modmul: 5655531
M = 17: #buf =  680, #pairs: 3397999, #single: 1301442 (83.93% paired), #blocks: 439394, #modmul: 5578229
M = 19: #buf =  760, #pairs: 3460780, #single: 1175877 (85.48% paired), #blocks: 439394, #modmul: 5515445
M = 21: #buf =  840, #pairs: 3512599, #single: 1072243 (86.76% paired), #blocks: 439394, #modmul: 5463630
M = 23: #buf =  920, #pairs: 3556263, #single:  984917 (87.84% paired), #blocks: 439394, #modmul: 5419968
M = 25: #buf = 1000, #pairs: 3593769, #single:  909898 (88.76% paired), #blocks: 439394, #modmul: 5382455
M = 25: #buf = 1000, #pairs: 3593769, #single:  909898 (88.76% paired), #blocks: 439394, #modmul: 5382455
M = 27: #buf = 1080, #pairs: 3625050, #single:  847334 (89.54% paired), #blocks: 439394, #modmul: 5351172
M = 29: #buf = 1160, #pairs: 3651559, #single:  794313 (90.19% paired), #blocks: 439394, #modmul: 5324660
M = 31: #buf = 1240, #pairs: 3677923, #single:  741589 (90.84% paired), #blocks: 439394, #modmul: 5298300
M = 33: #buf = 1320, #pairs: 3700854, #single:  695722 (91.41% paired), #blocks: 439394, #modmul: 5275364
M = 35: #buf = 1400, #pairs: 3720979, #single:  655475 (91.91% paired), #blocks: 439394, #modmul: 5255242
M = 37: #buf = 1480, #pairs: 3739103, #single:  619225 (92.35% paired), #blocks: 439394, #modmul: 5237116
M = 39: #buf = 1560, #pairs: 3755208, #single:  587011 (92.75% paired), #blocks: 439394, #modmul: 5221007
M = 41: #buf = 1640, #pairs: 3770204, #single:  557018 (93.12% paired), #blocks: 439394, #modmul: 5206010
M = 43: #buf = 1720, #pairs: 3782756, #single:  531911 (93.43% paired), #blocks: 439394, #modmul: 5193455
M = 45: #buf = 1800, #pairs: 3795545, #single:  506335 (93.75% paired), #blocks: 439394, #modmul: 5180668
M = 47: #buf = 1880, #pairs: 3806976, #single:  483474 (94.03% paired), #blocks: 439394, #modmul: 5169238
M = 49: #buf = 1960, #pairs: 3817740, #single:  461945 (94.30% paired), #blocks: 439394, #modmul: 5158473
M = 51: #buf = 2040, #pairs: 3827415, #single:  442595 (94.53% paired), #blocks: 439394, #modmul: 5148798
M = 53: #buf = 2120, #pairs: 3836172, #single:  425082 (94.75% paired), #blocks: 439394, #modmul: 5140042
M = 55: #buf = 2200, #pairs: 3844552, #single:  408322 (94.96% paired), #blocks: 439394, #modmul: 5131662
M = 57: #buf = 2280, #pairs: 3851701, #single:  394024 (95.13% paired), #blocks: 439394, #modmul: 5124513
M = 59: #buf = 2360, #pairs: 3859215, #single:  379003 (95.32% paired), #blocks: 439394, #modmul: 5117006

The nearest values to your #buf = 327 here are 280 and 360; the latter still has ~6% more modmuls than the 5.69M (assuming 'm' here means 10^6, not 2^20) you cite, so your pairing algo is more effective ... but pretty decent for a first-cut implementation using just peephole-style pairing optimizations.

Cheers,
-E

[later that day, a further note-to-self re. my pairing algo:]
In my scheme, each big-step interval of q's has M pairing oppos - consider M = 5, blocks A-E, A is just about to scroll out bottom of the extended pairing window and E has just entered at top of window:

k	A	B	C	D	E	0-window is C, A|E and B|D get ext-paired

k+1	B	C	D	E	F	0-window is D, B|F and C|E get ext-paired

k+2	C	D	E	F	G	0-window is E, C|G and D|F get ext-paired

k+4	D	E	F	G	H	0-window is F, D|H and E|G get ext-paired

k+5	E	F	G	H	I	0-window is G, E|I and F|H get ext-paired

Thus E has 5 pairing oppos: with A,C,G,I and also within-itself on step k+2.
Possible pairings with intervals an odd number away - e.g. B,D,F,H - would need half-size big-step intervals.

===========================
11/17:
A few weeks ago it occurred to me that composite q's which get processed in our pairing-algo Stage 2 might still serve a useful purpose, by way of allowing their prime factors to be eliminated from the Stage 1 prime-powers-product. That turns out to be a nonstarter because the modified Stage 2 powering is cheaper-per-prime than Stage 1 precisely because in Stage 2 we modify the "any combination of prime powers used may appear in p-1" to "any combination of Stage 1 prime powers, multiplied by any *single* Stage 2 prime". But here is the exploratory bc-code for posterity:

/* Uses binary search to find and return the index of the positive odd prime n in the primes0[] array.
If n <= 2, n composite or n > primes0[bc_dim_max], returns -1:
NOTE: Wrap various primes0[]-values here in abs() because we are calling from stage2_loop() function
below, which negates selected primes in that array as a form of hit-marking.
 */
define find_odd_prime_index(n) {
	auto lo,hi,mid;
	if(n <= 2 || n > abs(primes0[bc_dim_max-1]) || !pprimef(n,2)) {
		return -1;
	}
	lo = 0; hi = bc_dim_max-1;
	while(lo < hi) {
		/* if hi-lo odd (one even, one odd), mid on low side of 1/2-midpoint, i.e. for hi-lo = 1, mid = lo: */
		mid = (lo + hi)/2;
	/*	print "lo,hi,mid = ",lo,",",hi,",",mid,": p[mid] = ",abs(primes0[mid]),"\n";	*/
		if(abs(primes0[mid]) < n) {	/* n strictly in upper part of interval */
			lo = mid+1;
		} else {	/* n in lower part of interval, possibly at midpoint */
			hi = mid;
		}
	}
	/* Last pass thru above while() always has hi-lo = 1, i.e. , mid = lo on exit and we want to check hi-element for equality: */
/*	print "lo,hi,mid = ",lo,",",hi,",",mid,": p[hi] = ",abs(primes0[hi]),"\n";	 */
	if(abs(primes0[hi]) == n)
		return hi;
	return -1;
}

define stage2_loop(b2) {
	auto b1,b,num_b,d,factor,i,j,k,q,q0,q1,q2,nq,np,ns,p1,p2,psum,ndiv11;
	b1 = 10^6;	/* Fix b1 = 10^6 for our testing purposes */
	d = 210;
	/* First make sure to undo any negation-based primes-tagging due to previous calls to this function: */
	for(i = 0; i < bc_dim_max; i++) { if(primes0[i] < 0) primes0[i] = -primes0[i]; }
	/* For our product-of-small-primes D giant-step, find all coprime b in [1,D/2-1]: */
	num_b = 0;
	for(i = 1; i < d/2; i++) { if(gcd(d,i) == 1) b[num_b++] = i; }
	/* [b] Stage 2 starts at q0, the smallest multiple of D nearest but not exceeding b1 + D/2: */
	q0 = b1 + d - b1%d;
	if(q0 > b1 + d/2) q0 -= d;
	nq = np = 0;	/* nq = # of stage 2 q's processed; np = # of those which are prime */
	ns = 0;			/* Repurpose to = # composite q's paired with a prime q */
	ndiv11 = 0;		/* #q's divisible by 11, the smallest prime not covered by our D-sieve */
	for(q = q0; q < b2; q += d) {
		/* [e] Generate next batch of stage 2 powering pairs q1,q2[i] = k*D +- b[i]: */
		for(i = 0; i < num_b; i++) {
			q1 = q - b[i]; q2 = q + b[i]; nq += 2;
			p1 = pprimef(q1,2); p2 = pprimef(q2,2);	/* Run q1,q2 through a base-2 Fermat-composite test */
			psum = p1+p2; np += psum; ns += (psum == 1);
			/* Skip a given value of i if both of q1,q2[i] are composite according to a 2-prp test: */
			if(!psum) continue;
			ndiv11 += (q1%11 == 0) + (q2%11 == 0);
			/* Factor any surviving composite q and mark first-stage1-prime-hits by negating the primes in primes0[]: */
			if(!p1) {
				k = trialdiv(q1,b1); /* Store result to keep it from displaying */
				/* factor[] returned by call to trialdiv(n,nmax) consists of (p,e) pairs in n = p1^e1*p2^e2*...*pk^ek;
				here we only care about the prime factors, not their multiplicities: */
				for(j = 0; factor[j]; j+=2) {
					k = find_odd_prime_index(factor[j]);
		/*	print "q1 = ",q1," factor = ",factor[j]," k = ",k,"\n";	*/
					if(k != -1 && primes0[k] > 0) {
						primes0[k] = -primes0[k];
		/*	print "q1 = ",q1," hit prime factor ",factor[j]," in stage 1 list.\n";	*/
					}
				}
			}
			if(!p2) {
				k = trialdiv(q2,b2);
				for(j = 0; factor[j]; j+=2) {
					k = find_odd_prime_index(factor[j]);
		/*	print "q2 = ",q2," factor = ",factor[j]," k = ",k,"\n";	*/
					if(k != -1 && primes0[k] > 0) {
						primes0[k] = -primes0[k];
		/*	print "q2 = ",q2," hit prime factor ",factor[j]," in stage 1 list.\n";	*/
					}
				}
			}
		}
	}
	j = 0
	for(i = 0; i < bc_dim_max; i++) { j += (primes0[i] < 0); }
	print ns," composite-single-q's; ",ndiv11," div-by-11; ",j," primes < ",primes1[0]," out of ",bc_dim_max," hit.\n";
}

Results for 0-window (i.e. just the basic 24 buffers), with B1 = 10^6:
B2 = B1 + ...											% Stage 1 primes covered by Stage 2 composites:
10^3	54 composite-single-q's; 6 div-by-11; 94 primes < 821647 out of 65535 hit.				0.14
10^4	528 composite-single-q's; 77 div-by-11; 553 primes < 821647 out of 65535 hit.			0.84
10^5	4959 composite-single-q's; 723 div-by-11; 2865 primes < 821647 out of 65535 hit.		4.37
10^6	49010 composite-single-q's; 6820 div-by-11; 11589 primes < 821647 out of 65535 hit.		17.7
10^7	465140 composite-single-q's; 62277 div-by-11; 51613 primes < 821647 out of 65535 hit.	95.0
10^8	4302209 composite-single-q's; 549896 div-by-11; 65432 primes < 821647 out of 65535 hit.	99.8	<*** !!! ***

=====================================
11/23/2020: George re. p-1 assignment formats:

Hi Ernst,

There is no documentation on the worktodo lines (except the source code):

/* Pminus1=[aid?],k,b,n,c,B1,B2[,how_far_factored][,B2_start][,"factors"] */

/* Pfactor=[aid],k,b,n,c,how_far_factored,ll_tests_saved_if_factor_found */

/* PRP=k,b,n,c[,how_far_factored,tests_saved[,base,residue_type]][,known_factors] */
/* PRPDC=k,b,n,c[,how_far_factored,tests_saved[,base,residue_type]][,known_factors]*/
/* A tests_saved value of 0.0 will bypass any P-1 factoring */
/* The PRP residue type is defined in primenet.h */

AFAIK, the server issues Pfactor= lines not Pminus1= lines.

=======================================
Mar 2021: Re. computation of pow^(b[i]^2) buffers:

Speculative: can save some modmuls at the cost of adding code-fugliness, like so:
precompute pow^24, place in mul[0]. Now populate mul[]-array with needed additional powers, using the above s[i] entries:
mul[] contains powers 24*[...]:	Up-multiply to generate pow^(b[i]^2):	Action ('+' = addition of 2 exponents, i.e. modmul of powers):
------------------------------	------------------------------------	--------------------------------
*** GENERATE EACH ADDITIONAL NEEDED-MULTIPLIER AS EARLY AS POSSIBLE ***
1																		square->2
2,1																		2+1->3, replacing 1
2,3																		2+3->5
2,3,5							11,13,17,19								2+5->7; square 5->10
2,3,5,7,10						23										2+10,5+7->12; 3+10->13; 5+10->15; 7+10->17
2,3,5,7,10,12,13,15,17			29,31,37,41,43,47						3+15,5+13->18; 10+13->23; 10+15,12+13->25; 10+17,12+15->27; 13+15->28; square 15->30; 15+17->32
2,3,5,7,10,12,13,15,17,18,23,25,27,28,30,32		53,59,61,67,71,73		3+30,5+28,10+23,15+18->33; 3+32,5+30,7+28,10+25,12+23,17+18->35; 5+32,7+30,10+27,12+25->37; 10+28,13+25,15+23->38; 13+30,15+28,18+25->43; 15+32,17+30->47; 23+32,25+30,27+28->55; 25+32,27+30->57; 30+32->62
2,3,5,7,10,12,13,15,17,18,23,25,27,28,30,32,33,35,37,38,43,47,55,57,62	79,83,89,97,101,103,107,109,113
25+38,28+35,30+33->63; 3+62,10+55,18+47,27+38,28+37,30+35,32+33->65; 5+62,10+57,12+55,30+37,32+35->67; 18+55,30+43,35+38->73, replacing 38; 15+62,30+47->77; 23+55,35+43->78; 23+57,25+55,33+47,37+43->80; 33+55->88; 30+62,35+57,37+55->92, replacing any input
2,3,5,7,10,12,13,15,17,18,23*,25*,27,28*,30*,32*,33*,35,37,38,43*,47*,55*,57*,62*,63*,65*,67*,73*,77*,78*,80*,88*,92*	121,127,131,137,139,143,149,151,157,163,167,169,173,179,181,187,191,193,197,199
78+92->170
...,209
*** Need to minimize # of distinct 2-input modmul inputs, since modmul costs 1.5x modsqr - re-use each distinct as many times as possible
Now can work thru the various RHS multiple-options to minimize pre-modmul copies # of LHS powers-sequence terms:
In each LHS list use * to mark terms which are still needed for generating remaining sq-diffs or further needed terms
E.g. we use the small powers pow^2,3,5 a lot as multipliers, [thought to be continued]

To continue the sequence, use that ensuing terms satisfy b[i] = bigstep + b[i-2*num_b], so:
b[i] = bigstep + b[i-2*num_b], and the squares satisfy
b[i]^2 = (bigstep + b[i-2*num_b])^2 = bigstep^2 + 2.bigstep.b[i-2*num_b] + b[i-2*num_b]^2 .
The rightmost power-squares pow^(b[i-2*num_b]^2) we have just computed in the low 2*num_b spots of our vector-of-buffers.
The fixed-multiplier pow^(bigstep^2) can be precomputed and re-used as many times as needed.
***** How to efficiently get the pow^(2.bigstep.b[i-2*num_b]) terms? *****
I don't see an alternative to computing each pow^b[i-2*num_b], then feeding each result to modpow() to further raise to the 2*bigstep.
For bigstep = 210, 2*bigstep =  110100100, thus the latter powering needs 8 modsquare and 3 modmul;
For bigstep = 330, 2*bigstep = 1010010100, thus the latter powering needs 9 modsquare and 3 modmul.
...
============================
8 May 2021: Prime-pairing stats and #modmul for revised & improved pairing algorithm and D = [210|330|420|660|840].
Compare vs Mihai Preda's gpuowl: for B1=5.5m, B2=165m, at my maxalloc setting, he uses #buf = 146, D = 330:
	#pairs: 2665611, #single: 3526960 (60.18% paired), #blocks: 428570, #modmul: 7049711
My best-case for #buf ~= 146 is #buf = 144, D = 420 (M = 3):
	#pairs: 2202153, #single: 4455500 (49.71% paired), #blocks: 379763, #modmul: 7417179
He gets a better pairing %, but my larger D means 97614 fewer block-modmul, total #modmul just 5% higher.
And with just a few more 10s of buffers, #buf = 168, D = 210 (M = 7):
	#pairs: 3166393, #single: 2527009 (71.48% paired), #blocks: 759525, #modmul: 7212452
So not bad for a first-cut peephole-optimized pairing algo.
D = 210:
M =  1: #buf =   24, #pairs:  996226, #single: 6104964 (24.61% paired), #blocks: 690476, #modmul: 8482142
M =  2: #buf =   48, #pairs: 1600852, #single: 4895715 (39.54% paired), #blocks: 690476, #modmul: 7877519
M =  3: #buf =   72, #pairs: 2015823, #single: 4065766 (49.79% paired), #blocks: 690476, #modmul: 7462541
M =  4: #buf =   96, #pairs: 2321406, #single: 3454603 (57.34% paired), #blocks: 690476, #modmul: 7156961
M =  5: #buf =  120, #pairs: 2548391, #single: 3000627 (62.94% paired), #blocks: 690476, #modmul: 6929970
M =  6: #buf =  144, #pairs: 2729440, #single: 2638532 (67.42% paired), #blocks: 690476, #modmul: 6748924
M =  7: #buf =  168, #pairs: 2873910, #single: 2349587 (70.98% paired), #blocks: 690476, #modmul: 6604449
M =  8: #buf =  192, #pairs: 2991277, #single: 2114855 (73.88% paired), #blocks: 690476, #modmul: 6487084
M =  9: #buf =  216, #pairs: 3088843, #single: 1919716 (76.29% paired), #blocks: 690476, #modmul: 6389511
M = 10: #buf =  240, #pairs: 3170900, #single: 1755610 (78.32% paired), #blocks: 690476, #modmul: 6307462
M = 11: #buf =  264, #pairs: 3241697, #single: 1614011 (80.07% paired), #blocks: 690476, #modmul: 6236660
M = 12: #buf =  288, #pairs: 3301220, #single: 1494970 (81.54% paired), #blocks: 690476, #modmul: 6177142
M = 13: #buf =  312, #pairs: 3356000, #single: 1385407 (82.89% paired), #blocks: 690476, #modmul: 6122359
M = 14: #buf =  336, #pairs: 3400027, #single: 1297354 (83.98% paired), #blocks: 690476, #modmul: 6078333
M = 15: #buf =  360, #pairs: 3442262, #single: 1212885 (85.02% paired), #blocks: 690476, #modmul: 6036099
M = 16: #buf =  384, #pairs: 3477327, #single: 1142754 (85.89% paired), #blocks: 690476, #modmul: 6001033
M = 17: #buf =  408, #pairs: 3509931, #single: 1077542 (86.69% paired), #blocks: 690476, #modmul: 5968425
M = 18: #buf =  432, #pairs: 3539116, #single: 1019174 (87.41% paired), #blocks: 690476, #modmul: 5939242
M = 19: #buf =  456, #pairs: 3564868, #single:  967668 (88.05% paired), #blocks: 690476, #modmul: 5913488
M = 20: #buf =  480, #pairs: 3589621, #single:  918166 (88.66% paired), #blocks: 690476, #modmul: 5888739
M = 21: #buf =  504, #pairs: 3610428, #single:  876554 (89.17% paired), #blocks: 690476, #modmul: 5867934
M = 22: #buf =  528, #pairs: 3631976, #single:  833453 (89.71% paired), #blocks: 690476, #modmul: 5846381
M = 23: #buf =  552, #pairs: 3649128, #single:  799151 (90.13% paired), #blocks: 690476, #modmul: 5829231
M = 24: #buf =  576, #pairs: 3667859, #single:  761683 (90.59% paired), #blocks: 690476, #modmul: 5810494
M = 25: #buf =  600, #pairs: 3682406, #single:  732595 (90.95% paired), #blocks: 690476, #modmul: 5795953
M = 26: #buf =  624, #pairs: 3698231, #single:  700939 (91.34% paired), #blocks: 690476, #modmul: 5780122
M = 27: #buf =  648, #pairs: 3711427, #single:  674548 (91.67% paired), #blocks: 690476, #modmul: 5766927
M = 28: #buf =  672, #pairs: 3724768, #single:  647864 (92.00% paired), #blocks: 690476, #modmul: 5753584
M = 29: #buf =  696, #pairs: 3736367, #single:  624672 (92.29% paired), #blocks: 690476, #modmul: 5741991
M = 30: #buf =  720, #pairs: 3747986, #single:  601431 (92.57% paired), #blocks: 690476, #modmul: 5730369
M = 31: #buf =  744, #pairs: 3758131, #single:  581144 (92.82% paired), #blocks: 690476, #modmul: 5720227
M = 32: #buf =  768, #pairs: 3768152, #single:  561097 (93.07% paired), #blocks: 690476, #modmul: 5710201
M = 33: #buf =  792, #pairs: 3776827, #single:  543749 (93.28% paired), #blocks: 690476, #modmul: 5701528
M = 34: #buf =  816, #pairs: 3786051, #single:  525294 (93.51% paired), #blocks: 690476, #modmul: 5692297
M = 35: #buf =  840, #pairs: 3794047, #single:  509312 (93.71% paired), #blocks: 690476, #modmul: 5684311
M = 36: #buf =  864, #pairs: 3801953, #single:  493498 (93.91% paired), #blocks: 690476, #modmul: 5676403
M = 37: #buf =  888, #pairs: 3809046, #single:  479315 (94.08% paired), #blocks: 690476, #modmul: 5669313
M = 38: #buf =  912, #pairs: 3816169, #single:  465064 (94.26% paired), #blocks: 690476, #modmul: 5662185
M = 39: #buf =  936, #pairs: 3822589, #single:  452229 (94.42% paired), #blocks: 690476, #modmul: 5655770
M = 40: #buf =  960, #pairs: 3829112, #single:  439181 (94.58% paired), #blocks: 690476, #modmul: 5649245
M = 41: #buf =  984, #pairs: 3835103, #single:  427197 (94.72% paired), #blocks: 690476, #modmul: 5643252
M = 42: #buf = 1008, #pairs: 3840807, #single:  415788 (94.87% paired), #blocks: 690476, #modmul: 5637547
M = 43: #buf = 1032, #pairs: 3846070, #single:  405265 (95.00% paired), #blocks: 690476, #modmul: 5632287
M = 44: #buf = 1056, #pairs: 3851481, #single:  394443 (95.13% paired), #blocks: 690476, #modmul: 5626876
M = 45: #buf = 1080, #pairs: 3856034, #single:  385344 (95.24% paired), #blocks: 690476, #modmul: 5622330
M = 46: #buf = 1104, #pairs: 3861119, #single:  375167 (95.37% paired), #blocks: 690476, #modmul: 5617238
M = 47: #buf = 1128, #pairs: 3865315, #single:  366782 (95.47% paired), #blocks: 690476, #modmul: 5613049
M = 48: #buf = 1152, #pairs: 3870118, #single:  357169 (95.59% paired), #blocks: 690476, #modmul: 5608239
M = 49: #buf = 1176, #pairs: 3873956, #single:  349498 (95.68% paired), #blocks: 690476, #modmul: 5604406
M = 50: #buf = 1200, #pairs: 3878222, #single:  340960 (95.79% paired), #blocks: 690476, #modmul: 5600134
M = 51: #buf = 1224, #pairs: 3881820, #single:  333766 (95.88% paired), #blocks: 690476, #modmul: 5596538
M = 52: #buf = 1248, #pairs: 3885696, #single:  326013 (95.97% paired), #blocks: 690476, #modmul: 5592661
M = 53: #buf = 1272, #pairs: 3889205, #single:  318990 (96.06% paired), #blocks: 690476, #modmul: 5589147
M = 54: #buf = 1296, #pairs: 3892687, #single:  312024 (96.15% paired), #blocks: 690476, #modmul: 5585663
M = 55: #buf = 1320, #pairs: 3895865, #single:  305665 (96.23% paired), #blocks: 690476, #modmul: 5582482
M = 56: #buf = 1344, #pairs: 3899120, #single:  299162 (96.31% paired), #blocks: 690476, #modmul: 5579234
M = 57: #buf = 1368, #pairs: 3901908, #single:  293585 (96.37% paired), #blocks: 690476, #modmul: 5576445
M = 58: #buf = 1392, #pairs: 3905004, #single:  287395 (96.45% paired), #blocks: 690476, #modmul: 5573351
M = 59: #buf = 1416, #pairs: 3907803, #single:  281800 (96.52% paired), #blocks: 690476, #modmul: 5570555
M = 60: #buf = 1440, #pairs: 3910560, #single:  276279 (96.59% paired), #blocks: 690476, #modmul: 5567791
M = 61: #buf = 1464, #pairs: 3913086, #single:  271230 (96.65% paired), #blocks: 690476, #modmul: 5565268
M = 62: #buf = 1488, #pairs: 3915757, #single:  265887 (96.72% paired), #blocks: 690476, #modmul: 5562596
M = 63: #buf = 1512, #pairs: 3918049, #single:  261308 (96.77% paired), #blocks: 690476, #modmul: 5560309
M = 64: #buf = 1536, #pairs: 3920565, #single:  256276 (96.84% paired), #blocks: 690476, #modmul: 5557793
M = 65: #buf = 1560, #pairs: 3922815, #single:  251771 (96.89% paired), #blocks: 690476, #modmul: 5555538
M = 66: #buf = 1584, #pairs: 3925114, #single:  247175 (96.95% paired), #blocks: 690476, #modmul: 5553241
M = 67: #buf = 1608, #pairs: 3927327, #single:  242745 (97.00% paired), #blocks: 690476, #modmul: 5551024
M = 68: #buf = 1632, #pairs: 3929407, #single:  238590 (97.05% paired), #blocks: 690476, #modmul: 5548949
M = 69: #buf = 1656, #pairs: 3931496, #single:  234402 (97.11% paired), #blocks: 690476, #modmul: 5546850
M = 70: #buf = 1680, #pairs: 3933476, #single:  230452 (97.15% paired), #blocks: 690476, #modmul: 5544880
M = 71: #buf = 1704, #pairs: 3935385, #single:  226626 (97.20% paired), #blocks: 690476, #modmul: 5542963
M = 72: #buf = 1728, #pairs: 3937205, #single:  222994 (97.25% paired), #blocks: 690476, #modmul: 5541151
M = 73: #buf = 1752, #pairs: 3938947, #single:  219504 (97.29% paired), #blocks: 690476, #modmul: 5539403
M = 74: #buf = 1776, #pairs: 3940764, #single:  215880 (97.33% paired), #blocks: 690476, #modmul: 5537596
M = 75: #buf = 1800, #pairs: 3942439, #single:  212521 (97.38% paired), #blocks: 690476, #modmul: 5535912
M = 76: #buf = 1824, #pairs: 3944133, #single:  209141 (97.42% paired), #blocks: 690476, #modmul: 5534226
M = 77: #buf = 1848, #pairs: 3945729, #single:  205940 (97.46% paired), #blocks: 690476, #modmul: 5532621
M = 78: #buf = 1872, #pairs: 3947395, #single:  202616 (97.50% paired), #blocks: 690476, #modmul: 5530963
M = 79: #buf = 1896, #pairs: 3948853, #single:  199690 (97.53% paired), #blocks: 690476, #modmul: 5529495
M = 80: #buf = 1920, #pairs: 3950438, #single:  196533 (97.57% paired), #blocks: 690476, #modmul: 5527923
M = 81: #buf = 1944, #pairs: 3951738, #single:  193923 (97.61% paired), #blocks: 690476, #modmul: 5526613
M = 82: #buf = 1968, #pairs: 3953355, #single:  190699 (97.64% paired), #blocks: 690476, #modmul: 5525006
M = 83: #buf = 1992, #pairs: 3954529, #single:  188343 (97.67% paired), #blocks: 690476, #modmul: 5523824
M = 84: #buf = 2016, #pairs: 3956163, #single:  185082 (97.71% paired), #blocks: 690476, #modmul: 5522197
M = 85: #buf = 2040, #pairs: 3957192, #single:  183015 (97.74% paired), #blocks: 690476, #modmul: 5521159
M = 86: #buf = 2064, #pairs: 3958696, #single:  180016 (97.78% paired), #blocks: 690476, #modmul: 5519664
M = 87: #buf = 2088, #pairs: 3959715, #single:  177967 (97.80% paired), #blocks: 690476, #modmul: 5518634
M = 88: #buf = 2112, #pairs: 3961108, #single:  175188 (97.84% paired), #blocks: 690476, #modmul: 5517248
M = 89: #buf = 2136, #pairs: 3962097, #single:  173207 (97.86% paired), #blocks: 690476, #modmul: 5516256
M = 90: #buf = 2160, #pairs: 3963507, #single:  170391 (97.90% paired), #blocks: 690476, #modmul: 5514850
M = 91: #buf = 2184, #pairs: 3964433, #single:  168538 (97.92% paired), #blocks: 690476, #modmul: 5513923
M = 92: #buf = 2208, #pairs: 3965749, #single:  165910 (97.95% paired), #blocks: 690476, #modmul: 5512611
M = 93: #buf = 2232, #pairs: 3966585, #single:  164230 (97.97% paired), #blocks: 690476, #modmul: 5511767
M = 94: #buf = 2256, #pairs: 3967922, #single:  161565 (98.00% paired), #blocks: 690476, #modmul: 5510439
M = 95: #buf = 2280, #pairs: 3968706, #single:  159991 (98.02% paired), #blocks: 690476, #modmul: 5509649
M = 96: #buf = 2304, #pairs: 3969986, #single:  157438 (98.06% paired), #blocks: 690476, #modmul: 5508376
M = 97: #buf = 2328, #pairs: 3970667, #single:  156068 (98.07% paired), #blocks: 690476, #modmul: 5507687
M = 98: #buf = 2352, #pairs: 3971900, #single:  153611 (98.10% paired), #blocks: 690476, #modmul: 5506463
M = 99: #buf = 2376, #pairs: 3972590, #single:  152226 (98.12% paired), #blocks: 690476, #modmul: 5505768
M = 100:#buf = 2400, #pairs: 3973769, #single:  149872 (98.15% paired), #blocks: 690476, #modmul: 5504593
D = 330:
M =  1: #buf =   40, #pairs:  928462, #single: 6240538 (22.93% paired), #blocks: 439394, #modmul: 8047788
M =  2: #buf =   80, #pairs: 1536017, #single: 5025435 (37.94% paired), #blocks: 439394, #modmul: 7440240
M =  3: #buf =  120, #pairs: 1939760, #single: 4217931 (47.91% paired), #blocks: 439394, #modmul: 7036479
M =  4: #buf =  160, #pairs: 2256031, #single: 3585401 (55.72% paired), #blocks: 439394, #modmul: 6720220
M =  5: #buf =  200, #pairs: 2492189, #single: 3113068 (61.55% paired), #blocks: 439394, #modmul: 6484045
M =  6: #buf =  240, #pairs: 2673417, #single: 2750624 (66.03% paired), #blocks: 439394, #modmul: 6302829
M =  7: #buf =  280, #pairs: 2821890, #single: 2453665 (69.70% paired), #blocks: 439394, #modmul: 6154343
M =  8: #buf =  320, #pairs: 2937749, #single: 2221955 (72.56% paired), #blocks: 439394, #modmul: 6038492
M =  9: #buf =  360, #pairs: 3039674, #single: 2018097 (75.08% paired), #blocks: 439394, #modmul: 5936559
M = 10: #buf =  400, #pairs: 3122860, #single: 1851732 (77.13% paired), #blocks: 439394, #modmul: 5853380
M = 11: #buf =  440, #pairs: 3195485, #single: 1706467 (78.93% paired), #blocks: 439394, #modmul: 5780740
M = 12: #buf =  480, #pairs: 3258915, #single: 1579624 (80.49% paired), #blocks: 439394, #modmul: 5717327
M = 13: #buf =  520, #pairs: 3311716, #single: 1474005 (81.80% paired), #blocks: 439394, #modmul: 5664509
M = 14: #buf =  560, #pairs: 3361943, #single: 1373561 (83.04% paired), #blocks: 439394, #modmul: 5614292
M = 15: #buf =  600, #pairs: 3402734, #single: 1291969 (84.04% paired), #blocks: 439394, #modmul: 5573491
M = 16: #buf =  640, #pairs: 3442429, #single: 1212597 (85.02% paired), #blocks: 439394, #modmul: 5533814
M = 17: #buf =  680, #pairs: 3474854, #single: 1147731 (85.83% paired), #blocks: 439394, #modmul: 5501373
M = 18: #buf =  720, #pairs: 3507107, #single: 1083238 (86.62% paired), #blocks: 439394, #modmul: 5469133
M = 19: #buf =  760, #pairs: 3534294, #single: 1028847 (87.29% paired), #blocks: 439394, #modmul: 5441929
M = 20: #buf =  800, #pairs: 3560370, #single:  976717 (87.94% paired), #blocks: 439394, #modmul: 5415875
M = 21: #buf =  840, #pairs: 3583676, #single:  930087 (88.51% paired), #blocks: 439394, #modmul: 5392551
M = 22: #buf =  880, #pairs: 3604676, #single:  888102 (89.03% paired), #blocks: 439394, #modmul: 5371566
M = 23: #buf =  920, #pairs: 3624901, #single:  847635 (89.53% paired), #blocks: 439394, #modmul: 5351324
M = 24: #buf =  960, #pairs: 3642406, #single:  812640 (89.96% paired), #blocks: 439394, #modmul: 5333834
M = 25: #buf = 1000, #pairs: 3659475, #single:  778489 (90.39% paired), #blocks: 439394, #modmul: 5316752
M = 26: #buf = 1040, #pairs: 3674704, #single:  748044 (90.76% paired), #blocks: 439394, #modmul: 5301536
M = 27: #buf = 1080, #pairs: 3689108, #single:  719220 (91.12% paired), #blocks: 439394, #modmul: 5287116
M = 28: #buf = 1120, #pairs: 3702518, #single:  692413 (91.45% paired), #blocks: 439394, #modmul: 5273719
M = 29: #buf = 1160, #pairs: 3715063, #single:  667306 (91.76% paired), #blocks: 439394, #modmul: 5261157
M = 30: #buf = 1200, #pairs: 3727100, #single:  643249 (92.06% paired), #blocks: 439394, #modmul: 5249137
M = 31: #buf = 1240, #pairs: 3738046, #single:  621339 (92.33% paired), #blocks: 439394, #modmul: 5238173
M = 32: #buf = 1280, #pairs: 3748509, #single:  600427 (92.58% paired), #blocks: 439394, #modmul: 5227724
M = 33: #buf = 1320, #pairs: 3758037, #single:  581354 (92.82% paired), #blocks: 439394, #modmul: 5218179
M = 34: #buf = 1360, #pairs: 3767406, #single:  562631 (93.05% paired), #blocks: 439394, #modmul: 5208825
M = 35: #buf = 1400, #pairs: 3776202, #single:  545027 (93.27% paired), #blocks: 439394, #modmul: 5200017
M = 36: #buf = 1440, #pairs: 3784311, #single:  528822 (93.47% paired), #blocks: 439394, #modmul: 5191921
M = 37: #buf = 1480, #pairs: 3792542, #single:  512348 (93.67% paired), #blocks: 439394, #modmul: 5183678
M = 38: #buf = 1520, #pairs: 3799763, #single:  497917 (93.85% paired), #blocks: 439394, #modmul: 5176468
M = 39: #buf = 1560, #pairs: 3806869, #single:  483686 (94.03% paired), #blocks: 439394, #modmul: 5169343
M = 40: #buf = 1600, #pairs: 3813306, #single:  470819 (94.19% paired), #blocks: 439394, #modmul: 5162913
M = 41: #buf = 1640, #pairs: 3819639, #single:  458141 (94.34% paired), #blocks: 439394, #modmul: 5156568
M = 42: #buf = 1680, #pairs: 3825793, #single:  445843 (94.49% paired), #blocks: 439394, #modmul: 5150424
M = 43: #buf = 1720, #pairs: 3831484, #single:  434455 (94.63% paired), #blocks: 439394, #modmul: 5144727
M = 44: #buf = 1760, #pairs: 3837095, #single:  423244 (94.77% paired), #blocks: 439394, #modmul: 5139127
M = 45: #buf = 1800, #pairs: 3842056, #single:  413316 (94.90% paired), #blocks: 439394, #modmul: 5134160
M = 46: #buf = 1840, #pairs: 3847518, #single:  402396 (95.03% paired), #blocks: 439394, #modmul: 5128702
M = 47: #buf = 1880, #pairs: 3852061, #single:  393305 (95.14% paired), #blocks: 439394, #modmul: 5124154
M = 48: #buf = 1920, #pairs: 3856872, #single:  383692 (95.26% paired), #blocks: 439394, #modmul: 5119352
M = 49: #buf = 1960, #pairs: 3861149, #single:  375130 (95.37% paired), #blocks: 439394, #modmul: 5115067
M = 50: #buf = 2000, #pairs: 3865394, #single:  366646 (95.47% paired), #blocks: 439394, #modmul: 5110828
M = 51: #buf = 2040, #pairs: 3869383, #single:  358666 (95.57% paired), #blocks: 439394, #modmul: 5106837
M = 52: #buf = 2080, #pairs: 3873464, #single:  350506 (95.67% paired), #blocks: 439394, #modmul: 5102758
M = 53: #buf = 2120, #pairs: 3876944, #single:  343542 (95.76% paired), #blocks: 439394, #modmul: 5099274
M = 54: #buf = 2160, #pairs: 3880877, #single:  335680 (95.85% paired), #blocks: 439394, #modmul: 5095345
M = 55: #buf = 2200, #pairs: 3884106, #single:  329214 (95.93% paired), #blocks: 439394, #modmul: 5092108
M = 56: #buf = 2240, #pairs: 3887698, #single:  322044 (96.02% paired), #blocks: 439394, #modmul: 5088530
M = 57: #buf = 2280, #pairs: 3890752, #single:  315929 (96.10% paired), #blocks: 439394, #modmul: 5085469
M = 58: #buf = 2320, #pairs: 3893979, #single:  309489 (96.18% paired), #blocks: 439394, #modmul: 5082256
M = 59: #buf = 2360, #pairs: 3896828, #single:  303783 (96.25% paired), #blocks: 439394, #modmul: 5079399
M = 60: #buf = 2400, #pairs: 3899891, #single:  297672 (96.32% paired), #blocks: 439394, #modmul: 5076351
D = 420:
M =  1: #buf =   48, #pairs:  988787, #single: 6119842 (24.42% paired), #blocks: 345238, #modmul: 7799105
M =  2: #buf =   96, #pairs: 1604362, #single: 4888701 (39.63% paired), #blocks: 345238, #modmul: 7183539
M =  3: #buf =  144, #pairs: 2019925, #single: 4057555 (49.89% paired), #blocks: 345238, #modmul: 6767956
M =  4: #buf =  192, #pairs: 2321271, #single: 3454873 (57.33% paired), #blocks: 345238, #modmul: 6466620
M =  5: #buf =  240, #pairs: 2549842, #single: 2997711 (62.98% paired), #blocks: 345238, #modmul: 6238029
M =  6: #buf =  288, #pairs: 2728969, #single: 2639470 (67.40% paired), #blocks: 345238, #modmul: 6058915
M =  7: #buf =  336, #pairs: 2873823, #single: 2349749 (70.98% paired), #blocks: 345238, #modmul: 5914048
M =  8: #buf =  384, #pairs: 2990979, #single: 2115450 (73.87% paired), #blocks: 345238, #modmul: 5796905
M =  9: #buf =  432, #pairs: 3088715, #single: 1919959 (76.29% paired), #blocks: 345238, #modmul: 5699150
M = 10: #buf =  480, #pairs: 3170839, #single: 1755727 (78.32% paired), #blocks: 345238, #modmul: 5617042
M = 11: #buf =  528, #pairs: 3240589, #single: 1616207 (80.04% paired), #blocks: 345238, #modmul: 5547272
M = 12: #buf =  576, #pairs: 3300949, #single: 1495501 (81.53% paired), #blocks: 345238, #modmul: 5486926
M = 13: #buf =  624, #pairs: 3353364, #single: 1390652 (82.83% paired), #blocks: 345238, #modmul: 5434492
M = 14: #buf =  672, #pairs: 3399432, #single: 1298532 (83.96% paired), #blocks: 345238, #modmul: 5388440
M = 15: #buf =  720, #pairs: 3440809, #single: 1215763 (84.99% paired), #blocks: 345238, #modmul: 5347048
M = 16: #buf =  768, #pairs: 3477012, #single: 1143377 (85.88% paired), #blocks: 345238, #modmul: 5310865
M = 17: #buf =  816, #pairs: 3509654, #single: 1078075 (86.69% paired), #blocks: 345238, #modmul: 5278205
M = 18: #buf =  864, #pairs: 3539077, #single: 1019246 (87.41% paired), #blocks: 345238, #modmul: 5248799
M = 19: #buf =  912, #pairs: 3565510, #single:  966355 (88.07% paired), #blocks: 345238, #modmul: 5222341
M = 20: #buf =  960, #pairs: 3589871, #single:  917648 (88.67% paired), #blocks: 345238, #modmul: 5197995
M = 21: #buf = 1008, #pairs: 3611834, #single:  873709 (89.21% paired), #blocks: 345238, #modmul: 5176019
M = 22: #buf = 1056, #pairs: 3631939, #single:  833516 (89.71% paired), #blocks: 345238, #modmul: 5155931
M = 23: #buf = 1104, #pairs: 3650562, #single:  796251 (90.17% paired), #blocks: 345238, #modmul: 5137289
M = 24: #buf = 1152, #pairs: 3667625, #single:  762141 (90.59% paired), #blocks: 345238, #modmul: 5120242
M = 25: #buf = 1200, #pairs: 3683353, #single:  730670 (90.98% paired), #blocks: 345238, #modmul: 5104499
M = 26: #buf = 1248, #pairs: 3698118, #single:  701159 (91.34% paired), #blocks: 345238, #modmul: 5089753
M = 27: #buf = 1296, #pairs: 3711643, #single:  674093 (91.68% paired), #blocks: 345238, #modmul: 5076212
M = 28: #buf = 1344, #pairs: 3724511, #single:  648381 (91.99% paired), #blocks: 345238, #modmul: 5063368
M = 29: #buf = 1392, #pairs: 3736490, #single:  624408 (92.29% paired), #blocks: 345238, #modmul: 5051374
M = 30: #buf = 1440, #pairs: 3747399, #single:  602604 (92.56% paired), #blocks: 345238, #modmul: 5040479
M = 31: #buf = 1488, #pairs: 3758076, #single:  581239 (92.82% paired), #blocks: 345238, #modmul: 5029791
M = 32: #buf = 1536, #pairs: 3767893, #single:  561622 (93.06% paired), #blocks: 345238, #modmul: 5019991
M = 33: #buf = 1584, #pairs: 3777125, #single:  543139 (93.29% paired), #blocks: 345238, #modmul: 5010740
M = 34: #buf = 1632, #pairs: 3785733, #single:  525940 (93.50% paired), #blocks: 345238, #modmul: 5002149
M = 35: #buf = 1680, #pairs: 3793903, #single:  509584 (93.71% paired), #blocks: 345238, #modmul: 4993963
M = 36: #buf = 1728, #pairs: 3801632, #single:  494147 (93.90% paired), #blocks: 345238, #modmul: 4986255
M = 37: #buf = 1776, #pairs: 3808960, #single:  479473 (94.08% paired), #blocks: 345238, #modmul: 4978909
M = 38: #buf = 1824, #pairs: 3815983, #single:  465438 (94.25% paired), #blocks: 345238, #modmul: 4971897
M = 39: #buf = 1872, #pairs: 3822583, #single:  452225 (94.42% paired), #blocks: 345238, #modmul: 4965284
M = 40: #buf = 1920, #pairs: 3828832, #single:  439743 (94.57% paired), #blocks: 345238, #modmul: 4959051
M = 41: #buf = 1968, #pairs: 3834822, #single:  427744 (94.72% paired), #blocks: 345238, #modmul: 4953042
M = 42: #buf = 2016, #pairs: 3840528, #single:  416347 (94.86% paired), #blocks: 345238, #modmul: 4947351
M = 43: #buf = 2064, #pairs: 3845983, #single:  405419 (94.99% paired), #blocks: 345238, #modmul: 4941878
M = 44: #buf = 2112, #pairs: 3851138, #single:  395128 (95.12% paired), #blocks: 345238, #modmul: 4936742
M = 45: #buf = 2160, #pairs: 3856111, #single:  385165 (95.24% paired), #blocks: 345238, #modmul: 4931752
M = 46: #buf = 2208, #pairs: 3860920, #single:  375565 (95.36% paired), #blocks: 345238, #modmul: 4926961
M = 47: #buf = 2256, #pairs: 3865376, #single:  366639 (95.47% paired), #blocks: 345238, #modmul: 4922491
M = 48: #buf = 2304, #pairs: 3869793, #single:  357826 (95.58% paired), #blocks: 345238, #modmul: 4918095
M = 49: #buf = 2352, #pairs: 3873883, #single:  349634 (95.68% paired), #blocks: 345238, #modmul: 4913993
M = 50: #buf = 2400, #pairs: 3877936, #single:  341540 (95.78% paired), #blocks: 345238, #modmul: 4909952
D = 660:
M =  1: #buf =   80, #pairs:  936927, #single: 6223611 (23.14% paired), #blocks: 219697, #modmul: 7599932
M =  2: #buf =  160, #pairs: 1533761, #single: 5029954 (37.88% paired), #blocks: 219697, #modmul: 7003109
M =  3: #buf =  240, #pairs: 1951293, #single: 4194853 (48.20% paired), #blocks: 219697, #modmul: 6585540
M =  4: #buf =  320, #pairs: 2256915, #single: 3583630 (55.74% paired), #blocks: 219697, #modmul: 6279939
M =  5: #buf =  400, #pairs: 2490153, #single: 3117126 (61.50% paired), #blocks: 219697, #modmul: 6046673
M =  6: #buf =  480, #pairs: 2673581, #single: 2750289 (66.04% paired), #blocks: 219697, #modmul: 5863264
M =  7: #buf =  560, #pairs: 2819837, #single: 2457748 (69.65% paired), #blocks: 219697, #modmul: 5716979
M =  8: #buf =  640, #pairs: 2939102, #single: 2219247 (72.59% paired), #blocks: 219697, #modmul: 5597743
M =  9: #buf =  720, #pairs: 3038324, #single: 2020769 (75.04% paired), #blocks: 219697, #modmul: 5498487
M = 10: #buf =  800, #pairs: 3123473, #single: 1850495 (77.15% paired), #blocks: 219697, #modmul: 5413362
M = 11: #buf =  880, #pairs: 3195599, #single: 1706212 (78.93% paired), #blocks: 219697, #modmul: 5341205
M = 12: #buf =  960, #pairs: 3258462, #single: 1580511 (80.48% paired), #blocks: 219697, #modmul: 5278367
M = 13: #buf = 1040, #pairs: 3313497, #single: 1470410 (81.84% paired), #blocks: 219697, #modmul: 5223301
M = 14: #buf = 1120, #pairs: 3361161, #single: 1375107 (83.02% paired), #blocks: 219697, #modmul: 5175662
M = 15: #buf = 1200, #pairs: 3403832, #single: 1289738 (84.07% paired), #blocks: 219697, #modmul: 5132964
M = 16: #buf = 1280, #pairs: 3441845, #single: 1213740 (85.01% paired), #blocks: 219697, #modmul: 5094979
M = 17: #buf = 1360, #pairs: 3475906, #single: 1145588 (85.85% paired), #blocks: 219697, #modmul: 5060888
M = 18: #buf = 1440, #pairs: 3506343, #single: 1084742 (86.60% paired), #blocks: 219697, #modmul: 5030479
M = 19: #buf = 1520, #pairs: 3534694, #single: 1028015 (87.30% paired), #blocks: 219697, #modmul: 5002103
M = 20: #buf = 1600, #pairs: 3560030, #single:  977366 (87.93% paired), #blocks: 219697, #modmul: 4976790
M = 21: #buf = 1680, #pairs: 3582985, #single:  931430 (88.50% paired), #blocks: 219697, #modmul: 4953809
M = 22: #buf = 1760, #pairs: 3604238, #single:  888949 (89.02% paired), #blocks: 219697, #modmul: 4932581
M = 23: #buf = 1840, #pairs: 3623621, #single:  850151 (89.50% paired), #blocks: 219697, #modmul: 4913166
M = 24: #buf = 1920, #pairs: 3641837, #single:  813742 (89.95% paired), #blocks: 219697, #modmul: 4894973
M = 25: #buf = 2000, #pairs: 3658650, #single:  780093 (90.37% paired), #blocks: 219697, #modmul: 4878137
M = 26: #buf = 2080, #pairs: 3674075, #single:  749265 (90.75% paired), #blocks: 219697, #modmul: 4862734
M = 27: #buf = 2160, #pairs: 3688463, #single:  720459 (91.10% paired), #blocks: 219697, #modmul: 4848316
M = 28: #buf = 2240, #pairs: 3701952, #single:  693513 (91.44% paired), #blocks: 219697, #modmul: 4834859
M = 29: #buf = 2320, #pairs: 3714435, #single:  668523 (91.74% paired), #blocks: 219697, #modmul: 4822352
M = 30: #buf = 2400, #pairs: 3726200, #single:  645028 (92.03% paired), #blocks: 219697, #modmul: 4810622
D = 840:
M =  1: #buf =   96, #pairs:  991690, #single: 6114094 (24.49% paired), #blocks: 172620, #modmul: 7451024
M =  2: #buf =  192, #pairs: 1605530, #single: 4886433 (39.65% paired), #blocks: 172620, #modmul: 6837203
M =  3: #buf =  288, #pairs: 2019998, #single: 4057451 (49.89% paired), #blocks: 172620, #modmul: 6422689
M =  4: #buf =  384, #pairs: 2321147, #single: 3455179 (57.33% paired), #blocks: 172620, #modmul: 6121566
M =  5: #buf =  480, #pairs: 2549626, #single: 2998187 (62.97% paired), #blocks: 172620, #modmul: 5893053
M =  6: #buf =  576, #pairs: 2729422, #single: 2638622 (67.41% paired), #blocks: 172620, #modmul: 5713284
M =  7: #buf =  672, #pairs: 2873037, #single: 2351363 (70.96% paired), #blocks: 172620, #modmul: 5569640
M =  8: #buf =  768, #pairs: 2991048, #single: 2115368 (73.88% paired), #blocks: 172620, #modmul: 5451656
M =  9: #buf =  864, #pairs: 3089212, #single: 1919006 (76.30% paired), #blocks: 172620, #modmul: 5353458
M = 10: #buf =  960, #pairs: 3171401, #single: 1754652 (78.33% paired), #blocks: 172620, #modmul: 5271293
M = 11: #buf = 1056, #pairs: 3241330, #single: 1614766 (80.06% paired), #blocks: 172620, #modmul: 5201336
M = 12: #buf = 1152, #pairs: 3301281, #single: 1494897 (81.54% paired), #blocks: 172620, #modmul: 5141418
M = 13: #buf = 1248, #pairs: 3354007, #single: 1389420 (82.84% paired), #blocks: 172620, #modmul: 5088667
M = 14: #buf = 1344, #pairs: 3400165, #single: 1297139 (83.98% paired), #blocks: 172620, #modmul: 5042544
M = 15: #buf = 1440, #pairs: 3440908, #single: 1215618 (84.99% paired), #blocks: 172620, #modmul: 5001766
M = 16: #buf = 1536, #pairs: 3477693, #single: 1142081 (85.90% paired), #blocks: 172620, #modmul: 4965014
M = 17: #buf = 1632, #pairs: 3510173, #single: 1077098 (86.70% paired), #blocks: 172620, #modmul: 4932511
M = 18: #buf = 1728, #pairs: 3539247, #single: 1018967 (87.42% paired), #blocks: 172620, #modmul: 4903454
M = 19: #buf = 1824, #pairs: 3565675, #single:  966082 (88.07% paired), #blocks: 172620, #modmul: 4876997
M = 20: #buf = 1920, #pairs: 3589684, #single:  918093 (88.66% paired), #blocks: 172620, #modmul: 4853017
M = 21: #buf = 2016, #pairs: 3611705, #single:  874029 (89.21% paired), #blocks: 172620, #modmul: 4830974
M = 22: #buf = 2112, #pairs: 3632116, #single:  833233 (89.71% paired), #blocks: 172620, #modmul: 4810589
M = 23: #buf = 2208, #pairs: 3650759, #single:  795915 (90.17% paired), #blocks: 172620, #modmul: 4791914
M = 24: #buf = 2304, #pairs: 3667673, #single:  762110 (90.59% paired), #blocks: 172620, #modmul: 4775023
M = 25: #buf = 2400, #pairs: 3683531, #single:  730369 (90.98% paired), #blocks: 172620, #modmul: 4759140

==========================
C-code stage-2 single-prime self-tests:

  // M(16449593): Do a single stage-1-result-powering (pow^345221 - 1) and make sure the known factor divides the result:
  if(p == 16449593) {
	ASSERT(HERE, MODULUS_TYPE == MODULUS_TYPE_MERSENNE, "This p-1 self-test requires Mersenne-mod mode!");
	// A^345221: Use mult[0] as scratch array for modpow():
	input_is_int = TRUE;
	memcpy(a,pow,nbytes);
	modpow(a, mult[0], input_is_int, 345221ull, func_mod_square, p, n, scrnFlag,&tdif2);
	ierr = func_mod_square(       a, 0x0, n, 0,1, 8ull, p, scrnFlag,&tdif2, FALSE);	// undo pass 1 of fwd-FFT
	// subtract 1:
	a[0] -= 1;
	convert_res_FP_bytewise(a,(uint8*)vec1, n, p, 0x0,0x0,0x0);
	int isfact = mi64_is_div_by_scalar64(vec1,1283294140172967047ull,nlimb);	// k = 103.1097.345221
	ASSERT(HERE, isfact != 0, "Failed to find known stage 2 factor!");
	fprintf(stderr,"%s p-1 known-stage-2 prime self-test success!\n",PSTRING);
	exit(0);
  }
  // M(16238797): Do a single stage-1-result-powering (pow^41507 - 1) and make sure the known factor divides the result:
  if(p == 16238797) {
	ASSERT(HERE, MODULUS_TYPE == MODULUS_TYPE_MERSENNE, "This p-1 self-test requires Mersenne-mod mode!");
	// A^41507: Use mult[0] as scratch array for modpow():
	input_is_int = TRUE;
	memcpy(a,pow,nbytes);
	modpow(a, mult[0], input_is_int, 41507ull, func_mod_square, p, n, scrnFlag,&tdif2);
	ierr = func_mod_square(       a, 0x0, n, 0,1, 8ull, p, scrnFlag,&tdif2, FALSE);	// undo pass 1 of fwd-FFT
	// subtract 1:
	a[0] -= 1;
	convert_res_FP_bytewise(a,(uint8*)vec1, n, p, 0x0,0x0,0x0);
	int isfact = mi64_is_div_by_scalar64(vec1,7160849857727202529ull,nlimb);	// k = 2^5.3^2.37.997.41507
	ASSERT(HERE, isfact != 0, "Failed to find known stage 2 factor!");
	fprintf(stderr,"%s p-1 known-stage-2 prime self-test success!\n",PSTRING);
	exit(0);
  }
  if(p == 33554432) {	// F25: Do a single stage-1-result-powering (pow^11066599 - 1) and make sure the known factor divides the result:
	ASSERT(HERE, MODULUS_TYPE == MODULUS_TYPE_FERMAT, "This p-1 self-test requires Fermat-mod mode!");
	input_is_int = TRUE;
	memcpy(a,pow,nbytes);
	modpow(a, mult[0], input_is_int, 11066599ull, func_mod_square, p, n, scrnFlag,&tdif2);
	ierr = func_mod_square(       a, 0x0, n, 0,1, 8ull, p, scrnFlag,&tdif2, FALSE);	// undo pass 1 of fwd-FFT
	// subtract 1:
	a[0] -= 1;
	convert_res_FP_bytewise(a,(uint8*)vec1, n, p, 0x0,0x0,0x0);
	int isfact = mi64_is_div_by_scalar64(vec1,2170072644496392193ull,nlimb);	// k = 2^5.3^2.37.997.11066599
	ASSERT(HERE, isfact != 0, "Failed to find known stage 2 factor!");
	fprintf(stderr,"%s p-1 known-stage-2 prime self-test success!\n",PSTRING);
	exit(0);
  }
  // M(105032111): Do a stage-1-result-powerings (pow^a - 1) with a = 4002923,16093807 and make sure
  // each of the corresponding known factors divides the result:
  if(p == 105032111) {
	ASSERT(HERE, MODULUS_TYPE == MODULUS_TYPE_MERSENNE, "This p-1 self-test requires Mersenne-mod mode!");
	// A^4002923: Use mult[0] as scratch array for modpow():
	input_is_int = TRUE;
	memcpy(a,pow,nbytes);
	modpow(a, mult[0], input_is_int, 4002923ull, func_mod_square, p, n, scrnFlag,&tdif2);
	ierr = func_mod_square(       a, 0x0, n, 0,1, 8ull, p, scrnFlag,&tdif2, FALSE);	// undo pass 1 of fwd-FFT
	// subtract 1:
	a[0] -= 1;
	convert_res_FP_bytewise(a,(uint8*)vec1, n, p, 0x0,0x0,0x0);
	uint64 rem[2] = {0ull,0ull}, q[2] = {9632173486844301975ull,15752ull};	// k = 23.2399.6263.4002923
	int isfact = mi64_div(vec1,q, nlimb,2, 0x0, rem);
	ASSERT(HERE, isfact != 0, "Failed to find known stage 2 factor!");
	fprintf(stderr,"%s p-1 known-stage-2 prime self-test success!\n",PSTRING);
	// A^16093807: Use mult[0] as scratch array for modpow():
	input_is_int = TRUE;
	memcpy(a,pow,nbytes);
	modpow(a, mult[0], input_is_int, 16093807ull, func_mod_square, p, n, scrnFlag,&tdif2);
	ierr = func_mod_square(       a, 0x0, n, 0,1, 8ull, p, scrnFlag,&tdif2, FALSE);	// undo pass 1 of fwd-FFT
	// subtract 1:
	a[0] -= 1;
	convert_res_FP_bytewise(a,(uint8*)vec1, n, p, 0x0,0x0,0x0);
	rem[0] = rem[1] = 0ull; q[0] = 17455533182413519569ull; q[1] = 93166490317ull;	// k = 2^3.3.5.7.67.86753.104119.16093807
	isfact = mi64_div(vec1,q, nlimb,2, 0x0, rem);
	ASSERT(HERE, isfact != 0, "Failed to find known stage 2 factor!");
	fprintf(stderr,"%s p-1 known-stage-2 prime self-test success!\n",PSTRING);
	exit(0);
  }
  if(p == 2147483648) {	// F31: Do a single stage-1-result-powering (pow^140091319777 - 1) and make sure the known factor divides the result:
	ASSERT(HERE, MODULUS_TYPE == MODULUS_TYPE_FERMAT, "This p-1 self-test requires Fermat-mod mode!");
	input_is_int = TRUE;
	memcpy(a,pow,nbytes);
	modpow(a, mult[0], input_is_int, 140091319777ull, func_mod_square, p, n, scrnFlag,&tdif2);
	ierr = func_mod_square(       a, 0x0, n, 0,1, 8ull, p, scrnFlag,&tdif2, FALSE);	// undo pass 1 of fwd-FFT
	// subtract 1:
	a[0] -= 1;
	convert_res_FP_bytewise(a,(uint8*)vec1, n, p, 0x0,0x0,0x0);
	uint64 rem[2] = {0ull,0ull}, q[2] = {3118754346955702273ull,2544ull};	// k = 3.13.140091319777; q = k.2^(m+2) + 1
	// In fact, F31 has nlimb+1 words, but the only way a p-1 residue R has the same high bit
	// set as F31 iif R == F31 (uninteresting) or R == 2^2^31, which implies GCD == 1:
	int isfact = mi64_div(vec1,q, nlimb,2, 0x0, rem);
	ASSERT(HERE, isfact != 0, "Failed to find known stage 2 factor!");
	fprintf(stderr,"%s p-1 known-stage-2 prime self-test success!\n",PSTRING);
	exit(0);
  }

===================================
5/25/21 - George writes re. stage pairing algorithm:

Do you relocate stage 2 primes? [ewm: no]

Say you are doing B1=1M, B2=30M with D=210 (where D is the stage 2 big step increment). Instead
of doing stage 2 from 1M to 30M, you can do stage 2 from (30/11)M to 30M by relocating all primes
p between 1M and (30/11)M to 11*p. In fact, some p can be relocated to 13*p or 17*p where your
code gets to choose the most beneficial place to relocate the prime to.
... The speedup is not inconsequential. Pairing is better as the primes are concentrated in a smaller area as well as fewer multiplications for incrementing by D.

5/26: I sent my table of #modmul for best-combo at various #bufs, he came back with the below:

This is the easiest implementation. Have two sieves: sieve #1 from B1 to B2/11 and sieve #2 from B2/11 to B2. Write a C++ class or C procedure that simply returns the lesser of 11*sieve#1 prime or sieve #2 prime. Have your current pairing code call the combo sieve rather than the B1 to B2 sieve it currently calls.

Going the extra mile of deciding whether 11*p or 13*p pairs better can be left for a later date.

Here is more data than you probably want:
Some highlights:
M=2 your code pairs at ~38% prime95's is ~49%
M=5 your code pairs at ~63% prime95's is ~71%
M=25 your code pairs at ~91% prime95's is ~95%

There are more optimizations possible. The "2*Dsections" can be reduced to "1*Dsections" (a Peter Montgomery idea) and Pavel Atnashev has achieved 97% pairing in some circumstances. I'm exploring some of these now for prime95.

Code:
Analyzing B1=1000000, B2=30000000
D: 30, relative primes: 100, num relprimes to D: 4, multiplier: 25.00, est. density: 0.2584, B2_start: 4285695, Dsections: 857144
Estimated numprimes 1771914
Estimated numprimes relocated 222282
Memory required for each bit array: 857144 bytes
D: 30, relative primes: 100, stage 2 primes: 1779361, pair%=94.65

D: 42, relative primes: 100, num relprimes to D: 6, multiplier: 16.67, est. density: 0.2584, B2_start: 5999973, Dsections: 571430
Estimated numprimes 1771914
Estimated numprimes relocated 332723
Memory required for each bit array: 857145 bytes
D: 42, relative primes: 100, stage 2 primes: 1779361, pair%=90.94

D: 60, relative primes: 100, num relprimes to D: 8, multiplier: 12.50, est. density: 0.2584, B2_start: 4285710, Dsections: 428572
Estimated numprimes 1771914
Estimated numprimes relocated 222283
Memory required for each bit array: 857144 bytes
D: 60, relative primes: 100, stage 2 primes: 1779361, pair%=87.26

D: 90, relative primes: 100, num relprimes to D: 12, multiplier:  8.33, est. density: 0.2584, B2_start: 4285665, Dsections: 285715
Estimated numprimes 1771914
Estimated numprimes relocated 222280
Memory required for each bit array: 857145 bytes
D: 90, relative primes: 100, stage 2 primes: 1779361, pair%=80.54

D: 120, relative primes: 100, num relprimes to D: 16, multiplier:  6.25, est. density: 0.2584, B2_start: 4285620, Dsections: 214287
Estimated numprimes 1771914
Estimated numprimes relocated 222277
Memory required for each bit array: 857148 bytes
D: 120, relative primes: 100, stage 2 primes: 1779361, pair%=74.72

D: 150, relative primes: 100, num relprimes to D: 20, multiplier:  5.00, est. density: 0.2584, B2_start: 4285725, Dsections: 171429
Estimated numprimes 1771914
Estimated numprimes relocated 222284
Memory required for each bit array: 857145 bytes
D: 150, relative primes: 100, stage 2 primes: 1779361, pair%=69.77

D: 210, relative primes: 100, num relprimes to D: 24, multiplier:  4.17, est. density: 0.2842, B2_start: 2727165, Dsections: 129871
Estimated numprimes 1771914
Estimated numprimes relocated 119322
Memory required for each bit array: 779226 bytes
D: 210, relative primes: 100, stage 2 primes: 1779361, pair%=66.51

D: 330, relative primes: 100, num relprimes to D: 40, multiplier:  2.50, est. density: 0.2842, B2_start: 4285545, Dsections: 77923
Estimated numprimes 1771914
Estimated numprimes relocated 222273
Memory required for each bit array: 779230 bytes
D: 330, relative primes: 100, stage 2 primes: 1779361, pair%=53.59

D: 420, relative primes: 100, num relprimes to D: 48, multiplier:  2.08, est. density: 0.2842, B2_start: 2727270, Dsections: 64936
Estimated numprimes 1771914
Estimated numprimes relocated 119329
Memory required for each bit array: 779232 bytes
D: 420, relative primes: 100, stage 2 primes: 1779361, pair%=49.22

D: 462, relative primes: 100, num relprimes to D: 60, multiplier:  1.67, est. density: 0.2842, B2_start: 5999763, Dsections: 51949
Estimated numprimes 1771914
Estimated numprimes relocated 332709
Memory required for each bit array: 779235 bytes
D: 462, relative primes: 100, stage 2 primes: 1779361, pair%=43.02

D: 630, relative primes: 100, num relprimes to D: 72, multiplier:  1.39, est. density: 0.2842, B2_start: 2726955, Dsections: 43291
Estimated numprimes 1771914
Estimated numprimes relocated 119308
Memory required for each bit array: 779238 bytes
D: 630, relative primes: 100, stage 2 primes: 1779361, pair%=38.51

D: 840, relative primes: 100, num relprimes to D: 96, multiplier:  1.04, est. density: 0.2842, B2_start: 2727060, Dsections: 32468
Estimated numprimes 1771914
Estimated numprimes relocated 119315
Memory required for each bit array: 779232 bytes
D: 840, relative primes: 100, stage 2 primes: 1779361, pair%=32.85

Cannot run d=1050 with 100 buffers
Cannot run d=1260 with 100 buffers
Cannot run d=1470 with 100 buffers
Cannot run d=1680 with 100 buffers
Cannot run d=1890 with 100 buffers
Cannot run d=2310 with 100 buffers
Cannot run d=2730 with 100 buffers
Cannot run d=4620 with 100 buffers
Cannot run d=6930 with 100 buffers
D: 30, relative primes: 200, num relprimes to D: 4, multiplier: 50.00, est. density: 0.2584, B2_start: 4285695, Dsections: 857144
Estimated numprimes 1771914
Estimated numprimes relocated 222282
Memory required for each bit array: 857144 bytes
D: 30, relative primes: 200, stage 2 primes: 1779361, pair%=98.00

D: 42, relative primes: 200, num relprimes to D: 6, multiplier: 33.33, est. density: 0.2584, B2_start: 5999973, Dsections: 571430
Estimated numprimes 1771914
Estimated numprimes relocated 332723
Memory required for each bit array: 857145 bytes
D: 42, relative primes: 200, stage 2 primes: 1779361, pair%=96.50

D: 60, relative primes: 200, num relprimes to D: 8, multiplier: 25.00, est. density: 0.2584, B2_start: 4285710, Dsections: 428572
Estimated numprimes 1771914
Estimated numprimes relocated 222283
Memory required for each bit array: 857144 bytes
D: 60, relative primes: 200, stage 2 primes: 1779361, pair%=94.63

D: 90, relative primes: 200, num relprimes to D: 12, multiplier: 16.67, est. density: 0.2584, B2_start: 4285665, Dsections: 285715
Estimated numprimes 1771914
Estimated numprimes relocated 222280
Memory required for each bit array: 857145 bytes
D: 90, relative primes: 200, stage 2 primes: 1779361, pair%=90.86

D: 120, relative primes: 200, num relprimes to D: 16, multiplier: 12.50, est. density: 0.2584, B2_start: 4285620, Dsections: 214287
Estimated numprimes 1771914
Estimated numprimes relocated 222277
Memory required for each bit array: 857148 bytes
D: 120, relative primes: 200, stage 2 primes: 1779361, pair%=87.25

D: 150, relative primes: 200, num relprimes to D: 20, multiplier: 10.00, est. density: 0.2584, B2_start: 4285725, Dsections: 171429
Estimated numprimes 1771914
Estimated numprimes relocated 222284
Memory required for each bit array: 857145 bytes
D: 150, relative primes: 200, stage 2 primes: 1779361, pair%=83.82

D: 210, relative primes: 200, num relprimes to D: 24, multiplier:  8.33, est. density: 0.2842, B2_start: 2727165, Dsections: 129871
Estimated numprimes 1771914
Estimated numprimes relocated 119322
Memory required for each bit array: 779226 bytes
D: 210, relative primes: 200, stage 2 primes: 1779361, pair%=81.24

D: 330, relative primes: 200, num relprimes to D: 40, multiplier:  5.00, est. density: 0.2842, B2_start: 4285545, Dsections: 77923
Estimated numprimes 1771914
Estimated numprimes relocated 222273
Memory required for each bit array: 779230 bytes
D: 330, relative primes: 200, stage 2 primes: 1779361, pair%=70.94

D: 420, relative primes: 200, num relprimes to D: 48, multiplier:  4.17, est. density: 0.2842, B2_start: 2727270, Dsections: 64936
Estimated numprimes 1771914
Estimated numprimes relocated 119329
Memory required for each bit array: 779232 bytes
D: 420, relative primes: 200, stage 2 primes: 1779361, pair%=66.54

D: 462, relative primes: 200, num relprimes to D: 60, multiplier:  3.33, est. density: 0.2842, B2_start: 5999763, Dsections: 51949
Estimated numprimes 1771914
Estimated numprimes relocated 332709
Memory required for each bit array: 779235 bytes
D: 462, relative primes: 200, stage 2 primes: 1779361, pair%=60.96

D: 630, relative primes: 200, num relprimes to D: 72, multiplier:  2.78, est. density: 0.2842, B2_start: 2726955, Dsections: 43291
Estimated numprimes 1771914
Estimated numprimes relocated 119308
Memory required for each bit array: 779238 bytes
D: 630, relative primes: 200, stage 2 primes: 1779361, pair%=56.36

D: 840, relative primes: 200, num relprimes to D: 96, multiplier:  2.08, est. density: 0.2842, B2_start: 2727060, Dsections: 32468
Estimated numprimes 1771914
Estimated numprimes relocated 119315
Memory required for each bit array: 779232 bytes
D: 840, relative primes: 200, stage 2 primes: 1779361, pair%=49.26

D: 1050, relative primes: 200, num relprimes to D: 120, multiplier:  1.67, est. density: 0.2842, B2_start: 2726325, Dsections: 25975
Estimated numprimes 1771914
Estimated numprimes relocated 119266
Memory required for each bit array: 779250 bytes
D: 1050, relative primes: 200, stage 2 primes: 1779361, pair%=43.01

D: 1260, relative primes: 200, num relprimes to D: 144, multiplier:  1.39, est. density: 0.2842, B2_start: 2727270, Dsections: 21646
Estimated numprimes 1771914
Estimated numprimes relocated 119329
Memory required for each bit array: 779256 bytes
D: 1260, relative primes: 200, stage 2 primes: 1779361, pair%=38.55

D: 1470, relative primes: 200, num relprimes to D: 168, multiplier:  1.19, est. density: 0.2842, B2_start: 2726115, Dsections: 18554
Estimated numprimes 1771914
Estimated numprimes relocated 119252
Memory required for each bit array: 779268 bytes
D: 1470, relative primes: 200, stage 2 primes: 1779361, pair%=35.29

D: 1680, relative primes: 200, num relprimes to D: 192, multiplier:  1.04, est. density: 0.2842, B2_start: 2725800, Dsections: 16235
Estimated numprimes 1771914
Estimated numprimes relocated 119231
Memory required for each bit array: 779280 bytes
D: 1680, relative primes: 200, stage 2 primes: 1779361, pair%=32.85

Cannot run d=1890 with 200 buffers
Cannot run d=2310 with 200 buffers
Cannot run d=2730 with 200 buffers
Cannot run d=4620 with 200 buffers
Cannot run d=6930 with 200 buffers
Run d=30 with 300 buffers has a multiplier of 75, surely a larger d would be better
D: 42, relative primes: 300, num relprimes to D: 6, multiplier: 50.00, est. density: 0.2584, B2_start: 5999973, Dsections: 571430
Estimated numprimes 1771914
Estimated numprimes relocated 332723
Memory required for each bit array: 857145 bytes
D: 42, relative primes: 300, stage 2 primes: 1779361, pair%=98.16

D: 60, relative primes: 300, num relprimes to D: 8, multiplier: 37.50, est. density: 0.2584, B2_start: 4285710, Dsections: 428572
Estimated numprimes 1771914
Estimated numprimes relocated 222283
Memory required for each bit array: 857144 bytes
D: 60, relative primes: 300, stage 2 primes: 1779361, pair%=96.99

D: 90, relative primes: 300, num relprimes to D: 12, multiplier: 25.00, est. density: 0.2584, B2_start: 4285665, Dsections: 285715
Estimated numprimes 1771914
Estimated numprimes relocated 222280
Memory required for each bit array: 857145 bytes
D: 90, relative primes: 300, stage 2 primes: 1779361, pair%=94.60

D: 120, relative primes: 300, num relprimes to D: 16, multiplier: 18.75, est. density: 0.2584, B2_start: 4285620, Dsections: 214287
Estimated numprimes 1771914
Estimated numprimes relocated 222277
Memory required for each bit array: 857148 bytes
D: 120, relative primes: 300, stage 2 primes: 1779361, pair%=92.14

D: 150, relative primes: 300, num relprimes to D: 20, multiplier: 15.00, est. density: 0.2584, B2_start: 4285725, Dsections: 171429
Estimated numprimes 1771914
Estimated numprimes relocated 222284
Memory required for each bit array: 857145 bytes
D: 150, relative primes: 300, stage 2 primes: 1779361, pair%=89.64

D: 210, relative primes: 300, num relprimes to D: 24, multiplier: 12.50, est. density: 0.2842, B2_start: 2727165, Dsections: 129871
Estimated numprimes 1771914
Estimated numprimes relocated 119322
Memory required for each bit array: 779226 bytes
D: 210, relative primes: 300, stage 2 primes: 1779361, pair%=87.55

D: 330, relative primes: 300, num relprimes to D: 40, multiplier:  7.50, est. density: 0.2842, B2_start: 4285545, Dsections: 77923
Estimated numprimes 1771914
Estimated numprimes relocated 222273
Memory required for each bit array: 779230 bytes
D: 330, relative primes: 300, stage 2 primes: 1779361, pair%=79.24

D: 420, relative primes: 300, num relprimes to D: 48, multiplier:  6.25, est. density: 0.2842, B2_start: 2727270, Dsections: 64936
Estimated numprimes 1771914
Estimated numprimes relocated 119329
Memory required for each bit array: 779232 bytes
D: 420, relative primes: 300, stage 2 primes: 1779361, pair%=75.62

D: 462, relative primes: 300, num relprimes to D: 60, multiplier:  5.00, est. density: 0.2842, B2_start: 5999763, Dsections: 51949
Estimated numprimes 1771914
Estimated numprimes relocated 332709
Memory required for each bit array: 779235 bytes
D: 462, relative primes: 300, stage 2 primes: 1779361, pair%=70.84

D: 630, relative primes: 300, num relprimes to D: 72, multiplier:  4.17, est. density: 0.2842, B2_start: 2726955, Dsections: 43291
Estimated numprimes 1771914
Estimated numprimes relocated 119308
Memory required for each bit array: 779238 bytes
D: 630, relative primes: 300, stage 2 primes: 1779361, pair%=66.57

D: 840, relative primes: 300, num relprimes to D: 96, multiplier:  3.12, est. density: 0.2842, B2_start: 2727060, Dsections: 32468
Estimated numprimes 1771914
Estimated numprimes relocated 119315
Memory required for each bit array: 779232 bytes
D: 840, relative primes: 300, stage 2 primes: 1779361, pair%=59.45

D: 1050, relative primes: 300, num relprimes to D: 120, multiplier:  2.50, est. density: 0.2842, B2_start: 2726325, Dsections: 25975
Estimated numprimes 1771914
Estimated numprimes relocated 119266
Memory required for each bit array: 779250 bytes
D: 1050, relative primes: 300, stage 2 primes: 1779361, pair%=53.47

D: 1260, relative primes: 300, num relprimes to D: 144, multiplier:  2.08, est. density: 0.2842, B2_start: 2727270, Dsections: 21646
Estimated numprimes 1771914
Estimated numprimes relocated 119329
Memory required for each bit array: 779256 bytes
D: 1260, relative primes: 300, stage 2 primes: 1779361, pair%=49.23

D: 1470, relative primes: 300, num relprimes to D: 168, multiplier:  1.79, est. density: 0.2842, B2_start: 2726115, Dsections: 18554
Estimated numprimes 1771914
Estimated numprimes relocated 119252
Memory required for each bit array: 779268 bytes
D: 1470, relative primes: 300, stage 2 primes: 1779361, pair%=44.92

D: 1680, relative primes: 300, num relprimes to D: 192, multiplier:  1.56, est. density: 0.2842, B2_start: 2725800, Dsections: 16235
Estimated numprimes 1771914
Estimated numprimes relocated 119231
Memory required for each bit array: 779280 bytes
D: 1680, relative primes: 300, stage 2 primes: 1779361, pair%=41.30

D: 1890, relative primes: 300, num relprimes to D: 216, multiplier:  1.39, est. density: 0.2842, B2_start: 2726325, Dsections: 14431
Estimated numprimes 1771914
Estimated numprimes relocated 119266
Memory required for each bit array: 779274 bytes
D: 1890, relative primes: 300, stage 2 primes: 1779361, pair%=38.46

D: 2310, relative primes: 300, num relprimes to D: 240, multiplier:  1.25, est. density: 0.3079, B2_start: 2306535, Dsections: 11989
Estimated numprimes 1771914
Estimated numprimes relocated 90931
Memory required for each bit array: 719340 bytes
D: 2310, relative primes: 300, stage 2 primes: 1779361, pair%=37.35

D: 2730, relative primes: 300, num relprimes to D: 288, multiplier:  1.04, est. density: 0.3079, B2_start: 2725905, Dsections: 9991
Estimated numprimes 1771914
Estimated numprimes relocated 119238
Memory required for each bit array: 719352 bytes
D: 2730, relative primes: 300, stage 2 primes: 1779361, pair%=33.89

Cannot run d=4620 with 300 buffers
Cannot run d=6930 with 300 buffers

================================
EWM: Letting np = stage 2 primes and defining the pairing fraction f := pair%/100, #modmul = 2*Dsections + np*(1-f/2):
*** to-do ***

IDEA:
In my current pairing scheme, sa using D = 210 = 2.3.5.7
Could start at B2_start*11, now need to *keep* composites of form 11.prime in sieve. How to efficiently identify?
Can use various fixed-point div tricks to compute quotient&remainder, replace q's divisible-by-11 by q/11 and then apply usual 2-prp test to quotient.
Need to handle quotients up to nearly 32 bits. SSE2 has 2-way PMULUDQ, 4-way 16X16->32-bit [PMULLW,PMULHUW], SSE4 adds 4-way low-product-half via PMULLD.

But, in fact we can simply use a short-length "moving window" bitmap to tag q's divisible by our chosen q, which is the smallest prime not dividing our bigstep D. For such q's can compute exact quotient via simple low-half-of-dwide-product mul by the Montgomery inverse.

Example, using 32-bit math:
n = 337231763, q = 11; b = 2^32 and qinv = 3123612579 gives q*qinv == 1 (mod b).
Now try semiprime 11*p near 2^32: n = 337231763 = 11.30657433
MULL32(n,qinv = 30657433, the desired quotient.

What does the bitmap tagging such eaxct-q-multiples look like?

Using B2_start = 5000000, B2 = 5001000, Bigstep = 210, M = 1
Stage 2 q0 = 5000100, k0 = 23810	<*** q0%11 = 6, so just -+ the coprime offsets to this (mod 11):
New upper-interval, tagging its primes:								q1,q2%11:
	q = 5000100 -+   1: q1 = 5000099[0], q2 = 5000101[1], 1-prime	5	7
	q = 5000100 -+  11: q1 = 5000089[0], q2 = 5000111[1], 1-prime	6	6
	q = 5000100 -+  13: q1 = 5000087[1], q2 = 5000113[1], 2-prime	4	8
	q = 5000100 -+  17: q1 = 5000083[0], q2 = 5000117[0], 0-prime	0*	1
	q = 5000100 -+  19: q1 = 5000081[1], q2 = 5000119[0], 1-prime	9	3
	q = 5000100 -+  23: q1 = 5000077[1], q2 = 5000123[0], 1-prime	5	7
	q = 5000100 -+  29: q1 = 5000071[0], q2 = 5000129[0], 0-prime	10	2
	q = 5000100 -+  31: q1 = 5000069[0], q2 = 5000131[0], 0-prime	8	4
	q = 5000100 -+  37: q1 = 5000063[0], q2 = 5000137[0], 0-prime	2	10
	q = 5000100 -+  41: q1 = 5000059[0], q2 = 5000141[0], 0-prime	9	3
	q = 5000100 -+  43: q1 = 5000057[0], q2 = 5000143[0], 0-prime	7	5
	q = 5000100 -+  47: q1 = 5000053[0], q2 = 5000147[0], 0-prime	3	9
	q = 5000100 -+  53: q1 = 5000047[0], q2 = 5000153[1], 1-prime	8	4
	q = 5000100 -+  59: q1 = 5000041[0], q2 = 5000159[0], 0-prime	2	10
	q = 5000100 -+  61: q1 = 5000039[0], q2 = 5000161[1], 1-prime	0*	1
	q = 5000100 -+  67: q1 = 5000033[0], q2 = 5000167[1], 1-prime	5	7
	q = 5000100 -+  71: q1 = 5000029[0], q2 = 5000171[0], 0-prime	1	0*
	q = 5000100 -+  73: q1 = 5000027[0], q2 = 5000173[0], 0-prime	10	2
	q = 5000100 -+  79: q1 = 5000021[0], q2 = 5000179[0], 0-prime	4	8
	q = 5000100 -+  83: q1 = 5000017[0], q2 = 5000183[0], 0-prime	0*	1
	q = 5000100 -+  89: q1 = 5000011[1], q2 = 5000189[0], 1-prime	5	7
	q = 5000100 -+  97: q1 = 5000003[0], q2 = 5000197[1], 1-prime	8	4
	q = 5000100 -+ 101: q1 = 4999999[1], q2 = 5000201[1], 2-prime	4	8
	q = 5000100 -+ 103: q1 = 4999997[0], q2 = 5000203[0], 0-prime	2	10
	Resulting is-div-by-11 bitmap, bits run LR corr. to q0+103 ... q0-103:
	000000010000000000000000 000100000000001000010000
New upper-interval, tagging its primes:						*** D%11 = 1, so just add 1 to the above q1,2%11 values: ***
	q = 5000310 -+   1: q1 = 5000309[0], q2 = 5000311[1], 1-prime	6	8
	q = 5000310 -+  11: q1 = 5000299[1], q2 = 5000321[1], 2-prime	7	7
	q = 5000310 -+  13: q1 = 5000297[0], q2 = 5000323[0], 0-prime	5	9
	q = 5000310 -+  17: q1 = 5000293[0], q2 = 5000327[0], 0-prime	1	2
	q = 5000310 -+  19: q1 = 5000291[0], q2 = 5000329[0], 0-prime	10	4
	q = 5000310 -+  23: q1 = 5000287[0], q2 = 5000333[0], 0-prime	6	8
	q = 5000310 -+  29: q1 = 5000281[0], q2 = 5000339[1], 1-prime	0*	3
	q = 5000310 -+  31: q1 = 5000279[0], q2 = 5000341[0], 0-prime	9	5
	q = 5000310 -+  37: q1 = 5000273[0], q2 = 5000347[0], 0-prime	3	0*
	q = 5000310 -+  41: q1 = 5000269[0], q2 = 5000351[0], 0-prime	10	4
	q = 5000310 -+  43: q1 = 5000267[0], q2 = 5000353[0], 0-prime	8	6
	q = 5000310 -+  47: q1 = 5000263[1], q2 = 5000357[0], 1-prime	4	10
	q = 5000310 -+  53: q1 = 5000257[1], q2 = 5000363[0], 1-prime	9	5
	q = 5000310 -+  59: q1 = 5000251[1], q2 = 5000369[0], 1-prime	3	0*
	q = 5000310 -+  61: q1 = 5000249[0], q2 = 5000371[0], 0-prime	1	2
	q = 5000310 -+  67: q1 = 5000243[0], q2 = 5000377[0], 0-prime	6	8
	q = 5000310 -+  71: q1 = 5000239[0], q2 = 5000381[1], 1-prime	2	1
	q = 5000310 -+  73: q1 = 5000237[0], q2 = 5000383[0], 0-prime	0*	3
	q = 5000310 -+  79: q1 = 5000231[0], q2 = 5000389[1], 1-prime	5	9
	q = 5000310 -+  83: q1 = 5000227[0], q2 = 5000393[0], 0-prime	1	2
	q = 5000310 -+  89: q1 = 5000221[0], q2 = 5000399[1], 1-prime	6	8
	q = 5000310 -+  97: q1 = 5000213[1], q2 = 5000407[0], 1-prime	9	5
	q = 5000310 -+ 101: q1 = 5000209[0], q2 = 5000411[0], 0-prime	5	9
	q = 5000310 -+ 103: q1 = 5000207[0], q2 = 5000413[0], 0-prime	3	0*
New upper-interval, tagging its primes:
	q = 5000520 -+   1: q1 = 5000519[1], q2 = 5000521[0], 1-prime	7	9
	q = 5000520 -+  11: q1 = 5000509[0], q2 = 5000531[0], 0-prime	8	8
	q = 5000520 -+  13: q1 = 5000507[0], q2 = 5000533[0], 0-prime	6	10
	q = 5000520 -+  17: q1 = 5000503[1], q2 = 5000537[0], 1-prime	2	3
	q = 5000520 -+  19: q1 = 5000501[0], q2 = 5000539[1], 1-prime	0*	5
	q = 5000520 -+  23: q1 = 5000497[0], q2 = 5000543[1], 1-prime	7	9
	q = 5000520 -+  29: q1 = 5000491[1], q2 = 5000549[1], 2-prime	1	4
	q = 5000520 -+  31: q1 = 5000489[0], q2 = 5000551[1], 1-prime	10	6
	q = 5000520 -+  37: q1 = 5000483[0], q2 = 5000557[0], 0-prime	4	1
	q = 5000520 -+  41: q1 = 5000479[0], q2 = 5000561[0], 0-prime	0*	5
	q = 5000520 -+  43: q1 = 5000477[0], q2 = 5000563[1], 1-prime	9	7
	q = 5000520 -+  47: q1 = 5000473[1], q2 = 5000567[0], 1-prime	5	0*
	q = 5000520 -+  53: q1 = 5000467[0], q2 = 5000573[0], 0-prime	10	6
	q = 5000520 -+  59: q1 = 5000461[0], q2 = 5000579[0], 0-prime	4	1
	q = 5000520 -+  61: q1 = 5000459[0], q2 = 5000581[1], 1-prime	2	3
	q = 5000520 -+  67: q1 = 5000453[0], q2 = 5000587[0], 0-prime	7	9
	q = 5000520 -+  71: q1 = 5000449[0], q2 = 5000591[0], 0-prime	3	2
	q = 5000520 -+  73: q1 = 5000447[0], q2 = 5000593[0], 0-prime	1	4
	q = 5000520 -+  79: q1 = 5000441[0], q2 = 5000599[0], 0-prime	6	10
	q = 5000520 -+  83: q1 = 5000437[0], q2 = 5000603[0], 0-prime	2	3
	q = 5000520 -+  89: q1 = 5000431[0], q2 = 5000609[0], 0-prime	7	9
	q = 5000520 -+  97: q1 = 5000423[1], q2 = 5000617[0], 1-prime	10	6
	q = 5000520 -+ 101: q1 = 5000419[0], q2 = 5000621[0], 0-prime	6	10
	q = 5000520 -+ 103: q1 = 5000417[0], q2 = 5000623[1], 1-prime	4	1
New upper-interval, tagging its primes:
	q = 5000730 -+   1: q1 = 5000729[0], q2 = 5000731[0], 0-prime	8	10
	q = 5000730 -+  11: q1 = 5000719[0], q2 = 5000741[1], 1-prime	9	9
	q = 5000730 -+  13: q1 = 5000717[0], q2 = 5000743[0], 0-prime	7	0*
	q = 5000730 -+  17: q1 = 5000713[1], q2 = 5000747[1], 2-prime	3	4
	q = 5000730 -+  19: q1 = 5000711[0], q2 = 5000749[0], 0-prime	1	6
	q = 5000730 -+  23: q1 = 5000707[0], q2 = 5000753[0], 0-prime	8	10
	q = 5000730 -+  29: q1 = 5000701[1], q2 = 5000759[1], 2-prime	2	5
	q = 5000730 -+  31: q1 = 5000699[0], q2 = 5000761[1], 1-prime	0*	7
	q = 5000730 -+  37: q1 = 5000693[0], q2 = 5000767[0], 0-prime	5	2
	q = 5000730 -+  41: q1 = 5000689[1], q2 = 5000771[0], 1-prime	1	6
	q = 5000730 -+  43: q1 = 5000687[1], q2 = 5000773[0], 1-prime	10	8
	q = 5000730 -+  47: q1 = 5000683[0], q2 = 5000777[1], 1-prime	6	1
	q = 5000730 -+  53: q1 = 5000677[0], q2 = 5000783[1], 1-prime	0*	7
	q = 5000730 -+  59: q1 = 5000671[0], q2 = 5000789[0], 0-prime	5	2
	q = 5000730 -+  61: q1 = 5000669[0], q2 = 5000791[1], 1-prime	3	4
	q = 5000730 -+  67: q1 = 5000663[0], q2 = 5000797[1], 1-prime	8	10
	q = 5000730 -+  71: q1 = 5000659[0], q2 = 5000801[0], 0-prime	4	3
	q = 5000730 -+  73: q1 = 5000657[1], q2 = 5000803[0], 1-prime	2	5
	q = 5000730 -+  79: q1 = 5000651[1], q2 = 5000809[0], 1-prime	7	0*
	q = 5000730 -+  83: q1 = 5000647[0], q2 = 5000813[0], 0-prime	3	4
	q = 5000730 -+  89: q1 = 5000641[0], q2 = 5000819[0], 0-prime	8	10
	q = 5000730 -+  97: q1 = 5000633[0], q2 = 5000827[0], 0-prime	0*	7
	q = 5000730 -+ 101: q1 = 5000629[0], q2 = 5000831[0], 0-prime	7	0*
	q = 5000730 -+ 103: q1 = 5000627[1], q2 = 5000833[0], 1-prime	5	2
New upper-interval, tagging its primes:
	q = 5000940 -+   1: q1 = 5000939[1], q2 = 5000941[0], 1-prime	9	0*
	q = 5000940 -+  11: q1 = 5000929[1], q2 = 5000951[0], 1-prime	10	10
	q = 5000940 -+  13: q1 = 5000927[1], q2 = 5000953[0], 1-prime	8	1
	q = 5000940 -+  17: q1 = 5000923[1], q2 = 5000957[0], 1-prime	4	5
	q = 5000940 -+  19: q1 = 5000921[0], q2 = 5000959[0], 0-prime	2	7
	q = 5000940 -+  23: q1 = 5000917[1], q2 = 5000963[0], 1-prime	9	0*
	q = 5000940 -+  29: q1 = 5000911[0], q2 = 5000969[0], 0-prime	3	6
	q = 5000940 -+  31: q1 = 5000909[0], q2 = 5000971[0], 0-prime	1	8
	q = 5000940 -+  37: q1 = 5000903[1], q2 = 5000977[1], 2-prime	6	3
	q = 5000940 -+  41: q1 = 5000899[0], q2 = 5000981[1], 1-prime	2	7
	q = 5000940 -+  43: q1 = 5000897[0], q2 = 5000983[0], 0-prime	0*	9
	q = 5000940 -+  47: q1 = 5000893[0], q2 = 5000987[1], 1-prime	7	2
	q = 5000940 -+  53: q1 = 5000887[0], q2 = 5000993[1], 1-prime	1	8
	q = 5000940 -+  59: q1 = 5000881[1], q2 = 5000999[0], 1-prime	6	3
	q = 5000940 -+  61: q1 = 5000879[0], q2 = 5001001[1], 1-prime	4	5
	q = 5000940 -+  67: q1 = 5000873[0], q2 = 5001007[0], 0-prime	9	0*
	q = 5000940 -+  71: q1 = 5000869[0], q2 = 5001011[0], 0-prime	5	4
	q = 5000940 -+  73: q1 = 5000867[0], q2 = 5001013[0], 0-prime	3	6
	q = 5000940 -+  79: q1 = 5000861[1], q2 = 5001019[1], 2-prime	8	1
	q = 5000940 -+  83: q1 = 5000857[0], q2 = 5001023[1], 1-prime	4	5
	q = 5000940 -+  89: q1 = 5000851[1], q2 = 5001029[0], 1-prime	9	0*
	q = 5000940 -+  97: q1 = 5000843[0], q2 = 5001037[0], 0-prime	1	8
	q = 5000940 -+ 101: q1 = 5000839[0], q2 = 5001041[0], 0-prime	8	1
	q = 5000940 -+ 103: q1 = 5000837[0], q2 = 5001043[0], 0-prime	6	3
New upper-interval, tagging its primes:
	q = 5001150 -+   1: q1 = 5001149[0], q2 = 5001151[0], 0-prime	10	1
	q = 5001150 -+  11: q1 = 5001139[0], q2 = 5001161[0], 0-prime	0*	0*
	q = 5001150 -+  13: q1 = 5001137[0], q2 = 5001163[1], 1-prime	9	2
	q = 5001150 -+  17: q1 = 5001133[0], q2 = 5001167[1], 1-prime	5	6
	q = 5001150 -+  19: q1 = 5001131[0], q2 = 5001169[0], 0-prime	3	8
	q = 5001150 -+  23: q1 = 5001127[1], q2 = 5001173[1], 2-prime	10	1
	q = 5001150 -+  29: q1 = 5001121[1], q2 = 5001179[0], 1-prime	4	7
	q = 5001150 -+  31: q1 = 5001119[1], q2 = 5001181[0], 1-prime	2	9
	q = 5001150 -+  37: q1 = 5001113[0], q2 = 5001187[0], 0-prime	7	4
	q = 5001150 -+  41: q1 = 5001109[0], q2 = 5001191[0], 0-prime	3	8
	q = 5001150 -+  43: q1 = 5001107[0], q2 = 5001193[1], 1-prime	1	10
	q = 5001150 -+  47: q1 = 5001103[0], q2 = 5001197[1], 1-prime	8	3
	q = 5001150 -+  53: q1 = 5001097[0], q2 = 5001203[1], 1-prime	2	9
	q = 5001150 -+  59: q1 = 5001091[0], q2 = 5001209[0], 0-prime	7	4
	q = 5001150 -+  61: q1 = 5001089[1], q2 = 5001211[0], 1-prime	5	6
	q = 5001150 -+  67: q1 = 5001083[1], q2 = 5001217[0], 1-prime	10	1
	q = 5001150 -+  71: q1 = 5001079[0], q2 = 5001221[0], 0-prime	6	5
	q = 5001150 -+  73: q1 = 5001077[0], q2 = 5001223[0], 0-prime	4	7
	q = 5001150 -+  79: q1 = 5001071[1], q2 = 5001229[0], 1-prime	9	2
	q = 5001150 -+  83: q1 = 5001067[1], q2 = 5001233[1], 2-prime	5	6
	q = 5001150 -+  89: q1 = 5001061[0], q2 = 5001239[0], 0-prime	10	1
	q = 5001150 -+  97: q1 = 5001053[1], q2 = 5001247[0], 1-prime	2	9
	q = 5001150 -+ 101: q1 = 5001049[1], q2 = 5001251[1], 2-prime	9	2
	q = 5001150 -+ 103: q1 = 5001047[0], q2 = 5001253[0], 0-prime	7	4
New upper-interval, tagging its primes:
	q = 5001360 -+   1: q1 = 5001359[0], q2 = 5001361[1], 1-prime	0*	2
	q = 5001360 -+  11: q1 = 5001349[0], q2 = 5001371[0], 0-prime	1	1
	q = 5001360 -+  13: q1 = 5001347[0], q2 = 5001373[0], 0-prime	10	3
	q = 5001360 -+  17: q1 = 5001343[1], q2 = 5001377[0], 1-prime	6	7
	q = 5001360 -+  19: q1 = 5001341[0], q2 = 5001379[1], 1-prime	4	9
	q = 5001360 -+  23: q1 = 5001337[0], q2 = 5001383[0], 0-prime	0*	2
	q = 5001360 -+  29: q1 = 5001331[0], q2 = 5001389[0], 0-prime	5	8
	q = 5001360 -+  31: q1 = 5001329[0], q2 = 5001391[1], 1-prime	3	10
	q = 5001360 -+  37: q1 = 5001323[0], q2 = 5001397[1], 1-prime	8	5
	q = 5001360 -+  41: q1 = 5001319[1], q2 = 5001401[0], 1-prime	4	9
	q = 5001360 -+  43: q1 = 5001317[0], q2 = 5001403[0], 0-prime	2	0*
	q = 5001360 -+  47: q1 = 5001313[0], q2 = 5001407[1], 1-prime	9	4
	q = 5001360 -+  53: q1 = 5001307[1], q2 = 5001413[1], 2-prime	3	10
	q = 5001360 -+  59: q1 = 5001301[1], q2 = 5001419[0], 1-prime	8	5
	q = 5001360 -+  61: q1 = 5001299[1], q2 = 5001421[1], 2-prime	6	7
	q = 5001360 -+  67: q1 = 5001293[0], q2 = 5001427[0], 0-prime	0*	2
	q = 5001360 -+  71: q1 = 5001289[1], q2 = 5001431[1], 2-prime	7	6
	q = 5001360 -+  73: q1 = 5001287[0], q2 = 5001433[1], 1-prime	5	8
	q = 5001360 -+  79: q1 = 5001281[0], q2 = 5001439[0], 0-prime	10	3
	q = 5001360 -+  83: q1 = 5001277[1], q2 = 5001443[1], 2-prime	6	7
	q = 5001360 -+  89: q1 = 5001271[0], q2 = 5001449[0], 0-prime	0*	2
	q = 5001360 -+  97: q1 = 5001263[0], q2 = 5001457[0], 0-prime	3	10
	q = 5001360 -+ 101: q1 = 5001259[0], q2 = 5001461[1], 1-prime	10	3
	q = 5001360 -+ 103: q1 = 5001257[0], q2 = 5001463[0], 0-prime	8	5
New upper-interval, tagging its primes:
	q = 5001570 -+   1: q1 = 5001569[0], q2 = 5001571[0], 0-prime	1	3
	q = 5001570 -+  11: q1 = 5001559[1], q2 = 5001581[0], 1-prime	2	2
	q = 5001570 -+  13: q1 = 5001557[0], q2 = 5001583[0], 0-prime	0*	4
	q = 5001570 -+  17: q1 = 5001553[0], q2 = 5001587[0], 0-prime	7	8
	q = 5001570 -+  19: q1 = 5001551[0], q2 = 5001589[0], 0-prime	5	10
	q = 5001570 -+  23: q1 = 5001547[1], q2 = 5001593[1], 2-prime	1	3
	q = 5001570 -+  29: q1 = 5001541[0], q2 = 5001599[0], 0-prime	6	9
	q = 5001570 -+  31: q1 = 5001539[1], q2 = 5001601[0], 1-prime	4	0*
	q = 5001570 -+  37: q1 = 5001533[0], q2 = 5001607[0], 0-prime	9	6
	q = 5001570 -+  41: q1 = 5001529[0], q2 = 5001611[0], 0-prime	5	10
	q = 5001570 -+  43: q1 = 5001527[0], q2 = 5001613[0], 0-prime	3	1
	q = 5001570 -+  47: q1 = 5001523[1], q2 = 5001617[0], 1-prime	10	5
	q = 5001570 -+  53: q1 = 5001517[0], q2 = 5001623[0], 0-prime	4	0*
	q = 5001570 -+  59: q1 = 5001511[0], q2 = 5001629[1], 1-prime	9	6
	q = 5001570 -+  61: q1 = 5001509[0], q2 = 5001631[0], 0-prime	7	8
	q = 5001570 -+  67: q1 = 5001503[0], q2 = 5001637[0], 0-prime	1	3
	q = 5001570 -+  71: q1 = 5001499[0], q2 = 5001641[0], 0-prime	8	7
	q = 5001570 -+  73: q1 = 5001497[0], q2 = 5001643[1], 1-prime	6	9
	q = 5001570 -+  79: q1 = 5001491[0], q2 = 5001649[0], 0-prime	0*	4
	q = 5001570 -+  83: q1 = 5001487[1], q2 = 5001653[1], 2-prime	7	8
	q = 5001570 -+  89: q1 = 5001481[1], q2 = 5001659[0], 1-prime	1	3
	q = 5001570 -+  97: q1 = 5001473[0], q2 = 5001667[0], 0-prime	4	0*
	q = 5001570 -+ 101: q1 = 5001469[0], q2 = 5001671[1], 1-prime	0*	4
	q = 5001570 -+ 103: q1 = 5001467[0], q2 = 5001673[0], 0-prime	9	6
New upper-interval, tagging its primes:
	q = 5001780 -+   1: q1 = 5001779[1], q2 = 5001781[0], 1-prime	2	4
	q = 5001780 -+  11: q1 = 5001769[0], q2 = 5001791[0], 0-prime	3	3
	q = 5001780 -+  13: q1 = 5001767[1], q2 = 5001793[0], 1-prime	1	5
	q = 5001780 -+  17: q1 = 5001763[0], q2 = 5001797[0], 0-prime	8	9
	q = 5001780 -+  19: q1 = 5001761[1], q2 = 5001799[0], 1-prime	6	0*
	q = 5001780 -+  23: q1 = 5001757[0], q2 = 5001803[0], 0-prime	2	4
	q = 5001780 -+  29: q1 = 5001751[0], q2 = 5001809[1], 1-prime	7	10
	q = 5001780 -+  31: q1 = 5001749[1], q2 = 5001811[0], 1-prime	5	1
	q = 5001780 -+  37: q1 = 5001743[1], q2 = 5001817[0], 1-prime	10	7
	q = 5001780 -+  41: q1 = 5001739[1], q2 = 5001821[0], 1-prime	6	0*
	q = 5001780 -+  43: q1 = 5001737[0], q2 = 5001823[0], 0-prime	4	2
	q = 5001780 -+  47: q1 = 5001733[0], q2 = 5001827[0], 0-prime	0*	6
	q = 5001780 -+  53: q1 = 5001727[0], q2 = 5001833[0], 0-prime	5	1
	q = 5001780 -+  59: q1 = 5001721[0], q2 = 5001839[0], 0-prime	10	7
	q = 5001780 -+  61: q1 = 5001719[0], q2 = 5001841[0], 0-prime	8	9
	q = 5001780 -+  67: q1 = 5001713[0], q2 = 5001847[0], 0-prime	2	4
	q = 5001780 -+  71: q1 = 5001709[0], q2 = 5001851[0], 0-prime	9	8
	q = 5001780 -+  73: q1 = 5001707[1], q2 = 5001853[0], 1-prime	7	10
	q = 5001780 -+  79: q1 = 5001701[1], q2 = 5001859[0], 1-prime	1	5
	q = 5001780 -+  83: q1 = 5001697[0], q2 = 5001863[0], 0-prime	8	9
	q = 5001780 -+  89: q1 = 5001691[1], q2 = 5001869[0], 1-prime	2	4
	q = 5001780 -+  97: q1 = 5001683[0], q2 = 5001877[0], 0-prime	5	1
	q = 5001780 -+ 101: q1 = 5001679[1], q2 = 5001881[0], 1-prime	1	5
	q = 5001780 -+ 103: q1 = 5001677[0], q2 = 5001883[0], 0-prime	10	7
New upper-interval, tagging its primes:
	q = 5001990 -+   1: q1 = 5001989[0], q2 = 5001991[0], 0-prime	3	5
	q = 5001990 -+  11: q1 = 5001979[1], q2 = 5002001[1], 2-prime	4	4
	q = 5001990 -+  13: q1 = 5001977[0], q2 = 5002003[1], 1-prime	2	6
	q = 5001990 -+  17: q1 = 5001973[0], q2 = 5002007[0], 0-prime	9	10
	q = 5001990 -+  19: q1 = 5001971[0], q2 = 5002009[0], 0-prime	7	1
	q = 5001990 -+  23: q1 = 5001967[1], q2 = 5002013[0], 1-prime	3	5
	q = 5001990 -+  29: q1 = 5001961[0], q2 = 5002019[0], 0-prime	8	0*
	q = 5001990 -+  31: q1 = 5001959[0], q2 = 5002021[0], 0-prime	6	2
	q = 5001990 -+  37: q1 = 5001953[0], q2 = 5002027[0], 0-prime	0*	8
	q = 5001990 -+  41: q1 = 5001949[0], q2 = 5002031[0], 0-prime	7	1
	q = 5001990 -+  43: q1 = 5001947[0], q2 = 5002033[0], 0-prime	5	3
	q = 5001990 -+  47: q1 = 5001943[0], q2 = 5002037[0], 0-prime	1	7
	q = 5001990 -+  53: q1 = 5001937[0], q2 = 5002043[0], 0-prime	6	2
	q = 5001990 -+  59: q1 = 5001931[0], q2 = 5002049[0], 0-prime	0*	8
	q = 5001990 -+  61: q1 = 5001929[0], q2 = 5002051[1], 1-prime	9	10
	q = 5001990 -+  67: q1 = 5001923[1], q2 = 5002057[1], 2-prime	3	5
	q = 5001990 -+  71: q1 = 5001919[0], q2 = 5002061[0], 0-prime	10	9
	q = 5001990 -+  73: q1 = 5001917[0], q2 = 5002063[0], 0-prime	8	0*
	q = 5001990 -+  79: q1 = 5001911[1], q2 = 5002069[0], 1-prime	2	6
	q = 5001990 -+  83: q1 = 5001907[1], q2 = 5002073[0], 1-prime	9	10
	q = 5001990 -+  89: q1 = 5001901[0], q2 = 5002079[0], 0-prime	3	5
	q = 5001990 -+  97: q1 = 5001893[0], q2 = 5002087[0], 0-prime	6	2
	q = 5001990 -+ 101: q1 = 5001889[0], q2 = 5002091[0], 0-prime	2	6
	q = 5001990 -+ 103: q1 = 5001887[0], q2 = 5002093[1], 1-prime	0*	8
New upper-interval, tagging its primes:
	q = 5002200 -+   1: q1 = 5002199[0], q2 = 5002201[0], 0-prime	4	6
	q = 5002200 -+  11: q1 = 5002189[1], q2 = 5002211[1], 2-prime	5	5
	q = 5002200 -+  13: q1 = 5002187[0], q2 = 5002213[0], 0-prime	3	7
	q = 5002200 -+  17: q1 = 5002183[0], q2 = 5002217[0], 0-prime	10	0*
	q = 5002200 -+  19: q1 = 5002181[0], q2 = 5002219[1], 1-prime	8	2
	q = 5002200 -+  23: q1 = 5002177[0], q2 = 5002223[1], 1-prime	4	6
	q = 5002200 -+  29: q1 = 5002171[0], q2 = 5002229[1], 1-prime	9	1
	q = 5002200 -+  31: q1 = 5002169[0], q2 = 5002231[0], 0-prime	7	3
	q = 5002200 -+  37: q1 = 5002163[0], q2 = 5002237[1], 1-prime	1	9
	q = 5002200 -+  41: q1 = 5002159[0], q2 = 5002241[1], 1-prime	8	2
	q = 5002200 -+  43: q1 = 5002157[1], q2 = 5002243[0], 1-prime	6	4
	q = 5002200 -+  47: q1 = 5002153[0], q2 = 5002247[0], 0-prime	2	8
	q = 5002200 -+  53: q1 = 5002147[0], q2 = 5002253[0], 0-prime	7	3
	q = 5002200 -+  59: q1 = 5002141[0], q2 = 5002259[1], 1-prime	1	9
	q = 5002200 -+  61: q1 = 5002139[0], q2 = 5002261[0], 0-prime	10	0*
	q = 5002200 -+  67: q1 = 5002133[1], q2 = 5002267[0], 1-prime	4	6
	q = 5002200 -+  71: q1 = 5002129[0], q2 = 5002271[0], 0-prime	0*	10
	q = 5002200 -+  73: q1 = 5002127[0], q2 = 5002273[1], 1-prime	9	1
	q = 5002200 -+  79: q1 = 5002121[0], q2 = 5002279[0], 0-prime	3	7
	q = 5002200 -+  83: q1 = 5002117[0], q2 = 5002283[0], 0-prime	10	0*
	q = 5002200 -+  89: q1 = 5002111[0], q2 = 5002289[0], 0-prime	4	6
	q = 5002200 -+  97: q1 = 5002103[1], q2 = 5002297[0], 1-prime	7	3
	q = 5002200 -+ 101: q1 = 5002099[0], q2 = 5002301[0], 0-prime	3	7
	q = 5002200 -+ 103: q1 = 5002097[0], q2 = 5002303[0], 0-prime	1	9
At this point the above pattern repeats.
Resulting div-11 bitmap, consisting of 11 48-bit pieces:
q0		q0%11			div-11 bitmap[hi24,lo24]:				#set:
5000100	6	000000010000000000000000 000100000000001000010000	4	<*** [lo|hi]24: q = [5000100,5000100 -+ D/2]
5000310	7	100000000010000100000000 000000100000000001000000	5
5000520	8	000000000000100000000000 000010000100000000000000	3
5000730	9	010001000000000000000100 000000010000100000000100	6
5000940	10	000100001000000000100001 000000000010000000000000	5
5001150	0	000000000000000000000010 010000000000000000000000	2
5001360	1	000000000000010000000000 100001000000000100001000	5
5001570	2	001000000001000010000000 001000000000000000100010	6
5001780	3	000000000000001000010000 000000000001000000000000	3
5001990	4	000000100000000001000000 000000001000010000000001	5
5002200	5	000010000100000000001000 000000000000000010000000	4
There are 48 set bits in total. Init a const byte-array to capture this map, 8 byte-sextets ordered by q0%11:
q0%11 [hi24|lo24]:	lo24	hi24	bytewise:
0	000002400000	400000	000002
1	000400840108	840108	000400
2	201080200022	200022	201080
3	000210001000	001000	000210
4	020040008401	008401	020040
5	084008000080	000080	084008
6	010000100210	100210	010000
7	802100020040	020040	802100
8	000800084000	084000	000800
9	440004010804	010804	440004
10	108021002000	002000	108021

======================================================
Q: Is the patterning different for M even?

Using B2_start = 5000000, B2 = 5002000, Bigstep = 210, M = 2
Stage 2 q0 = 5000100, k0 = 23810
New upper-interval, tagging its primes:	q1%11/is-div-by-11:
	q = 5000100 -   1: q1 = 5000099[0]	5	0
	q = 5000100 -  11: q1 = 5000089[0]	6	0
	q = 5000100 -  13: q1 = 5000087[1]	4	0
	q = 5000100 -  17: q1 = 5000083[0]	0*	1
	q = 5000100 -  19: q1 = 5000081[1]	9	0
	q = 5000100 -  23: q1 = 5000077[1]	5	0
	q = 5000100 -  29: q1 = 5000071[0]	10	0
	q = 5000100 -  31: q1 = 5000069[0]	8	0
	q = 5000100 -  37: q1 = 5000063[0]	2	0
	q = 5000100 -  41: q1 = 5000059[0]	9	0
	q = 5000100 -  43: q1 = 5000057[0]	7	0
	q = 5000100 -  47: q1 = 5000053[0]	3	0
	q = 5000100 -  53: q1 = 5000047[0]	8	0
	q = 5000100 -  59: q1 = 5000041[0]	2	0
	q = 5000100 -  61: q1 = 5000039[0]	0*	1
	q = 5000100 -  67: q1 = 5000033[0]	5	0
	q = 5000100 -  71: q1 = 5000029[0]	1	0
	q = 5000100 -  73: q1 = 5000027[0]	10	0
	q = 5000100 -  79: q1 = 5000021[0]	4	0
	q = 5000100 -  83: q1 = 5000017[0]	0*	1
	q = 5000100 -  89: q1 = 5000011[1]	5	0
	q = 5000100 -  97: q1 = 5000003[0]	8	0
	q = 5000100 - 101: q1 = 4999999[1]	4	0
	q = 5000100 - 103: q1 = 4999997[0]	2	0
	q = 5000100 - 107: q1 = 4999993[0]	9	0
	q = 5000100 - 109: q1 = 4999991[0]	7	0
	q = 5000100 - 113: q1 = 4999987[0]	3	0
	q = 5000100 - 121: q1 = 4999979[0]	6	0
	q = 5000100 - 127: q1 = 4999973[0]	0*	1
	q = 5000100 - 131: q1 = 4999969[0]	7	0
	q = 5000100 - 137: q1 = 4999963[1]	1	0
	q = 5000100 - 139: q1 = 4999961[1]	10	0
	q = 5000100 - 143: q1 = 4999957[1]	6	0
	q = 5000100 - 149: q1 = 4999951[0]	0*	1
	q = 5000100 - 151: q1 = 4999949[1]	9	0
	q = 5000100 - 157: q1 = 4999943[0]	3	0
	q = 5000100 - 163: q1 = 4999937[0]	8	0
	q = 5000100 - 167: q1 = 4999933[1]	4	0
	q = 5000100 - 169: q1 = 4999931[0]	2	0
	q = 5000100 - 173: q1 = 4999927[0]	9	0
	q = 5000100 - 179: q1 = 4999921[0]	3	0
	q = 5000100 - 181: q1 = 4999919[0]	1	0
	q = 5000100 - 187: q1 = 4999913[1]	6	0
	q = 5000100 - 191: q1 = 4999909[0]	2	0
	q = 5000100 - 193: q1 = 4999907[0]	0*	1
	q = 5000100 - 197: q1 = 4999903[0]	7	0
	q = 5000100 - 199: q1 = 4999901[0]	5	0
	q = 5000100 - 209: q1 = 4999891[0]	6	0
New upper-interval, tagging its primes:
	q = 5000310 -   1: q1 = 5000309[0]	6	0
	q = 5000310 -  11: q1 = 5000299[1]	7	0
	q = 5000310 -  13: q1 = 5000297[0]	5	0
	q = 5000310 -  17: q1 = 5000293[0]	1	0
	q = 5000310 -  19: q1 = 5000291[0]	10	0
	q = 5000310 -  23: q1 = 5000287[0]	6	0
	q = 5000310 -  29: q1 = 5000281[0]	0*	1
	q = 5000310 -  31: q1 = 5000279[0]	9	0
	q = 5000310 -  37: q1 = 5000273[0]	3	0
	q = 5000310 -  41: q1 = 5000269[0]	10	0
	q = 5000310 -  43: q1 = 5000267[0]	8	0
	q = 5000310 -  47: q1 = 5000263[1]	4	0
	q = 5000310 -  53: q1 = 5000257[1]	9	0
	q = 5000310 -  59: q1 = 5000251[1]	3	0
	q = 5000310 -  61: q1 = 5000249[0]	1	0
	q = 5000310 -  67: q1 = 5000243[0]	6	0
	q = 5000310 -  71: q1 = 5000239[0]	2	0
	q = 5000310 -  73: q1 = 5000237[0]	0*	1
	q = 5000310 -  79: q1 = 5000231[0]	5	0
	q = 5000310 -  83: q1 = 5000227[0]	1	0
	q = 5000310 -  89: q1 = 5000221[0]	6	0
	q = 5000310 -  97: q1 = 5000213[1]	9	0
	q = 5000310 - 101: q1 = 5000209[0]	5	0
	q = 5000310 - 103: q1 = 5000207[0]	3	0
	q = 5000310 - 107: q1 = 5000203[0]	10	0
	q = 5000310 - 109: q1 = 5000201[1]	8	0
	q = 5000310 - 113: q1 = 5000197[1]	4	0
	q = 5000310 - 121: q1 = 5000189[0]	7	0
	q = 5000310 - 127: q1 = 5000183[0]	1	0
	q = 5000310 - 131: q1 = 5000179[0]	8	0
	q = 5000310 - 137: q1 = 5000173[0]	2	0
	q = 5000310 - 139: q1 = 5000171[0]	0*	1
	q = 5000310 - 143: q1 = 5000167[1]	7	0
	q = 5000310 - 149: q1 = 5000161[1]	1	0
	q = 5000310 - 151: q1 = 5000159[0]	10	0
	q = 5000310 - 157: q1 = 5000153[1]	4	0
	q = 5000310 - 163: q1 = 5000147[0]	9	0
	q = 5000310 - 167: q1 = 5000143[0]	5	0
	q = 5000310 - 169: q1 = 5000141[0]	3	0
	q = 5000310 - 173: q1 = 5000137[0]	10	0
	q = 5000310 - 179: q1 = 5000131[0]	4	0
	q = 5000310 - 181: q1 = 5000129[0]	2	0
	q = 5000310 - 187: q1 = 5000123[0]	7	0
	q = 5000310 - 191: q1 = 5000119[0]	3	0
	q = 5000310 - 193: q1 = 5000117[0]	1	0
	q = 5000310 - 197: q1 = 5000113[1]	8	0
	q = 5000310 - 199: q1 = 5000111[1]	6	0
	q = 5000310 - 209: q1 = 5000101[1]	7	0
New upper-interval, tagging its primes:
	q = 5000520 -   1: q1 = 5000519[1]	7	0
	q = 5000520 -  11: q1 = 5000509[0]	8	0
	q = 5000520 -  13: q1 = 5000507[0]	6	0
	q = 5000520 -  17: q1 = 5000503[1]	2	0
	q = 5000520 -  19: q1 = 5000501[0]	0*	1
	q = 5000520 -  23: q1 = 5000497[0]	7	0
	q = 5000520 -  29: q1 = 5000491[1]	1	0
	q = 5000520 -  31: q1 = 5000489[0]	10	0
	q = 5000520 -  37: q1 = 5000483[0]	4	0
	q = 5000520 -  41: q1 = 5000479[0]	0*	1
	q = 5000520 -  43: q1 = 5000477[0]	9	0
	q = 5000520 -  47: q1 = 5000473[1]	5	0
	q = 5000520 -  53: q1 = 5000467[0]	10	0
	q = 5000520 -  59: q1 = 5000461[0]	4	0
	q = 5000520 -  61: q1 = 5000459[0]	2	0
	q = 5000520 -  67: q1 = 5000453[0]	7	0
	q = 5000520 -  71: q1 = 5000449[0]	3	0
	q = 5000520 -  73: q1 = 5000447[0]	1	0
	q = 5000520 -  79: q1 = 5000441[0]	6	0
	q = 5000520 -  83: q1 = 5000437[0]	2	0
	q = 5000520 -  89: q1 = 5000431[0]	7	0
	q = 5000520 -  97: q1 = 5000423[1]	10	0
	q = 5000520 - 101: q1 = 5000419[0]	6	0
	q = 5000520 - 103: q1 = 5000417[0]	4	0
	q = 5000520 - 107: q1 = 5000413[0]	0*	1
	q = 5000520 - 109: q1 = 5000411[0]	9	0
	q = 5000520 - 113: q1 = 5000407[0]	5	0
	q = 5000520 - 121: q1 = 5000399[1]	8	0
	q = 5000520 - 127: q1 = 5000393[0]	2	0
	q = 5000520 - 131: q1 = 5000389[1]	9	0
	q = 5000520 - 137: q1 = 5000383[0]	3	0
	q = 5000520 - 139: q1 = 5000381[1]	1	0
	q = 5000520 - 143: q1 = 5000377[0]	8	0
	q = 5000520 - 149: q1 = 5000371[0]	2	0
	q = 5000520 - 151: q1 = 5000369[0]	0*	1
	q = 5000520 - 157: q1 = 5000363[0]	5	0
	q = 5000520 - 163: q1 = 5000357[0]	10	0
	q = 5000520 - 167: q1 = 5000353[0]	6	0
	q = 5000520 - 169: q1 = 5000351[0]	4	0
	q = 5000520 - 173: q1 = 5000347[0]	0*	1
	q = 5000520 - 179: q1 = 5000341[0]	5	0
	q = 5000520 - 181: q1 = 5000339[1]	3	0
	q = 5000520 - 187: q1 = 5000333[0]	8	0
	q = 5000520 - 191: q1 = 5000329[0]	4	0
	q = 5000520 - 193: q1 = 5000327[0]	2	0
	q = 5000520 - 197: q1 = 5000323[0]	9	0
	q = 5000520 - 199: q1 = 5000321[1]	7	0
	q = 5000520 - 209: q1 = 5000311[1]	8	0
New upper-interval, tagging its primes:
	q = 5000730 -   1: q1 = 5000729[0]	8	0
	q = 5000730 -  11: q1 = 5000719[0]	9	0
	q = 5000730 -  13: q1 = 5000717[0]	7	0
	q = 5000730 -  17: q1 = 5000713[1]	3	0
	q = 5000730 -  19: q1 = 5000711[0]	1	0
	q = 5000730 -  23: q1 = 5000707[0]	8	0
	q = 5000730 -  29: q1 = 5000701[1]	2	0
	q = 5000730 -  31: q1 = 5000699[0]	0*	1
	q = 5000730 -  37: q1 = 5000693[0]	5	0
	q = 5000730 -  41: q1 = 5000689[1]	1	0
	q = 5000730 -  43: q1 = 5000687[1]	10	0
	q = 5000730 -  47: q1 = 5000683[0]	6	0
	q = 5000730 -  53: q1 = 5000677[0]	0*	1
	q = 5000730 -  59: q1 = 5000671[0]	5	0
	q = 5000730 -  61: q1 = 5000669[0]	3	0
	q = 5000730 -  67: q1 = 5000663[0]	8	0
	q = 5000730 -  71: q1 = 5000659[0]	4	0
	q = 5000730 -  73: q1 = 5000657[1]	2	0
	q = 5000730 -  79: q1 = 5000651[1]	7	0
	q = 5000730 -  83: q1 = 5000647[0]	3	0
	q = 5000730 -  89: q1 = 5000641[0]	8	0
	q = 5000730 -  97: q1 = 5000633[0]	0*	1
	q = 5000730 - 101: q1 = 5000629[0]	7	0
	q = 5000730 - 103: q1 = 5000627[1]	5	0
	q = 5000730 - 107: q1 = 5000623[1]	1	0
	q = 5000730 - 109: q1 = 5000621[0]	10	0
	q = 5000730 - 113: q1 = 5000617[0]	6	0
	q = 5000730 - 121: q1 = 5000609[0]	9	0
	q = 5000730 - 127: q1 = 5000603[0]	3	0
	q = 5000730 - 131: q1 = 5000599[0]	10	0
	q = 5000730 - 137: q1 = 5000593[0]	4	0
	q = 5000730 - 139: q1 = 5000591[0]	2	0
	q = 5000730 - 143: q1 = 5000587[0]	9	0
	q = 5000730 - 149: q1 = 5000581[1]	3	0
	q = 5000730 - 151: q1 = 5000579[0]	1	0
	q = 5000730 - 157: q1 = 5000573[0]	6	0
	q = 5000730 - 163: q1 = 5000567[0]	0*	1
	q = 5000730 - 167: q1 = 5000563[1]	7	0
	q = 5000730 - 169: q1 = 5000561[0]	5	0
	q = 5000730 - 173: q1 = 5000557[0]	1	0
	q = 5000730 - 179: q1 = 5000551[1]	6	0
	q = 5000730 - 181: q1 = 5000549[1]	4	0
	q = 5000730 - 187: q1 = 5000543[1]	9	0
	q = 5000730 - 191: q1 = 5000539[1]	5	0
	q = 5000730 - 193: q1 = 5000537[0]	3	0
	q = 5000730 - 197: q1 = 5000533[0]	10	0
	q = 5000730 - 199: q1 = 5000531[0]	8	0
	q = 5000730 - 209: q1 = 5000521[0]	9	0
New upper-interval, tagging its primes:
	q = 5000940 -   1: q1 = 5000939[1]	9	0
	q = 5000940 -  11: q1 = 5000929[1]	10	0
	q = 5000940 -  13: q1 = 5000927[1]	8	0
	q = 5000940 -  17: q1 = 5000923[1]	4	0
	q = 5000940 -  19: q1 = 5000921[0]	2	0
	q = 5000940 -  23: q1 = 5000917[1]	9	0
	q = 5000940 -  29: q1 = 5000911[0]	3	0
	q = 5000940 -  31: q1 = 5000909[0]	1	0
	q = 5000940 -  37: q1 = 5000903[1]	6	0
	q = 5000940 -  41: q1 = 5000899[0]	2	0
	q = 5000940 -  43: q1 = 5000897[0]	0*	1
	q = 5000940 -  47: q1 = 5000893[0]	7	0
	q = 5000940 -  53: q1 = 5000887[0]	1	0
	q = 5000940 -  59: q1 = 5000881[1]	6	0
	q = 5000940 -  61: q1 = 5000879[0]	4	0
	q = 5000940 -  67: q1 = 5000873[0]	9	0
	q = 5000940 -  71: q1 = 5000869[0]	5	0
	q = 5000940 -  73: q1 = 5000867[0]	3	0
	q = 5000940 -  79: q1 = 5000861[1]	8	0
	q = 5000940 -  83: q1 = 5000857[0]	4	0
	q = 5000940 -  89: q1 = 5000851[1]	9	0
	q = 5000940 -  97: q1 = 5000843[0]	1	0
	q = 5000940 - 101: q1 = 5000839[0]	8	0
	q = 5000940 - 103: q1 = 5000837[0]	6	0
	q = 5000940 - 107: q1 = 5000833[0]	2	0
	q = 5000940 - 109: q1 = 5000831[0]	0*	1
	q = 5000940 - 113: q1 = 5000827[0]	7	0
	q = 5000940 - 121: q1 = 5000819[0]	10	0
	q = 5000940 - 127: q1 = 5000813[0]	4	0
	q = 5000940 - 131: q1 = 5000809[0]	0*	1
	q = 5000940 - 137: q1 = 5000803[0]	5	0
	q = 5000940 - 139: q1 = 5000801[0]	3	0
	q = 5000940 - 143: q1 = 5000797[1]	10	0
	q = 5000940 - 149: q1 = 5000791[1]	4	0
	q = 5000940 - 151: q1 = 5000789[0]	2	0
	q = 5000940 - 157: q1 = 5000783[1]	7	0
	q = 5000940 - 163: q1 = 5000777[1]	1	0
	q = 5000940 - 167: q1 = 5000773[0]	8	0
	q = 5000940 - 169: q1 = 5000771[0]	6	0
	q = 5000940 - 173: q1 = 5000767[0]	2	0
	q = 5000940 - 179: q1 = 5000761[1]	7	0
	q = 5000940 - 181: q1 = 5000759[1]	5	0
	q = 5000940 - 187: q1 = 5000753[0]	10	0
	q = 5000940 - 191: q1 = 5000749[0]	6	0
	q = 5000940 - 193: q1 = 5000747[1]	4	0
	q = 5000940 - 197: q1 = 5000743[0]	0*	1
	q = 5000940 - 199: q1 = 5000741[1]	9	0
	q = 5000940 - 209: q1 = 5000731[0]	10	0
New upper-interval, tagging its primes:
	q = 5001150 -   1: q1 = 5001149[0]	10	0
	q = 5001150 -  11: q1 = 5001139[0]	0*	1
	q = 5001150 -  13: q1 = 5001137[0]	9	0
	q = 5001150 -  17: q1 = 5001133[0]	5	0
	q = 5001150 -  19: q1 = 5001131[0]	3	0
	q = 5001150 -  23: q1 = 5001127[1]	10	0
	q = 5001150 -  29: q1 = 5001121[1]	4	0
	q = 5001150 -  31: q1 = 5001119[1]	2	0
	q = 5001150 -  37: q1 = 5001113[0]	7	0
	q = 5001150 -  41: q1 = 5001109[0]	3	0
	q = 5001150 -  43: q1 = 5001107[0]	1	0
	q = 5001150 -  47: q1 = 5001103[0]	8	0
	q = 5001150 -  53: q1 = 5001097[0]	2	0
	q = 5001150 -  59: q1 = 5001091[0]	7	0
	q = 5001150 -  61: q1 = 5001089[1]	5	0
	q = 5001150 -  67: q1 = 5001083[1]	10	0
	q = 5001150 -  71: q1 = 5001079[0]	6	0
	q = 5001150 -  73: q1 = 5001077[0]	4	0
	q = 5001150 -  79: q1 = 5001071[1]	9	0
	q = 5001150 -  83: q1 = 5001067[1]	5	0
	q = 5001150 -  89: q1 = 5001061[0]	10	0
	q = 5001150 -  97: q1 = 5001053[1]	2	0
	q = 5001150 - 101: q1 = 5001049[1]	9	0
	q = 5001150 - 103: q1 = 5001047[0]	7	0
	q = 5001150 - 107: q1 = 5001043[0]	3	0
	q = 5001150 - 109: q1 = 5001041[0]	1	0
	q = 5001150 - 113: q1 = 5001037[0]	8	0
	q = 5001150 - 121: q1 = 5001029[0]	0*	1
	q = 5001150 - 127: q1 = 5001023[1]	5	0
	q = 5001150 - 131: q1 = 5001019[1]	1	0
	q = 5001150 - 137: q1 = 5001013[0]	6	0
	q = 5001150 - 139: q1 = 5001011[0]	4	0
	q = 5001150 - 143: q1 = 5001007[0]	0*	1
	q = 5001150 - 149: q1 = 5001001[1]	5	0
	q = 5001150 - 151: q1 = 5000999[0]	3	0
	q = 5001150 - 157: q1 = 5000993[1]	8	0
	q = 5001150 - 163: q1 = 5000987[1]	2	0
	q = 5001150 - 167: q1 = 5000983[0]	9	0
	q = 5001150 - 169: q1 = 5000981[1]	7	0
	q = 5001150 - 173: q1 = 5000977[1]	3	0
	q = 5001150 - 179: q1 = 5000971[0]	8	0
	q = 5001150 - 181: q1 = 5000969[0]	6	0
	q = 5001150 - 187: q1 = 5000963[0]	0*	1
	q = 5001150 - 191: q1 = 5000959[0]	7	0
	q = 5001150 - 193: q1 = 5000957[0]	5	0
	q = 5001150 - 197: q1 = 5000953[0]	1	0
	q = 5001150 - 199: q1 = 5000951[0]	10	0
	q = 5001150 - 209: q1 = 5000941[0]	0*	1
New upper-interval, tagging its primes:
	q = 5001360 -   1: q1 = 5001359[0]	0*	1
	q = 5001360 -  11: q1 = 5001349[0]	1	0
	q = 5001360 -  13: q1 = 5001347[0]	10	0
	q = 5001360 -  17: q1 = 5001343[1]	6	0
	q = 5001360 -  19: q1 = 5001341[0]	4	0
	q = 5001360 -  23: q1 = 5001337[0]	0*	1
	q = 5001360 -  29: q1 = 5001331[0]	5	0
	q = 5001360 -  31: q1 = 5001329[0]	3	0
	q = 5001360 -  37: q1 = 5001323[0]	8	0
	q = 5001360 -  41: q1 = 5001319[1]	4	0
	q = 5001360 -  43: q1 = 5001317[0]	2	0
	q = 5001360 -  47: q1 = 5001313[0]	9	0
	q = 5001360 -  53: q1 = 5001307[1]	3	0
	q = 5001360 -  59: q1 = 5001301[1]	8	0
	q = 5001360 -  61: q1 = 5001299[1]	6	0
	q = 5001360 -  67: q1 = 5001293[0]	0*	1
	q = 5001360 -  71: q1 = 5001289[1]	7	0
	q = 5001360 -  73: q1 = 5001287[0]	5	0
	q = 5001360 -  79: q1 = 5001281[0]	10	0
	q = 5001360 -  83: q1 = 5001277[1]	6	0
	q = 5001360 -  89: q1 = 5001271[0]	0*	1
	q = 5001360 -  97: q1 = 5001263[0]	3	0
	q = 5001360 - 101: q1 = 5001259[0]	10	0
	q = 5001360 - 103: q1 = 5001257[0]	8	0
	q = 5001360 - 107: q1 = 5001253[0]	4	0
	q = 5001360 - 109: q1 = 5001251[1]	2	0
	q = 5001360 - 113: q1 = 5001247[0]	9	0
	q = 5001360 - 121: q1 = 5001239[0]	1	0
	q = 5001360 - 127: q1 = 5001233[1]	6	0
	q = 5001360 - 131: q1 = 5001229[0]	2	0
	q = 5001360 - 137: q1 = 5001223[0]	7	0
	q = 5001360 - 139: q1 = 5001221[0]	5	0
	q = 5001360 - 143: q1 = 5001217[0]	1	0
	q = 5001360 - 149: q1 = 5001211[0]	6	0
	q = 5001360 - 151: q1 = 5001209[0]	4	0
	q = 5001360 - 157: q1 = 5001203[1]	9	0
	q = 5001360 - 163: q1 = 5001197[1]	3	0
	q = 5001360 - 167: q1 = 5001193[1]	10	0
	q = 5001360 - 169: q1 = 5001191[0]	8	0
	q = 5001360 - 173: q1 = 5001187[0]	4	0
	q = 5001360 - 179: q1 = 5001181[0]	9	0
	q = 5001360 - 181: q1 = 5001179[0]	7	0
	q = 5001360 - 187: q1 = 5001173[1]	1	0
	q = 5001360 - 191: q1 = 5001169[0]	8	0
	q = 5001360 - 193: q1 = 5001167[1]	6	0
	q = 5001360 - 197: q1 = 5001163[1]	2	0
	q = 5001360 - 199: q1 = 5001161[0]	0*	1
	q = 5001360 - 209: q1 = 5001151[0]	1	0
New upper-interval, tagging its primes:
	q = 5001570 -   1: q1 = 5001569[0]	1	0
	q = 5001570 -  11: q1 = 5001559[1]	2	0
	q = 5001570 -  13: q1 = 5001557[0]	0*	1
	q = 5001570 -  17: q1 = 5001553[0]	7	0
	q = 5001570 -  19: q1 = 5001551[0]	5	0
	q = 5001570 -  23: q1 = 5001547[1]	1	0
	q = 5001570 -  29: q1 = 5001541[0]	6	0
	q = 5001570 -  31: q1 = 5001539[1]	4	0
	q = 5001570 -  37: q1 = 5001533[0]	9	0
	q = 5001570 -  41: q1 = 5001529[0]	5	0
	q = 5001570 -  43: q1 = 5001527[0]	3	0
	q = 5001570 -  47: q1 = 5001523[1]	10	0
	q = 5001570 -  53: q1 = 5001517[0]	4	0
	q = 5001570 -  59: q1 = 5001511[0]	9	0
	q = 5001570 -  61: q1 = 5001509[0]	7	0
	q = 5001570 -  67: q1 = 5001503[0]	1	0
	q = 5001570 -  71: q1 = 5001499[0]	8	0
	q = 5001570 -  73: q1 = 5001497[0]	6	0
	q = 5001570 -  79: q1 = 5001491[0]	0*	1
	q = 5001570 -  83: q1 = 5001487[1]	7	0
	q = 5001570 -  89: q1 = 5001481[1]	1	0
	q = 5001570 -  97: q1 = 5001473[0]	4	0
	q = 5001570 - 101: q1 = 5001469[0]	0*	1
	q = 5001570 - 103: q1 = 5001467[0]	9	0
	q = 5001570 - 107: q1 = 5001463[0]	5	0
	q = 5001570 - 109: q1 = 5001461[1]	3	0
	q = 5001570 - 113: q1 = 5001457[0]	10	0
	q = 5001570 - 121: q1 = 5001449[0]	2	0
	q = 5001570 - 127: q1 = 5001443[1]	7	0
	q = 5001570 - 131: q1 = 5001439[0]	3	0
	q = 5001570 - 137: q1 = 5001433[1]	8	0
	q = 5001570 - 139: q1 = 5001431[1]	6	0
	q = 5001570 - 143: q1 = 5001427[0]	2	0
	q = 5001570 - 149: q1 = 5001421[1]	7	0
	q = 5001570 - 151: q1 = 5001419[0]	5	0
	q = 5001570 - 157: q1 = 5001413[1]	10	0
	q = 5001570 - 163: q1 = 5001407[1]	4	0
	q = 5001570 - 167: q1 = 5001403[0]	0*	1
	q = 5001570 - 169: q1 = 5001401[0]	9	0
	q = 5001570 - 173: q1 = 5001397[1]	5	0
	q = 5001570 - 179: q1 = 5001391[1]	10	0
	q = 5001570 - 181: q1 = 5001389[0]	8	0
	q = 5001570 - 187: q1 = 5001383[0]	2	0
	q = 5001570 - 191: q1 = 5001379[1]	9	0
	q = 5001570 - 193: q1 = 5001377[0]	7	0
	q = 5001570 - 197: q1 = 5001373[0]	3	0
	q = 5001570 - 199: q1 = 5001371[0]	1	0
	q = 5001570 - 209: q1 = 5001361[1]	2	0
New upper-interval, tagging its primes:
	q = 5001780 -   1: q1 = 5001779[1]	2	0
	q = 5001780 -  11: q1 = 5001769[0]	3	0
	q = 5001780 -  13: q1 = 5001767[1]	1	0
	q = 5001780 -  17: q1 = 5001763[0]	8	0
	q = 5001780 -  19: q1 = 5001761[1]	6	0
	q = 5001780 -  23: q1 = 5001757[0]	2	0
	q = 5001780 -  29: q1 = 5001751[0]	7	0
	q = 5001780 -  31: q1 = 5001749[1]	5	0
	q = 5001780 -  37: q1 = 5001743[1]	10	0
	q = 5001780 -  41: q1 = 5001739[1]	6	0
	q = 5001780 -  43: q1 = 5001737[0]	4	0
	q = 5001780 -  47: q1 = 5001733[0]	0*	1
	q = 5001780 -  53: q1 = 5001727[0]	5	0
	q = 5001780 -  59: q1 = 5001721[0]	10	0
	q = 5001780 -  61: q1 = 5001719[0]	8	0
	q = 5001780 -  67: q1 = 5001713[0]	2	0
	q = 5001780 -  71: q1 = 5001709[0]	9	0
	q = 5001780 -  73: q1 = 5001707[1]	7	0
	q = 5001780 -  79: q1 = 5001701[1]	1	0
	q = 5001780 -  83: q1 = 5001697[0]	8	0
	q = 5001780 -  89: q1 = 5001691[1]	2	0
	q = 5001780 -  97: q1 = 5001683[0]	5	0
	q = 5001780 - 101: q1 = 5001679[1]	1	0
	q = 5001780 - 103: q1 = 5001677[0]	10	0
	q = 5001780 - 107: q1 = 5001673[0]	6	0
	q = 5001780 - 109: q1 = 5001671[1]	4	0
	q = 5001780 - 113: q1 = 5001667[0]	0*	1
	q = 5001780 - 121: q1 = 5001659[0]	3	0
	q = 5001780 - 127: q1 = 5001653[1]	8	0
	q = 5001780 - 131: q1 = 5001649[0]	4	0
	q = 5001780 - 137: q1 = 5001643[1]	9	0
	q = 5001780 - 139: q1 = 5001641[0]	7	0
	q = 5001780 - 143: q1 = 5001637[0]	3	0
	q = 5001780 - 149: q1 = 5001631[0]	8	0
	q = 5001780 - 151: q1 = 5001629[1]	6	0
	q = 5001780 - 157: q1 = 5001623[0]	0*	1
	q = 5001780 - 163: q1 = 5001617[0]	5	0
	q = 5001780 - 167: q1 = 5001613[0]	1	0
	q = 5001780 - 169: q1 = 5001611[0]	10	0
	q = 5001780 - 173: q1 = 5001607[0]	6	0
	q = 5001780 - 179: q1 = 5001601[0]	0*	1
	q = 5001780 - 181: q1 = 5001599[0]	9	0
	q = 5001780 - 187: q1 = 5001593[1]	3	0
	q = 5001780 - 191: q1 = 5001589[0]	10	0
	q = 5001780 - 193: q1 = 5001587[0]	8	0
	q = 5001780 - 197: q1 = 5001583[0]	4	0
	q = 5001780 - 199: q1 = 5001581[0]	2	0
	q = 5001780 - 209: q1 = 5001571[0]	3	0
New upper-interval, tagging its primes:
	q = 5001990 -   1: q1 = 5001989[0]	3	0
	q = 5001990 -  11: q1 = 5001979[1]	4	0
	q = 5001990 -  13: q1 = 5001977[0]	2	0
	q = 5001990 -  17: q1 = 5001973[0]	9	0
	q = 5001990 -  19: q1 = 5001971[0]	7	0
	q = 5001990 -  23: q1 = 5001967[1]	3	0
	q = 5001990 -  29: q1 = 5001961[0]	8	0
	q = 5001990 -  31: q1 = 5001959[0]	6	0
	q = 5001990 -  37: q1 = 5001953[0]	0*	1
	q = 5001990 -  41: q1 = 5001949[0]	7	0
	q = 5001990 -  43: q1 = 5001947[0]	5	0
	q = 5001990 -  47: q1 = 5001943[0]	1	0
	q = 5001990 -  53: q1 = 5001937[0]	6	0
	q = 5001990 -  59: q1 = 5001931[0]	0*	1
	q = 5001990 -  61: q1 = 5001929[0]	9	0
	q = 5001990 -  67: q1 = 5001923[1]	3	0
	q = 5001990 -  71: q1 = 5001919[0]	10	0
	q = 5001990 -  73: q1 = 5001917[0]	8	0
	q = 5001990 -  79: q1 = 5001911[1]	2	0
	q = 5001990 -  83: q1 = 5001907[1]	9	0
	q = 5001990 -  89: q1 = 5001901[0]	3	0
	q = 5001990 -  97: q1 = 5001893[0]	6	0
	q = 5001990 - 101: q1 = 5001889[0]	2	0
	q = 5001990 - 103: q1 = 5001887[0]	0*	1
	q = 5001990 - 107: q1 = 5001883[0]	7	0
	q = 5001990 - 109: q1 = 5001881[0]	5	0
	q = 5001990 - 113: q1 = 5001877[0]	1	0
	q = 5001990 - 121: q1 = 5001869[0]	4	0
	q = 5001990 - 127: q1 = 5001863[0]	9	0
	q = 5001990 - 131: q1 = 5001859[0]	5	0
	q = 5001990 - 137: q1 = 5001853[0]	10	0
	q = 5001990 - 139: q1 = 5001851[0]	8	0
	q = 5001990 - 143: q1 = 5001847[0]	4	0
	q = 5001990 - 149: q1 = 5001841[0]	9	0
	q = 5001990 - 151: q1 = 5001839[0]	7	0
	q = 5001990 - 157: q1 = 5001833[0]	1	0
	q = 5001990 - 163: q1 = 5001827[0]	6	0
	q = 5001990 - 167: q1 = 5001823[0]	2	0
	q = 5001990 - 169: q1 = 5001821[0]	0*	1
	q = 5001990 - 173: q1 = 5001817[0]	7	0
	q = 5001990 - 179: q1 = 5001811[0]	1	0
	q = 5001990 - 181: q1 = 5001809[1]	10	0
	q = 5001990 - 187: q1 = 5001803[0]	4	0
	q = 5001990 - 191: q1 = 5001799[0]	0*	1
	q = 5001990 - 193: q1 = 5001797[0]	9	0
	q = 5001990 - 197: q1 = 5001793[0]	5	0
	q = 5001990 - 199: q1 = 5001791[0]	3	0
	q = 5001990 - 209: q1 = 5001781[0]	4	0
New upper-interval, tagging its primes:
	q = 5002200 -   1: q1 = 5002199[0]	4	0
	q = 5002200 -  11: q1 = 5002189[1]	5	0
	q = 5002200 -  13: q1 = 5002187[0]	3	0
	q = 5002200 -  17: q1 = 5002183[0]	10	0
	q = 5002200 -  19: q1 = 5002181[0]	8	0
	q = 5002200 -  23: q1 = 5002177[0]	4	0
	q = 5002200 -  29: q1 = 5002171[0]	9	0
	q = 5002200 -  31: q1 = 5002169[0]	7	0
	q = 5002200 -  37: q1 = 5002163[0]	1	0
	q = 5002200 -  41: q1 = 5002159[0]	8	0
	q = 5002200 -  43: q1 = 5002157[1]	6	0
	q = 5002200 -  47: q1 = 5002153[0]	2	0
	q = 5002200 -  53: q1 = 5002147[0]	7	0
	q = 5002200 -  59: q1 = 5002141[0]	1	0
	q = 5002200 -  61: q1 = 5002139[0]	10	0
	q = 5002200 -  67: q1 = 5002133[1]	4	0
	q = 5002200 -  71: q1 = 5002129[0]	0*	1
	q = 5002200 -  73: q1 = 5002127[0]	9	0
	q = 5002200 -  79: q1 = 5002121[0]	3	0
	q = 5002200 -  83: q1 = 5002117[0]	10	0
	q = 5002200 -  89: q1 = 5002111[0]	4	0
	q = 5002200 -  97: q1 = 5002103[1]	7	0
	q = 5002200 - 101: q1 = 5002099[0]	3	0
	q = 5002200 - 103: q1 = 5002097[0]	1	0
	q = 5002200 - 107: q1 = 5002093[1]	8	0
	q = 5002200 - 109: q1 = 5002091[0]	6	0
	q = 5002200 - 113: q1 = 5002087[0]	2	0
	q = 5002200 - 121: q1 = 5002079[0]	5	0
	q = 5002200 - 127: q1 = 5002073[0]	10	0
	q = 5002200 - 131: q1 = 5002069[0]	6	0
	q = 5002200 - 137: q1 = 5002063[0]	0*	1
	q = 5002200 - 139: q1 = 5002061[0]	9	0
	q = 5002200 - 143: q1 = 5002057[1]	5	0
	q = 5002200 - 149: q1 = 5002051[1]	10	0
	q = 5002200 - 151: q1 = 5002049[0]	8	0
	q = 5002200 - 157: q1 = 5002043[0]	2	0
	q = 5002200 - 163: q1 = 5002037[0]	7	0
	q = 5002200 - 167: q1 = 5002033[0]	3	0
	q = 5002200 - 169: q1 = 5002031[0]	1	0
	q = 5002200 - 173: q1 = 5002027[0]	8	0
	q = 5002200 - 179: q1 = 5002021[0]	2	0
	q = 5002200 - 181: q1 = 5002019[0]	0*	1
	q = 5002200 - 187: q1 = 5002013[0]	5	0
	q = 5002200 - 191: q1 = 5002009[0]	1	0
	q = 5002200 - 193: q1 = 5002007[0]	10	0
	q = 5002200 - 197: q1 = 5002003[1]	6	0
	q = 5002200 - 199: q1 = 5002001[1]	4	0
	q = 5002200 - 209: q1 = 5001991[0]	5	0
Resulting is-div-by-11 bitmaps, bits run LR corr. to q0-209 ... q0-1;
These contain the same 24-bit chunks as the M = 1 case, just the ordering differs:
q0		q0%11			div-11 bitmap[hi24,lo24]:		24-bit-chunk locations in M=1 map:
6	000100000000001000010000 000010000100000000001000	6.lo,5.hi	<*** [lo|hi]24: q = 5000100-[0,D/2],5000100-[D/2,D]
7	000000100000000001000000 000000010000000000000000	7.lo,6.hi
8	000010000100000000000000 100000000010000100000000	8.lo,7.hi
9	000000010000100000000100 000000000000100000000000	9.lo,8.hi
10	000000000010000000000000 010001000000000000000100	10.lo,9.hi
0	010000000000000000000000 000100001000000000100001	0.lo,10.hi
1	100001000000000100001000 000000000000000000000010	1.lo,0.hi
2	001000000000000000100010 000000000000010000000000	2.lo,1.hi
3	000000000001000000000000 001000000001000010000000	3.lo,2.hi
4	000000001000010000000001 000000000000001000010000	4.lo,3.hi
5	000000000000000010000000 000000100000000001000000	5.lo,4.hi
IDEA:
Init a set of 22 24-bit maplets, 2 for each value of q0%11, with [lo,hi]24 of each pair corr. to the [q0,q0 -+ D/2]
branches of the D-interval centered at q0. For D = 210, in terms of this, the above 2 bit-maplet tables look like so:
M = 1:
q0		q0%11			div-11 bitmap[hi24,lo24]:
5000100	6	6.hi,6.lo
5000310	7	7.hi,7.lo
5000520	8	8.hi,8.lo
5000730	9	9.hi,9.lo
5000940	10	10.hi,10.lo
5001150	0	0.hi,0.lo
5001360	1	1.hi,1.lo
5001570	2	2.hi,2.lo
5001780	3	3.hi,3.lo
5001990	4	4.hi,4.lo
5002200	5	5.hi,5.lo
M = 2:
q0		q0%11			div-11 bitmap[hi24,lo24]:
5000100	6	6.lo,5.hi
5000310	7	7.lo,6.hi
5000520	8	8.lo,7.hi
5000730	9	9.lo,8.hi
5000940	10	10.lo,9.hi
5001150	0	0.lo,10.hi
5001360	1	1.lo,0.hi
5001570	2	2.lo,1.hi
5001780	3	3.lo,2.hi
5001990	4	4.lo,3.hi
5002200	5	5.lo,4.hi
6	000100000000001000010000 000010000100000000001000	6.lo,5.hi	<*** [lo|hi]24: q = 5000100-[0,D/2],5000100-[D/2,D]
7	000000100000000001000000 000000010000000000000000	7.lo,6.hi
8	000010000100000000000000 100000000010000100000000	8.lo,7.hi
9	000000010000100000000100 000000000000100000000000	9.lo,8.hi
10	000000000010000000000000 010001000000000000000100	10.lo,9.hi
0	010000000000000000000000 000100001000000000100001	0.lo,10.hi
1	100001000000000100001000 000000000000000000000010	1.lo,0.hi
2	001000000000000000100010 000000000000010000000000	2.lo,1.hi
3	000000000001000000000000 001000000001000010000000	3.lo,2.hi
4	000000001000010000000001 000000000000001000010000	4.lo,3.hi
5	000000000000000010000000 000000100000000001000000	5.lo,4.hi
===============================
D = 420, M = 1:
MacBook:src ewmayer$ ./pm1 -bigstep 420 -b1 5000000 -b2 5005000 -m 1
Using B2_start = 5000000, B2 = 5005000, Bigstep = 420, M = 1
Stage 2 q0 = 5000100, k0 = 11905
New upper-interval, tagging its primes:
	q == 0 (mod 11) bitmap: 000000100000000001000000000000010000000000000000000100000000001000010000000010000100000000001000
k = 11905: q = 5000100
Processing 0-interval prime pairs:
	q1 = 5000099[0], q2 = 5000101[1], 1-prime
	q1 = 5000089[0], q2 = 5000111[1], 1-prime
	q1 = 5000087[1], q2 = 5000113[1], both prime
	q1 = 5000081[1], q2 = 5000119[0], 1-prime
	q1 = 5000077[1], q2 = 5000123[0], 1-prime
	q1 = 5000047[0], q2 = 5000153[1], 1-prime
	q1 = 5000039[0], q2 = 5000161[1], 1-prime
	q1 = 5000033[0], q2 = 5000167[1], 1-prime
	q1 = 5000011[1], q2 = 5000189[0], 1-prime
	q1 = 5000003[0], q2 = 5000197[1], 1-prime
	q1 = 4999999[1], q2 = 5000201[1], both prime
	q1 = 4999987[0], q2 = 5000213[1], 1-prime
	q1 = 4999963[1], q2 = 5000237[0], 1-prime
	q1 = 4999961[1], q2 = 5000239[0], 1-prime
	q1 = 4999957[1], q2 = 5000243[0], 1-prime
	q1 = 4999949[1], q2 = 5000251[1], both prime
	q1 = 4999943[0], q2 = 5000257[1], 1-prime
	q1 = 4999937[0], q2 = 5000263[1], 1-prime
	q1 = 4999933[1], q2 = 5000267[0], 1-prime
	q1 = 4999913[1], q2 = 5000287[0], 1-prime
	q1 = 4999901[0], q2 = 5000299[1], 1-prime
New upper-interval, tagging its primes:
	q == 0 (mod 11) bitmap: 000000010000100000000100000000000000100000000000000010000100000000000000100000000010000100000000
k = 11906: q = 5000520
Processing 0-interval prime pairs:
	q1 = 5000519[1], q2 = 5000521[0], 1-prime
	q1 = 5000503[1], q2 = 5000537[0], 1-prime
	q1 = 5000501[0], q2 = 5000539[1], 1-prime
	q1 = 5000497[0], q2 = 5000543[1], 1-prime
	q1 = 5000491[1], q2 = 5000549[1], both prime
	q1 = 5000489[0], q2 = 5000551[1], 1-prime
	q1 = 5000477[0], q2 = 5000563[1], 1-prime
	q1 = 5000473[1], q2 = 5000567[0], 1-prime
	q1 = 5000459[0], q2 = 5000581[1], 1-prime
	q1 = 5000423[1], q2 = 5000617[0], 1-prime
	q1 = 5000417[0], q2 = 5000623[1], 1-prime
	q1 = 5000413[0], q2 = 5000627[1], 1-prime
	q1 = 5000399[1], q2 = 5000641[0], 1-prime
	q1 = 5000389[1], q2 = 5000651[1], both prime
	q1 = 5000383[0], q2 = 5000657[1], 1-prime
	q1 = 5000381[1], q2 = 5000659[0], 1-prime
	q1 = 5000353[0], q2 = 5000687[1], 1-prime
	q1 = 5000351[0], q2 = 5000689[1], 1-prime
	q1 = 5000339[1], q2 = 5000701[1], both prime
	q1 = 5000327[0], q2 = 5000713[1], 1-prime
	q1 = 5000321[1], q2 = 5000719[0], 1-prime
	q1 = 5000311[1], q2 = 5000729[0], 1-prime
New upper-interval, tagging its primes:
	q == 0 (mod 11) bitmap: 010000000000000000000000000100001000000000100001000000000010000000000000010001000000000000000100
k = 11907: q = 5000940
Processing 0-interval prime pairs:
	q1 = 5000939[1], q2 = 5000941[0], 1-prime
	q1 = 5000929[1], q2 = 5000951[0], 1-prime
	q1 = 5000927[1], q2 = 5000953[0], 1-prime
	q1 = 5000923[1], q2 = 5000957[0], 1-prime
	q1 = 5000917[1], q2 = 5000963[0], 1-prime
	q1 = 5000903[1], q2 = 5000977[1], both prime
	q1 = 5000899[0], q2 = 5000981[1], 1-prime
	q1 = 5000893[0], q2 = 5000987[1], 1-prime
	q1 = 5000887[0], q2 = 5000993[1], 1-prime
	q1 = 5000881[1], q2 = 5000999[0], 1-prime
	q1 = 5000879[0], q2 = 5001001[1], 1-prime
	q1 = 5000861[1], q2 = 5001019[1], both prime
	q1 = 5000857[0], q2 = 5001023[1], 1-prime
	q1 = 5000851[1], q2 = 5001029[0], 1-prime
	q1 = 5000831[0], q2 = 5001049[1], 1-prime
	q1 = 5000827[0], q2 = 5001053[1], 1-prime
	q1 = 5000813[0], q2 = 5001067[1], 1-prime
	q1 = 5000809[0], q2 = 5001071[1], 1-prime
	q1 = 5000797[1], q2 = 5001083[1], both prime
	q1 = 5000791[1], q2 = 5001089[1], both prime
	q1 = 5000783[1], q2 = 5001097[0], 1-prime
	q1 = 5000777[1], q2 = 5001103[0], 1-prime
	q1 = 5000761[1], q2 = 5001119[1], both prime
	q1 = 5000759[1], q2 = 5001121[1], both prime
	q1 = 5000753[0], q2 = 5001127[1], 1-prime
	q1 = 5000747[1], q2 = 5001133[0], 1-prime
	q1 = 5000741[1], q2 = 5001139[0], 1-prime
New upper-interval, tagging its primes:
	q == 0 (mod 11) bitmap: 001000000000000000100010000000000000010000000000100001000000000100001000000000000000000000000010
k = 11908: q = 5001360
Processing 0-interval prime pairs:
	q1 = 5001359[0], q2 = 5001361[1], 1-prime
	q1 = 5001343[1], q2 = 5001377[0], 1-prime
	q1 = 5001341[0], q2 = 5001379[1], 1-prime
	q1 = 5001329[0], q2 = 5001391[1], 1-prime
	q1 = 5001323[0], q2 = 5001397[1], 1-prime
	q1 = 5001319[1], q2 = 5001401[0], 1-prime
	q1 = 5001313[0], q2 = 5001407[1], 1-prime
	q1 = 5001307[1], q2 = 5001413[1], both prime
	q1 = 5001301[1], q2 = 5001419[0], 1-prime
	q1 = 5001299[1], q2 = 5001421[1], both prime
	q1 = 5001289[1], q2 = 5001431[1], both prime
	q1 = 5001287[0], q2 = 5001433[1], 1-prime
	q1 = 5001277[1], q2 = 5001443[1], both prime
	q1 = 5001259[0], q2 = 5001461[1], 1-prime
	q1 = 5001251[1], q2 = 5001469[0], 1-prime
	q1 = 5001239[0], q2 = 5001481[1], 1-prime
	q1 = 5001233[1], q2 = 5001487[1], both prime
	q1 = 5001203[1], q2 = 5001517[0], 1-prime
	q1 = 5001197[1], q2 = 5001523[1], both prime
	q1 = 5001193[1], q2 = 5001527[0], 1-prime
	q1 = 5001181[0], q2 = 5001539[1], 1-prime
	q1 = 5001173[1], q2 = 5001547[1], both prime
	q1 = 5001167[1], q2 = 5001553[0], 1-prime
	q1 = 5001163[1], q2 = 5001557[0], 1-prime
	q1 = 5001161[0], q2 = 5001559[1], 1-prime
New upper-interval, tagging its primes:
	q == 0 (mod 11) bitmap: 000000001000010000000001000000000000001000010000000000000001000000000000001000000001000010000000
k = 11909: q = 5001780
Processing 0-interval prime pairs:
	q1 = 5001779[1], q2 = 5001781[0], 1-prime
	q1 = 5001767[1], q2 = 5001793[0], 1-prime
	q1 = 5001761[1], q2 = 5001799[0], 1-prime
	q1 = 5001751[0], q2 = 5001809[1], 1-prime
	q1 = 5001749[1], q2 = 5001811[0], 1-prime
	q1 = 5001743[1], q2 = 5001817[0], 1-prime
	q1 = 5001739[1], q2 = 5001821[0], 1-prime
	q1 = 5001707[1], q2 = 5001853[0], 1-prime
	q1 = 5001701[1], q2 = 5001859[0], 1-prime
	q1 = 5001691[1], q2 = 5001869[0], 1-prime
	q1 = 5001679[1], q2 = 5001881[0], 1-prime
	q1 = 5001671[1], q2 = 5001889[0], 1-prime
	q1 = 5001653[1], q2 = 5001907[1], both prime
	q1 = 5001649[0], q2 = 5001911[1], 1-prime
	q1 = 5001643[1], q2 = 5001917[0], 1-prime
	q1 = 5001637[0], q2 = 5001923[1], 1-prime
	q1 = 5001629[1], q2 = 5001931[0], 1-prime
	q1 = 5001593[1], q2 = 5001967[1], both prime
	q1 = 5001581[0], q2 = 5001979[1], 1-prime
New upper-interval, tagging its primes:
	q == 0 (mod 11) bitmap: 000100000000001000010000000010000100000000001000000000000000000010000000000000100000000001000000
k = 11910: q = 5002200
Processing 0-interval prime pairs:
	q1 = 5002189[1], q2 = 5002211[1], both prime
	q1 = 5002181[0], q2 = 5002219[1], 1-prime
	q1 = 5002177[0], q2 = 5002223[1], 1-prime
	q1 = 5002171[0], q2 = 5002229[1], 1-prime
	q1 = 5002163[0], q2 = 5002237[1], 1-prime
	q1 = 5002159[0], q2 = 5002241[1], 1-prime
	q1 = 5002157[1], q2 = 5002243[0], 1-prime
	q1 = 5002141[0], q2 = 5002259[1], 1-prime
	q1 = 5002133[1], q2 = 5002267[0], 1-prime
	q1 = 5002127[0], q2 = 5002273[1], 1-prime
	q1 = 5002103[1], q2 = 5002297[0], 1-prime
	q1 = 5002093[1], q2 = 5002307[0], 1-prime
	q1 = 5002087[0], q2 = 5002313[1], 1-prime
	q1 = 5002079[0], q2 = 5002321[1], 1-prime
	q1 = 5002069[0], q2 = 5002331[1], 1-prime
	q1 = 5002057[1], q2 = 5002343[0], 1-prime
	q1 = 5002051[1], q2 = 5002349[0], 1-prime
	q1 = 5002027[0], q2 = 5002373[1], 1-prime
	q1 = 5002021[0], q2 = 5002379[1], 1-prime
	q1 = 5002009[0], q2 = 5002391[1], 1-prime
	q1 = 5002003[1], q2 = 5002397[0], 1-prime
	q1 = 5002001[1], q2 = 5002399[0], 1-prime
New upper-interval, tagging its primes:
	q == 0 (mod 11) bitmap: 000010000100000000000000100000000010000100000000000000100000000001000000000000010000000000000000
k = 11911: q = 5002620
Processing 0-interval prime pairs:
	q1 = 5002603[0], q2 = 5002637[1], 1-prime
	q1 = 5002601[0], q2 = 5002639[1], 1-prime
	q1 = 5002591[0], q2 = 5002649[1], 1-prime
	q1 = 5002589[0], q2 = 5002651[1], 1-prime
	q1 = 5002583[1], q2 = 5002657[0], 1-prime
	q1 = 5002579[1], q2 = 5002661[0], 1-prime
	q1 = 5002561[1], q2 = 5002679[0], 1-prime
	q1 = 5002553[1], q2 = 5002687[0], 1-prime
	q1 = 5002549[0], q2 = 5002691[1], 1-prime
	q1 = 5002541[1], q2 = 5002699[0], 1-prime
	q1 = 5002537[1], q2 = 5002703[0], 1-prime
	q1 = 5002519[1], q2 = 5002721[1], both prime
	q1 = 5002511[0], q2 = 5002729[1], 1-prime
	q1 = 5002507[1], q2 = 5002733[0], 1-prime
	q1 = 5002499[1], q2 = 5002741[1], both prime
	q1 = 5002493[0], q2 = 5002747[1], 1-prime
	q1 = 5002489[1], q2 = 5002751[0], 1-prime
	q1 = 5002469[0], q2 = 5002771[1], 1-prime
	q1 = 5002463[1], q2 = 5002777[0], 1-prime
	q1 = 5002457[1], q2 = 5002783[0], 1-prime
	q1 = 5002439[0], q2 = 5002801[1], 1-prime
	q1 = 5002423[0], q2 = 5002817[1], 1-prime
New upper-interval, tagging its primes:
	q == 0 (mod 11) bitmap: 000000000010000000000000010001000000000000000100000000010000100000000100000000000000100000000000
k = 11912: q = 5003040
Processing 0-interval prime pairs:
	q1 = 5003039[1], q2 = 5003041[0], 1-prime
	q1 = 5003009[0], q2 = 5003071[1], 1-prime
	q1 = 5003003[1], q2 = 5003077[1], both prime
	q1 = 5002999[0], q2 = 5003081[1], 1-prime
	q1 = 5002979[1], q2 = 5003101[1], both prime
	q1 = 5002969[0], q2 = 5003111[1], 1-prime
	q1 = 5002967[0], q2 = 5003113[1], 1-prime
	q1 = 5002957[0], q2 = 5003123[1], 1-prime
	q1 = 5002939[1], q2 = 5003141[0], 1-prime
	q1 = 5002937[0], q2 = 5003143[1], 1-prime
	q1 = 5002927[1], q2 = 5003153[0], 1-prime
	q1 = 5002903[1], q2 = 5003177[0], 1-prime
	q1 = 5002901[1], q2 = 5003179[0], 1-prime
	q1 = 5002889[1], q2 = 5003191[1], both prime
	q1 = 5002883[1], q2 = 5003197[0], 1-prime
	q1 = 5002877[0], q2 = 5003203[1], 1-prime
	q1 = 5002859[1], q2 = 5003221[0], 1-prime
	q1 = 5002853[0], q2 = 5003227[1], 1-prime
	q1 = 5002849[0], q2 = 5003231[1], 1-prime
	q1 = 5002847[1], q2 = 5003233[0], 1-prime
	q1 = 5002843[1], q2 = 5003237[0], 1-prime
	q1 = 5002841[1], q2 = 5003239[1], both prime
	q1 = 5002831[0], q2 = 5003249[1], 1-prime
New upper-interval, tagging its primes:
	q == 0 (mod 11) bitmap: 100001000000000100001000000000000000000000000010010000000000000000000000000100001000000000100001
k = 11913: q = 5003460
Processing 0-interval prime pairs:
	q1 = 5003459[1], q2 = 5003461[0], 1-prime
	q1 = 5003443[0], q2 = 5003477[1], 1-prime
	q1 = 5003437[0], q2 = 5003483[1], 1-prime
	q1 = 5003429[1], q2 = 5003491[0], 1-prime
	q1 = 5003417[0], q2 = 5003503[1], 1-prime
	q1 = 5003413[0], q2 = 5003507[1], 1-prime
	q1 = 5003407[1], q2 = 5003513[1], both prime
	q1 = 5003401[0], q2 = 5003519[1], 1-prime
	q1 = 5003387[1], q2 = 5003533[0], 1-prime
	q1 = 5003381[0], q2 = 5003539[1], 1-prime
	q1 = 5003377[0], q2 = 5003543[1], 1-prime
	q1 = 5003371[1], q2 = 5003549[1], both prime
	q1 = 5003329[1], q2 = 5003591[1], both prime
	q1 = 5003323[0], q2 = 5003597[1], 1-prime
	q1 = 5003309[1], q2 = 5003611[0], 1-prime
	q1 = 5003303[1], q2 = 5003617[0], 1-prime
	q1 = 5003287[0], q2 = 5003633[1], 1-prime
	q1 = 5003267[1], q2 = 5003653[1], both prime
	q1 = 5003263[1], q2 = 5003657[1], both prime
	q1 = 5003261[1], q2 = 5003659[1], both prime
New upper-interval, tagging its primes:
	q == 0 (mod 11) bitmap: 000000000001000000000000001000000001000010000000001000000000000000100010000000000000010000000000
k = 11914: q = 5003880
Processing 0-interval prime pairs:
	q1 = 5003879[0], q2 = 5003881[1], 1-prime
	q1 = 5003867[0], q2 = 5003893[1], 1-prime
	q1 = 5003851[0], q2 = 5003909[1], 1-prime
	q1 = 5003839[1], q2 = 5003921[0], 1-prime
	q1 = 5003837[1], q2 = 5003923[1], both prime
	q1 = 5003827[1], q2 = 5003933[0], 1-prime
	q1 = 5003819[1], q2 = 5003941[0], 1-prime
	q1 = 5003813[1], q2 = 5003947[0], 1-prime
	q1 = 5003809[1], q2 = 5003951[1], both prime
	q1 = 5003801[0], q2 = 5003959[1], 1-prime
	q1 = 5003797[0], q2 = 5003963[1], 1-prime
	q1 = 5003791[0], q2 = 5003969[1], 1-prime
	q1 = 5003779[0], q2 = 5003981[1], 1-prime
	q1 = 5003777[0], q2 = 5003983[1], 1-prime
	q1 = 5003773[1], q2 = 5003987[0], 1-prime
	q1 = 5003771[1], q2 = 5003989[0], 1-prime
	q1 = 5003767[0], q2 = 5003993[1], 1-prime
	q1 = 5003759[1], q2 = 5004001[0], 1-prime
	q1 = 5003753[0], q2 = 5004007[1], 1-prime
	q1 = 5003749[1], q2 = 5004011[0], 1-prime
	q1 = 5003743[1], q2 = 5004017[1], both prime
	q1 = 5003741[0], q2 = 5004019[1], 1-prime
	q1 = 5003737[1], q2 = 5004023[0], 1-prime
	q1 = 5003729[0], q2 = 5004031[1], 1-prime
	q1 = 5003717[1], q2 = 5004043[0], 1-prime
	q1 = 5003711[1], q2 = 5004049[0], 1-prime
	q1 = 5003707[0], q2 = 5004053[1], 1-prime
	q1 = 5003701[1], q2 = 5004059[1], both prime
	q1 = 5003699[1], q2 = 5004061[0], 1-prime
	q1 = 5003693[0], q2 = 5004067[1], 1-prime
	q1 = 5003689[0], q2 = 5004071[1], 1-prime
	q1 = 5003687[0], q2 = 5004073[1], 1-prime
	q1 = 5003671[1], q2 = 5004089[1], both prime
New upper-interval, tagging its primes:
	q == 0 (mod 11) bitmap: 000000000000000010000000000000100000000001000000000000001000010000000001000000000000001000010000
k = 11915: q = 5004300
Processing 0-interval prime pairs:
	q1 = 5004281[1], q2 = 5004319[0], 1-prime
	q1 = 5004277[0], q2 = 5004323[1], 1-prime
	q1 = 5004241[0], q2 = 5004359[1], 1-prime
	q1 = 5004233[0], q2 = 5004367[1], 1-prime
	q1 = 5004227[1], q2 = 5004373[0], 1-prime
	q1 = 5004221[1], q2 = 5004379[0], 1-prime
	q1 = 5004217[1], q2 = 5004383[0], 1-prime
	q1 = 5004199[0], q2 = 5004401[1], 1-prime
	q1 = 5004197[0], q2 = 5004403[1], 1-prime
	q1 = 5004193[1], q2 = 5004407[0], 1-prime
	q1 = 5004163[0], q2 = 5004437[1], 1-prime
	q1 = 5004157[1], q2 = 5004443[0], 1-prime
	q1 = 5004149[1], q2 = 5004451[1], both prime
	q1 = 5004143[1], q2 = 5004457[1], both prime
	q1 = 5004127[1], q2 = 5004473[0], 1-prime
	q1 = 5004121[1], q2 = 5004479[0], 1-prime
	q1 = 5004119[1], q2 = 5004481[0], 1-prime
	q1 = 5004109[0], q2 = 5004491[1], 1-prime

Resulting is-div-by-11 bitmaps, bits run LR corr. to q0-209 ... q0+209;
These contain the same 24-bit chunks as the M = 1 case, just the ordering differs:
q0%11										div-11 bitmap:
6	000000100000000001000000 000000010000000000000000 000100000000001000010000 000010000100000000001000
8	000000010000100000000100 000000000000100000000000 000010000100000000000000 100000000010000100000000
10	010000000000000000000000 000100001000000000100001 000000000010000000000000 010001000000000000000100
1	001000000000000000100010 000000000000010000000000 100001000000000100001000 000000000000000000000010
3	000000001000010000000001 000000000000001000010000 000000000001000000000000 001000000001000010000000
5	000100000000001000010000 000010000100000000001000 000000000000000010000000 000000100000000001000000
7	000010000100000000000000 100000000010000100000000 000000100000000001000000 000000010000000000000000
9	000000000010000000000000 010001000000000000000100 000000010000100000000100 000000000000100000000000
0	100001000000000100001000 000000000000000000000010 010000000000000000000000 000100001000000000100001
2	000000000001000000000000 001000000001000010000000 001000000000000000100010 000000000000010000000000
4	000000000000000010000000 000000100000000001000000 000000001000010000000001 000000000000001000010000
In terms of the above 2*11-24-bit-maplets scheme, these corr. to:
6	7.lo 6.hi 6.lo 5.hi
8	9.lo 8.hi 8.lo 7.hi
10	0.lo 10.hi 10.lo 9.hi
1	2.lo 1.hi 1.lo 0.hi
3	4.lo 3.hi 3.lo 2.hi
5	6.lo 5.hi 5.lo 4.hi
7	8.lo 7.hi 7.lo 6.hi
9	10.lo 9.hi 9.lo 8.hi
0	1.lo 0.hi 0.lo 10.hi
2	3.lo 2.hi 2.lo 1.hi
4	5.lo 4.hi 4.lo 3.hi, and each maplet now appears 2 times in the table.
===============================
D = 420, M = 2:
6	000100000000001000010000 000010000100000000001000 000000000000000010000000 000000100000000001000000
8	000010000100000000000000 100000000010000100000000 000000100000000001000000 000000010000000000000000
10	000000000010000000000000 010001000000000000000100 000000010000100000000100 000000000000100000000000
1	100001000000000100001000 000000000000000000000010 010000000000000000000000 000100001000000000100001
3	000000000001000000000000 001000000001000010000000 001000000000000000100010 000000000000010000000000
5	000000000000000010000000 000000100000000001000000 000000001000010000000001 000000000000001000010000
7	000000100000000001000000 000000010000000000000000 000100000000001000010000 000010000100000000001000
9	000000010000100000000100 000000000000100000000000 000010000100000000000000 100000000010000100000000
0	010000000000000000000000 000100001000000000100001 000000000010000000000000 010001000000000000000100
2	001000000000000000100010 000000000000010000000000 100001000000000100001000 000000000000000000000010
4	000000001000010000000001 000000000000001000010000 000000000001000000000000 001000000001000010000000
In terms of the above 2*11-24-bit-maplets scheme, these corr. to:
6	7.lo 6.hi 6.lo 5.hi
8	9.lo 8.hi 8.lo 7.hi
10	0.lo 10.hi 10.lo 9.hi
1	2.lo 1.hi 1.lo 0.hi
3	4.lo 3.hi 3.lo 2.hi
5	6.lo 5.hi 5.lo 4.hi
7	8.lo 7.hi 7.lo 6.hi
9	10.lo 9.hi 9.lo 8.hi
0	1.lo 0.hi 0.lo 10.hi
2	3.lo 2.hi 2.lo 1.hi
4	5.lo 4.hi 4.lo 3.hi, and each maplet now appears 2 times in the table.
In terms of the above 2*11-24-bit-maplets scheme, these corr. to:
6	6.lo 5.hi 5.lo 4.hi
8	8.lo 7.hi 7.lo 6.hi
10	10.lo 9.hi 9.lo 8.hi
1	1.lo 0.hi 0.lo 10.hi
3	3.lo 2.hi 2.lo 1.hi
5	5.lo 4.hi 4.lo 3.hi
7	7.lo 6.hi 6.lo 5.hi
9	9.lo 8.hi 8.lo 7.hi
0	0.lo 10.hi 10.lo 9.hi
2	2.lo 1.hi 1.lo 0.hi
5	4.lo 3.hi 3.lo 2.hi, which is identical to the M=1 table if we subtract 1 from the left-column q0%11 indices.
===============================
D = 840, M = 1:
4	000100000000001000010000 000010000100000000001000 000000000000000010000000 000000100000000001000000 000000001000010000000001 000000000000001000010000 000000000001000000000000 001000000001000010000000
8	000000000010000000000000 010001000000000000000100 000000010000100000000100 000000000000100000000000 000010000100000000000000 100000000010000100000000 000000100000000001000000 000000010000000000000000
1	000000000001000000000000 001000000001000010000000 001000000000000000100010 000000000000010000000000 100001000000000100001000 000000000000000000000010 010000000000000000000000 000100001000000000100001
5	000000100000000001000000 000000010000000000000000 000100000000001000010000 000010000100000000001000 000000000000000010000000 000000100000000001000000 000000001000010000000001 000000000000001000010000
9	010000000000000000000000 000100001000000000100001 000000000010000000000000 010001000000000000000100 000000010000100000000100 000000000000100000000000 000010000100000000000000 100000000010000100000000
2	000000001000010000000001 000000000000001000010000 000000000001000000000000 001000000001000010000000 001000000000000000100010 000000000000010000000000 100001000000000100001000 000000000000000000000010
6	000010000100000000000000 100000000010000100000000 000000100000000001000000 000000010000000000000000 000100000000001000010000 000010000100000000001000 000000000000000010000000 000000100000000001000000
10	100001000000000100001000 000000000000000000000010 010000000000000000000000 000100001000000000100001 000000000010000000000000 010001000000000000000100 000000010000100000000100 000000000000100000000000
3	000000000000000010000000 000000100000000001000000 000000001000010000000001 000000000000001000010000 000000000001000000000000 001000000001000010000000 001000000000000000100010 000000000000010000000000
7	000000010000100000000100 000000000000100000000000 000010000100000000000000 100000000010000100000000 000000100000000001000000 000000010000000000000000 000100000000001000010000 000010000100000000001000
0	001000000000000000100010 000000000000010000000000 100001000000000100001000 000000000000000000000010 010000000000000000000000 000100001000000000100001 000000000010000000000000 010001000000000000000100
In terms of the above 2*11-24-bit-maplets scheme, these corr. to:
4	6.lo 5.hi 5.lo 4.hi 4.lo 3.hi 3.lo 2.hi
8	10.lo 9.hi 9.lo 8.hi 8.lo 7.hi 7.lo 6.hi
1	3.lo 2.hi 2.lo 1.hi 1.lo 0.hi 0.lo 10.hi
5	7.lo 6.hi 6.lo 5.hi 5.lo 4.hi 4.lo 3.hi
9	0.lo 10.hi 10.lo 9.hi 9.lo 8.hi 8.lo 7.hi
2	4.lo 3.hi 3.lo 2.hi 2.lo 1.hi 1.lo 0.hi
6	8.lo 7.hi 7.lo 6.hi 6.lo 5.hi 5.lo 4.hi
10	1.lo 0.hi 0.lo 10.hi 10.lo 9.hi 9.lo 8.hi
3	5.lo 4.hi 4.lo 3.hi 3.lo 2.hi 2.lo 1.hi
7	9.lo 8.hi 8.lo 7.hi 7.lo 6.hi 6.lo 5.hi
0	2.lo 1.hi 1.lo 0.hi 0.lo 10.hi 10.lo 9.hi
===============================
D = 840, M = 2:
4	000000001000010000000001 000000000000001000010000000000000001000000000000001000000001000010000000001000000000000000100010000000000000010000000000100001000000000100001000000000000000000000000010
8	000010000100000000000000 100000000010000100000000000000100000000001000000000000010000000000000000000100000000001000010000000010000100000000001000000000000000000010000000000000100000000001000000
1	100001000000000100001000 000000000000000000000010010000000000000000000000000100001000000000100001000000000010000000000000010001000000000000000100000000010000100000000100000000000000100000000000
5	000000000000000010000000 000000100000000001000000000000001000010000000001000000000000001000010000000000000001000000000000001000000001000010000000001000000000000000100010000000000000010000000000
9	000000010000100000000100 000000000000100000000000000010000100000000000000100000000010000100000000000000100000000001000000000000010000000000000000000100000000001000010000000010000100000000001000
2	001000000000000000100010 000000000000010000000000100001000000000100001000000000000000000000000010010000000000000000000000000100001000000000100001000000000010000000000000010001000000000000000100
6	000100000000001000010000 000010000100000000001000000000000000000010000000000000100000000001000000000000001000010000000001000000000000001000010000000000000001000000000000001000000001000010000000
10	000000000010000000000000 010001000000000000000100000000010000100000000100000000000000100000000000000010000100000000000000100000000010000100000000000000100000000001000000000000010000000000000000
3	000000000001000000000000 001000000001000010000000001000000000000000100010000000000000010000000000100001000000000100001000000000000000000000000010010000000000000000000000000100001000000000100001
7	000000100000000001000000 000000010000000000000000000100000000001000010000000010000100000000001000000000000000000010000000000000100000000001000000000000001000010000000001000000000000001000010000
0	010000000000000000000000 000100001000000000100001000000000010000000000000010001000000000000000100000000010000100000000100000000000000100000000000000010000100000000000000100000000010000100000000
In terms of the above 2*11-24-bit-maplets scheme, these corr. to:
4	4.lo,...
8	8.lo,...
1	1.lo,...
5	5.lo,...
9	9.lo,...
2	2.lo,...
6	6.lo,...
10	10.lo,...
3	3.lo,...
7	7.lo,...
0	0.lo,...

So for a general D = 2^k.210 lookup scheme - Note that we don't need to consider M > 2 because the above rules apply
per-width-D-interval. Thus for D = 210, defining q0mod := q0%11 and computing q0mod for initial interval on loop entry:
D = 210:
	M odd:	Each new upper interval gets mod-11 map [q0mod.hi,q0mod.lo], q0mod += 1 (mod 11) for next interval
	M even:	Each new upper interval gets mod-11 map [q0mod.lo,(q0mod-1).hi], q0mod += 1 (mod 11) for next interval
D = 420:
	M odd:	Each new upper interval gets mod-11 map [(q0mod+1).lo,q0mod.hi,q0mod.lo,(q0mod-1).hi], q0mod += 2 (mod 11) for next interval
	M even:	Each new upper interval gets mod-11 map [q0mod.lo,(q0mod-1).hi,(q0mod-1).lo,(q0mod-2).hi], q0mod += 2 (mod 11) for next interval
D = 840:
	M odd:	Each new upper interval gets mod-11 map [q0mod+(2,...,-2).(lo,hi)], q0mod += 4 (mod 11) for next interval
	M even:	Each new upper interval gets mod-11 map [q0mod+(0,...,-4).(lo,hi)], q0mod += 4 (mod 11) for next interval
Q: How to efficiently compute the small q0mod-offset (mod 11)?
A: Not cycle-crucial, for each interval start with (uint32)q0mod, get needed offsets using MOD_ADD32,MOD_SUB32 .
===============================
D = 330, M = 1:
Resulting is-div-by-7 bitmaps, bits run LR corr. to q0-D/2 ... q0+D/2;
q0%7							div-7 bitmap[hi40,lo40]:
0	0100000100100000010000000001000000000010 0100000000001000000000100000010010000010
1	0000010000000000100100000000001000000100 1000001000100000010000000000101000000000
2	0000000010000010001000001000100000010000 0000010010000000000100000010000000010001
3	0001001000001000000000010010000000000000 0001000100000010001000001000000000000100
4	0010000000000001000001000100000010001000 0000000000000100100000000001000001001000
5	1000100000000100000010000000000100100000 0000100000010001000001000100000100000000
6	0000000001010000000000100000010001000001 0010000001000000000010010000000000100000
Hexadecimal:
Byte  9    8    7    6    5    4    3    2    1    0
0	0x41,0x20,0x40,0x10,0x02,0x40,0x08,0x02,0x04,0x82
1	0x04,0x00,0x90,0x02,0x04,0x82,0x20,0x40,0x0A,0x00
2	0x00,0x82,0x20,0x88,0x10,0x04,0x80,0x10,0x20,0x11
3	0x12,0x08,0x01,0x20,0x00,0x11,0x02,0x20,0x80,0x04
4	0x20,0x01,0x04,0x40,0x88,0x00,0x04,0x80,0x10,0x48
5	0x88,0x04,0x08,0x01,0x20,0x08,0x11,0x04,0x41,0x00
6	0x00,0x50,0x02,0x04,0x41,0x20,0x40,0x09,0x00,0x20
And reorder the cols to run bytes low-to-high for purpose of const byte-table init:
  0    1    2    3    4    5    6    7    8    9
0x82,0x04,0x02,0x08,0x40,0x02,0x10,0x40,0x20,0x41
0x00,0x0A,0x40,0x20,0x82,0x04,0x02,0x90,0x00,0x04
0x11,0x20,0x10,0x80,0x04,0x10,0x88,0x20,0x82,0x00
0x04,0x80,0x20,0x02,0x11,0x00,0x20,0x01,0x08,0x12
0x48,0x10,0x80,0x04,0x00,0x88,0x40,0x04,0x01,0x20
0x00,0x41,0x04,0x11,0x08,0x20,0x01,0x08,0x04,0x88
0x20,0x00,0x09,0x40,0x20,0x41,0x04,0x02,0x50,0x00
===============================
D = 330, M = 2:
Resulting is-div-by-7 bitmaps, bits run LR corr. to q0-209 ... q0-1;
These contain the same 40-bit chunks as the M = 1 case, just the ordering differs:
q0%7							div-7 bitmap[hi40,lo40]:								40-bit-chunk locations in M=1 map:
0	0100000000001000000000100000010010000010 0000000001010000000000100000010001000001	0.lo,6.hi
1	1000001000100000010000000000101000000000 0100000100100000010000000001000000000010	1.lo,0.hi
2	0000010010000000000100000010000000010001 0000010000000000100100000000001000000100	2.lo,1.hi
3	0001000100000010001000001000000000000100 0000000010000010001000001000100000010000	3.lo,2.hi
4	0000000000000100100000000001000001001000 0001001000001000000000010010000000000000	4.lo,3.hi
5	0000100000010001000001000100000100000000 0010000000000001000001000100000010001000	5.lo,4.hi
6	0010000001000000000010010000000000100000 1000100000000100000010000000000100100000	6.lo,5.hi
===============================
D = 660, M = 1:
q0%7							div-7 bitmap[hi40,lo40]:								40-bit-chunk locations in M=1 map:
0	1000001000100000010000000000101000000000 0100000100100000010000000001000000000010 0100000000001000000000100000010010000010 0000000001010000000000100000010001000001	1.lo,0.hi,0.lo,6.hi
1	0000010010000000000100000010000000010001 0000010000000000100100000000001000000100 1000001000100000010000000000101000000000 0100000100100000010000000001000000000010	2.lo,1.hi,1.lo,0.hi
2	0001000100000010001000001000000000000100 0000000010000010001000001000100000010000 0000010010000000000100000010000000010001 0000010000000000100100000000001000000100	3.lo,2.hi,2.lo,1.hi
3	0000000000000100100000000001000001001000 0001001000001000000000010010000000000000 0001000100000010001000001000000000000100 0000000010000010001000001000100000010000	4.lo,3.hi,3.lo,2.hi
4	0000100000010001000001000100000100000000 0010000000000001000001000100000010001000 0000000000000100100000000001000001001000 0001001000001000000000010010000000000000	5.lo,4.hi,4.lo,3.hi
5	0010000001000000000010010000000000100000 1000100000000100000010000000000100100000 0000100000010001000001000100000100000000 0010000000000001000001000100000010001000	6.lo,5.hi,5.lo,4.hi
6	0100000000001000000000100000010010000010 0000000001010000000000100000010001000001 0010000001000000000010010000000000100000 1000100000000100000010000000000100100000	0.lo,6.hi,6.lo,5.hi

==============================
Compute updated pairing-stats and modmul counts with relocation:
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 1
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 2
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 3
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 4
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 5
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 6
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 7
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 8
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 9
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 10
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 11
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 12
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 13
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 14
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 15
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 16
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 17
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 18
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 19
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 20
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 21
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 22
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 23
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 24
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 25
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 26
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 27
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 28
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 29
./pm1 -bigstep 840 -b1 5000000 -b2 150000000 -m 30
D = 210:
M =  1: #buf =   24, #pairs: 1050404, #single: 5996572 (25.94% paired), #blocks: 649351, #modmul: 8345678
M =  2: #buf =   48, #pairs: 1676289, #single: 4744807 (41.40% paired), #blocks: 649351, #modmul: 7719798
M =  3: #buf =   72, #pairs: 2095632, #single: 3906112 (51.76% paired), #blocks: 649351, #modmul: 7300446
M =  4: #buf =   96, #pairs: 2396766, #single: 3303850 (59.20% paired), #blocks: 649351, #modmul: 6999318
M =  5: #buf =  120, #pairs: 2619183, #single: 2859007 (64.69% paired), #blocks: 649351, #modmul: 6776892
M =  6: #buf =  144, #pairs: 2794492, #single: 2508394 (69.02% paired), #blocks: 649351, #modmul: 6601588
M =  7: #buf =  168, #pairs: 2934282, #single: 2228807 (72.47% paired), #blocks: 649351, #modmul: 6461791
M =  8: #buf =  192, #pairs: 3046995, #single: 2003385 (75.26% paired), #blocks: 649351, #modmul: 6349082
M =  9: #buf =  216, #pairs: 3141492, #single: 1814378 (77.59% paired), #blocks: 649351, #modmul: 6254572
M = 10: #buf =  240, #pairs: 3220158, #single: 1657055 (79.54% paired), #blocks: 649351, #modmul: 6175915
M = 11: #buf =  264, #pairs: 3287227, #single: 1522909 (81.19% paired), #blocks: 649351, #modmul: 6108838
M = 12: #buf =  288, #pairs: 3344901, #single: 1407565 (82.62% paired), #blocks: 649351, #modmul: 6051168
M = 13: #buf =  312, #pairs: 3395732, #single: 1305899 (83.87% paired), #blocks: 649351, #modmul: 6000333
M = 14: #buf =  336, #pairs: 3439696, #single: 1217977 (84.96% paired), #blocks: 649351, #modmul: 5956375
M = 15: #buf =  360, #pairs: 3478800, #single: 1139762 (85.92% paired), #blocks: 649351, #modmul: 5917264
M = 16: #buf =  384, #pairs: 3513274, #single: 1070816 (86.78% paired), #blocks: 649351, #modmul: 5882792
M = 17: #buf =  408, #pairs: 3544181, #single: 1008993 (87.54% paired), #blocks: 649351, #modmul: 5851876
M = 18: #buf =  432, #pairs: 3571988, #single: 953383 (88.23% paired), #blocks: 649351, #modmul: 5824073
M = 19: #buf =  456, #pairs: 3597406, #single: 902537 (88.85% paired), #blocks: 649351, #modmul: 5798645
M = 20: #buf =  480, #pairs: 3620199, #single: 856961 (89.42% paired), #blocks: 649351, #modmul: 5775862
M = 21: #buf =  504, #pairs: 3641017, #single: 815318 (89.93% paired), #blocks: 649351, #modmul: 5755037
M = 22: #buf =  528, #pairs: 3660129, #single: 777099 (90.40% paired), #blocks: 649351, #modmul: 5735930
M = 23: #buf =  552, #pairs: 3677633, #single: 742082 (90.84% paired), #blocks: 649351, #modmul: 5718417
M = 24: #buf =  576, #pairs: 3694006, #single: 709342 (91.24% paired), #blocks: 649351, #modmul: 5702050
M = 25: #buf =  600, #pairs: 3708825, #single: 679694 (91.61% paired), #blocks: 649351, #modmul: 5687221
M = 26: #buf =  624, #pairs: 3722743, #single: 651865 (91.95% paired), #blocks: 649351, #modmul: 5673310
M = 27: #buf =  648, #pairs: 3735649, #single: 626047 (92.27% paired), #blocks: 649351, #modmul: 5660398
M = 28: #buf =  672, #pairs: 3747713, #single: 601920 (92.57% paired), #blocks: 649351, #modmul: 5648335
M = 29: #buf =  696, #pairs: 3758955, #single: 579434 (92.84% paired), #blocks: 649351, #modmul: 5637091
M = 30: #buf =  720, #pairs: 3769415, #single: 558524 (93.10% paired), #blocks: 649351, #modmul: 5626641
D = 330:
M =  1: #buf =   40, #pairs: 1052601, #single: 5992190 (26.00% paired), #blocks: 389611, #modmul: 7824013
M =  2: #buf =   80, #pairs: 1680819, #single: 4735757 (41.52% paired), #blocks: 389611, #modmul: 7195798
M =  3: #buf =  120, #pairs: 2097000, #single: 3903379 (51.79% paired), #blocks: 389611, #modmul: 6779601
M =  4: #buf =  160, #pairs: 2394404, #single: 3308572 (59.14% paired), #blocks: 389611, #modmul: 6482198
M =  5: #buf =  200, #pairs: 2618188, #single: 2860993 (64.67% paired), #blocks: 389611, #modmul: 6258403
M =  6: #buf =  240, #pairs: 2792820, #single: 2511735 (68.98% paired), #blocks: 389611, #modmul: 6083777
M =  7: #buf =  280, #pairs: 2931373, #single: 2234618 (72.40% paired), #blocks: 389611, #modmul: 5945213
M =  8: #buf =  320, #pairs: 3044706, #single: 2007957 (75.20% paired), #blocks: 389611, #modmul: 5831885
M =  9: #buf =  360, #pairs: 3139368, #single: 1818625 (77.54% paired), #blocks: 389611, #modmul: 5737215
M = 10: #buf =  400, #pairs: 3218197, #single: 1660969 (79.49% paired), #blocks: 389611, #modmul: 5658388
M = 11: #buf =  440, #pairs: 3285726, #single: 1525901 (81.16% paired), #blocks: 389611, #modmul: 5590849
M = 12: #buf =  480, #pairs: 3344554, #single: 1408248 (82.61% paired), #blocks: 389611, #modmul: 5532024
M = 13: #buf =  520, #pairs: 3394725, #single: 1307899 (83.85% paired), #blocks: 389611, #modmul: 5481846
M = 14: #buf =  560, #pairs: 3439115, #single: 1219121 (84.94% paired), #blocks: 389611, #modmul: 5437458
M = 15: #buf =  600, #pairs: 3477879, #single: 1141590 (85.90% paired), #blocks: 389611, #modmul: 5398691
M = 16: #buf =  640, #pairs: 3512626, #single: 1072096 (86.76% paired), #blocks: 389611, #modmul: 5363944
M = 17: #buf =  680, #pairs: 3543481, #single: 1010379 (87.52% paired), #blocks: 389611, #modmul: 5333082
M = 18: #buf =  720, #pairs: 3571458, #single: 954432 (88.21% paired), #blocks: 389611, #modmul: 5305112
M = 19: #buf =  760, #pairs: 3597017, #single: 903302 (88.84% paired), #blocks: 389611, #modmul: 5279541
M = 20: #buf =  800, #pairs: 3619557, #single: 858233 (89.40% paired), #blocks: 389611, #modmul: 5257012
M = 21: #buf =  840, #pairs: 3640500, #single: 816339 (89.92% paired), #blocks: 389611, #modmul: 5236061
M = 22: #buf =  880, #pairs: 3659502, #single: 778331 (90.39% paired), #blocks: 389611, #modmul: 5217055
M = 23: #buf =  920, #pairs: 3676967, #single: 743390 (90.82% paired), #blocks: 389611, #modmul: 5199579
M = 24: #buf =  960, #pairs: 3693002, #single: 711328 (91.22% paired), #blocks: 389611, #modmul: 5183552
M = 25: #buf = 1000, #pairs: 3708178, #single: 680972 (91.59% paired), #blocks: 389611, #modmul: 5168372
M = 26: #buf = 1040, #pairs: 3721808, #single: 653716 (91.93% paired), #blocks: 389611, #modmul: 5154746
M = 27: #buf = 1080, #pairs: 3734724, #single: 627879 (92.25% paired), #blocks: 389611, #modmul: 5141825
M = 28: #buf = 1120, #pairs: 3746842, #single: 603650 (92.55% paired), #blocks: 389611, #modmul: 5129714
M = 29: #buf = 1160, #pairs: 3757990, #single: 581348 (92.82% paired), #blocks: 389611, #modmul: 5118560
M = 30: #buf = 1200, #pairs: 3768553, #single: 560226 (93.08% paired), #blocks: 389611, #modmul: 5108001
D = 420:
M =  1: #buf =   48, #pairs: 1048857, #single: 5999653 (25.91% paired), #blocks: 324675, #modmul: 7697860
M =  2: #buf =   96, #pairs: 1680851, #single: 4735674 (41.52% paired), #blocks: 324675, #modmul: 7065875
M =  3: #buf =  144, #pairs: 2098525, #single: 3900305 (51.83% paired), #blocks: 324675, #modmul: 6648180
M =  4: #buf =  192, #pairs: 2396170, #single: 3305025 (59.18% paired), #blocks: 324675, #modmul: 6350545
M =  5: #buf =  240, #pairs: 2620240, #single: 2856861 (64.72% paired), #blocks: 324675, #modmul: 6126451
M =  6: #buf =  288, #pairs: 2793976, #single: 2509399 (69.01% paired), #blocks: 324675, #modmul: 5952725
M =  7: #buf =  336, #pairs: 2934186, #single: 2228966 (72.47% paired), #blocks: 324675, #modmul: 5812502
M =  8: #buf =  384, #pairs: 3047068, #single: 2003215 (75.26% paired), #blocks: 324675, #modmul: 5699633
M =  9: #buf =  432, #pairs: 3140942, #single: 1815448 (77.58% paired), #blocks: 324675, #modmul: 5605740
M = 10: #buf =  480, #pairs: 3220242, #single: 1656863 (79.54% paired), #blocks: 324675, #modmul: 5526455
M = 11: #buf =  528, #pairs: 3287149, #single: 1523030 (81.19% paired), #blocks: 324675, #modmul: 5459529
M = 12: #buf =  576, #pairs: 3344882, #single: 1407573 (82.62% paired), #blocks: 324675, #modmul: 5401805
M = 13: #buf =  624, #pairs: 3395298, #single: 1306724 (83.86% paired), #blocks: 324675, #modmul: 5351372
M = 14: #buf =  672, #pairs: 3439454, #single: 1218425 (84.95% paired), #blocks: 324675, #modmul: 5307229
M = 15: #buf =  720, #pairs: 3478650, #single: 1140017 (85.92% paired), #blocks: 324675, #modmul: 5268017
M = 16: #buf =  768, #pairs: 3513203, #single: 1070931 (86.77% paired), #blocks: 324675, #modmul: 5233484
M = 17: #buf =  816, #pairs: 3544212, #single: 1008896 (87.54% paired), #blocks: 324675, #modmul: 5202458
M = 18: #buf =  864, #pairs: 3572126, #single: 953077 (88.23% paired), #blocks: 324675, #modmul: 5174553
M = 19: #buf =  912, #pairs: 3597305, #single: 902703 (88.85% paired), #blocks: 324675, #modmul: 5149358
M = 20: #buf =  960, #pairs: 3620343, #single: 856634 (89.42% paired), #blocks: 324675, #modmul: 5126327
M = 21: #buf = 1008, #pairs: 3640943, #single: 815415 (89.93% paired), #blocks: 324675, #modmul: 5105708
M = 22: #buf = 1056, #pairs: 3660049, #single: 777218 (90.40% paired), #blocks: 324675, #modmul: 5086617
M = 23: #buf = 1104, #pairs: 3677684, #single: 741932 (90.84% paired), #blocks: 324675, #modmul: 5068966
M = 24: #buf = 1152, #pairs: 3693631, #single: 710049 (91.23% paired), #blocks: 324675, #modmul: 5053030
M = 25: #buf = 1200, #pairs: 3708511, #single: 680272 (91.60% paired), #blocks: 324675, #modmul: 5038133
M = 26: #buf = 1248, #pairs: 3722480, #single: 652348 (91.94% paired), #blocks: 324675, #modmul: 5024178
M = 27: #buf = 1296, #pairs: 3735269, #single: 626757 (92.26% paired), #blocks: 324675, #modmul: 5011376
M = 28: #buf = 1344, #pairs: 3747270, #single: 602774 (92.56% paired), #blocks: 324675, #modmul: 4999394
M = 30: #buf = 1440, #pairs: 3768756, #single: 559801 (93.09% paired), #blocks: 324675, #modmul: 4977907
D = 660:
M =  1: #buf =   80, #pairs: 1053344, #single: 5990678 (26.02% paired), #blocks: 194805, #modmul: 7433632
M =  2: #buf =  160, #pairs: 1680821, #single: 4735726 (41.52% paired), #blocks: 194805, #modmul: 6806157
M =  3: #buf =  240, #pairs: 2099371, #single: 3898594 (51.85% paired), #blocks: 194805, #modmul: 6387575
M =  4: #buf =  320, #pairs: 2396509, #single: 3304327 (59.19% paired), #blocks: 194805, #modmul: 6090446
M =  5: #buf =  400, #pairs: 2619074, #single: 2859172 (64.69% paired), #blocks: 194805, #modmul: 5867856
M =  6: #buf =  480, #pairs: 2793230, #single: 2510871 (68.99% paired), #blocks: 194805, #modmul: 5693711
M =  7: #buf =  560, #pairs: 2932510, #single: 2232285 (72.43% paired), #blocks: 194805, #modmul: 5554405
M =  8: #buf =  640, #pairs: 3045866, #single: 2005595 (75.23% paired), #blocks: 194805, #modmul: 5441071
M =  9: #buf =  720, #pairs: 3139318, #single: 1818664 (77.54% paired), #blocks: 194805, #modmul: 5347592
M = 10: #buf =  800, #pairs: 3218411, #single: 1660490 (79.49% paired), #blocks: 194805, #modmul: 5268511
M = 11: #buf =  880, #pairs: 3285618, #single: 1526046 (81.15% paired), #blocks: 194805, #modmul: 5201274
M = 12: #buf =  960, #pairs: 3343911, #single: 1409476 (82.59% paired), #blocks: 194805, #modmul: 5142997
M = 13: #buf = 1040, #pairs: 3394233, #single: 1308807 (83.84% paired), #blocks: 194805, #modmul: 5092650
M = 14: #buf = 1120, #pairs: 3438621, #single: 1220050 (84.93% paired), #blocks: 194805, #modmul: 5048281
M = 15: #buf = 1200, #pairs: 3477894, #single: 1141478 (85.90% paired), #blocks: 194805, #modmul: 5008982
M = 16: #buf = 1280, #pairs: 3512597, #single: 1072088 (86.76% paired), #blocks: 194805, #modmul: 4974295
M = 17: #buf = 1360, #pairs: 3543649, #single: 1009958 (87.53% paired), #blocks: 194805, #modmul: 4943217
M = 18: #buf = 1440, #pairs: 3571407, #single: 954461 (88.21% paired), #blocks: 194805, #modmul: 4915478
M = 19: #buf = 1520, #pairs: 3597112, #single: 903020 (88.85% paired), #blocks: 194805, #modmul: 4889742
M = 20: #buf = 1600, #pairs: 3619965, #single: 857326 (89.41% paired), #blocks: 194805, #modmul: 4866901
M = 21: #buf = 1680, #pairs: 3640886, #single: 815459 (89.93% paired), #blocks: 194805, #modmul: 4845955
M = 22: #buf = 1760, #pairs: 3659932, #single: 777386 (90.40% paired), #blocks: 194805, #modmul: 4826928
M = 23: #buf = 1840, #pairs: 3677395, #single: 742437 (90.83% paired), #blocks: 194805, #modmul: 4809442
M = 24: #buf = 1920, #pairs: 3693700, #single: 709847 (91.23% paired), #blocks: 194805, #modmul: 4793157
M = 25: #buf = 2000, #pairs: 3708633, #single: 679959 (91.60% paired), #blocks: 194805, #modmul: 4778202
M = 26: #buf = 2080, #pairs: 3722370, #single: 652495 (91.94% paired), #blocks: 194805, #modmul: 4764475
M = 27: #buf = 2160, #pairs: 3735184, #single: 626843 (92.26% paired), #blocks: 194805, #modmul: 4751637
M = 28: #buf = 2240, #pairs: 3746976, #single: 603277 (92.55% paired), #blocks: 194805, #modmul: 4739863
M = 29: #buf = 2320, #pairs: 3757994, #single: 581216 (92.82% paired), #blocks: 194805, #modmul: 4728820
M = 30: #buf = 2400, #pairs: 3768539, #single: 560153 (93.08% paired), #blocks: 194805, #moD = 840:
D = 840:
M =  1: #buf =   96, #pairs: 1052490, #single: 5992411 (26.00% paired), #blocks: 162338, #modmul: 7369577
M =  2: #buf =  192, #pairs: 1681887, #single: 4733629 (41.54% paired), #blocks: 162338, #modmul: 6740192
M =  3: #buf =  288, #pairs: 2098246, #single: 3900865 (51.83% paired), #blocks: 162338, #modmul: 6323787
M =  4: #buf =  384, #pairs: 2396285, #single: 3304807 (59.19% paired), #blocks: 162338, #modmul: 6025768
M =  5: #buf =  480, #pairs: 2619733, #single: 2857875 (64.71% paired), #blocks: 162338, #modmul: 5802284
M =  6: #buf =  576, #pairs: 2793891, #single: 2509583 (69.01% paired), #blocks: 162338, #modmul: 5628150
M =  7: #buf =  672, #pairs: 2933114, #single: 2231108 (72.45% paired), #blocks: 162338, #modmul: 5488898
M =  8: #buf =  768, #pairs: 3046833, #single: 2003697 (75.25% paired), #blocks: 162338, #modmul: 5375206
M =  9: #buf =  864, #pairs: 3141328, #single: 1814678 (77.59% paired), #blocks: 162338, #modmul: 5280682
M = 10: #buf =  960, #pairs: 3220401, #single: 1656563 (79.54% paired), #blocks: 162338, #modmul: 5201640
M = 11: #buf = 1056, #pairs: 3287512, #single: 1522313 (81.20% paired), #blocks: 162338, #modmul: 5134501
M = 12: #buf = 1152, #pairs: 3345101, #single: 1407160 (82.62% paired), #blocks: 162338, #modmul: 5076937
M = 13: #buf = 1248, #pairs: 3395531, #single: 1306265 (83.87% paired), #blocks: 162338, #modmul: 5026472
M = 14: #buf = 1344, #pairs: 3439625, #single: 1218103 (84.96% paired), #blocks: 162338, #modmul: 4982404
M = 15: #buf = 1440, #pairs: 3478410, #single: 1140490 (85.92% paired), #blocks: 162338, #modmul: 4943576
M = 16: #buf = 1536, #pairs: 3513379, #single: 1070581 (86.78% paired), #blocks: 162338, #modmul: 4908636
M = 17: #buf = 1632, #pairs: 3544325, #single: 1008666 (87.54% paired), #blocks: 162338, #modmul: 4877667
M = 18: #buf = 1728, #pairs: 3572154, #single: 953028 (88.23% paired), #blocks: 162338, #modmul: 4849858
M = 19: #buf = 1824, #pairs: 3597272, #single: 902759 (88.85% paired), #blocks: 162338, #modmul: 4824707
M = 20: #buf = 1920, #pairs: 3620144, #single: 857040 (89.42% paired), #blocks: 162338, #modmul: 4801860
M = 21: #buf = 2016, #pairs: 3641028, #single: 815248 (89.93% paired), #blocks: 162338, #modmul: 4780952
M = 22: #buf = 2112, #pairs: 3660158, #single: 777012 (90.40% paired), #blocks: 162338, #modmul: 4761846
M = 23: #buf = 2208, #pairs: 3677762, #single: 741773 (90.84% paired), #blocks: 162338, #modmul: 4744211
M = 24: #buf = 2304, #pairs: 3693697, #single: 709926 (91.23% paired), #blocks: 162338, #modmul: 4728299
M = 25: #buf = 2400, #pairs: 3708643, #single: 680003 (91.60% paired), #blocks: 162338, #modmul: 4713322

./pm1 -bigstep 210 -b1 1000000 -b2 30000000 -m  1
./pm1 -bigstep 330 -b1 1000000 -b2 30000000 -m  1
./pm1 -bigstep 420 -b1 1000000 -b2 30000000 -m  1
./pm1 -bigstep 210 -b1 1000000 -b2 30000000 -m  3
./pm1 -bigstep 330 -b1 1000000 -b2 30000000 -m  2
./pm1 -bigstep 210 -b1 1000000 -b2 30000000 -m  4
./pm1 -bigstep 210 -b1 1000000 -b2 30000000 -m  5
./pm1 -bigstep 210 -b1 1000000 -b2 30000000 -m  6
./pm1 -bigstep 330 -b1 1000000 -b2 30000000 -m  4
./pm1 -bigstep 210 -b1 1000000 -b2 30000000 -m  7
./pm1 -bigstep 210 -b1 1000000 -b2 30000000 -m  8
./pm1 -bigstep 330 -b1 1000000 -b2 30000000 -m  5
./pm1 -bigstep 210 -b1 1000000 -b2 30000000 -m  9
./pm1 -bigstep 330 -b1 1000000 -b2 30000000 -m  6
./pm1 -bigstep 330 -b1 1000000 -b2 30000000 -m  7
./pm1 -bigstep 330 -b1 1000000 -b2 30000000 -m  8
./pm1 -bigstep 420 -b1 1000000 -b2 30000000 -m  7
./pm1 -bigstep 330 -b1 1000000 -b2 30000000 -m  9
./pm1 -bigstep 420 -b1 1000000 -b2 30000000 -m  8
./pm1 -bigstep 330 -b1 1000000 -b2 30000000 -m 10
./pm1 -bigstep 420 -b1 1000000 -b2 30000000 -m  9
./pm1 -bigstep 330 -b1 1000000 -b2 30000000 -m 11
./pm1 -bigstep 420 -b1 1000000 -b2 30000000 -m 10
./pm1 -bigstep 330 -b1 1000000 -b2 30000000 -m 13
./pm1 -bigstep 420 -b1 1000000 -b2 30000000 -m 11
./pm1 -bigstep 330 -b1 1000000 -b2 30000000 -m 14
./pm1 -bigstep 420 -b1 1000000 -b2 30000000 -m 12
./pm1 -bigstep 330 -b1 1000000 -b2 30000000 -m 15
./pm1 -bigstep 420 -b1 1000000 -b2 30000000 -m 13
./pm1 -bigstep 420 -b1 1000000 -b2 30000000 -m 14
./pm1 -bigstep 420 -b1 1000000 -b2 30000000 -m 15
./pm1 -bigstep 420 -b1 1000000 -b2 30000000 -m 16
./pm1 -bigstep 420 -b1 1000000 -b2 30000000 -m 17
./pm1 -bigstep 420 -b1 1000000 -b2 30000000 -m 18
./pm1 -bigstep 420 -b1 1000000 -b2 30000000 -m 19
./pm1 -bigstep 420 -b1 1000000 -b2 30000000 -m 20
./pm1 -bigstep 420 -b1 1000000 -b2 30000000 -m 21
./pm1 -bigstep 660 -b1 1000000 -b2 30000000 -m 13
./pm1 -bigstep 420 -b1 1000000 -b2 30000000 -m 22
./pm1 -bigstep 420 -b1 1000000 -b2 30000000 -m 23
./pm1 -bigstep 660 -b1 1000000 -b2 30000000 -m 14
./pm1 -bigstep 660 -b1 1000000 -b2 30000000 -m 15
./pm1 -bigstep 660 -b1 1000000 -b2 30000000 -m 16
./pm1 -bigstep 660 -b1 1000000 -b2 30000000 -m 17
./pm1 -bigstep 660 -b1 1000000 -b2 30000000 -m 18
./pm1 -bigstep 660 -b1 1000000 -b2 30000000 -m 19
./pm1 -bigstep 660 -b1 1000000 -b2 30000000 -m 20
./pm1 -bigstep 660 -b1 1000000 -b2 30000000 -m 21
./pm1 -bigstep 660 -b1 1000000 -b2 30000000 -m 22
./pm1 -bigstep 840 -b1 1000000 -b2 30000000 -m 19
./pm1 -bigstep 660 -b1 1000000 -b2 30000000 -m 23
./pm1 -bigstep 660 -b1 1000000 -b2 30000000 -m 24
./pm1 -bigstep 660 -b1 1000000 -b2 30000000 -m 25
./pm1 -bigstep 660 -b1 1000000 -b2 30000000 -m 26
./pm1 -bigstep 840 -b1 1000000 -b2 30000000 -m 22
./pm1 -bigstep 660 -b1 1000000 -b2 30000000 -m 27
./pm1 -bigstep 840 -b1 1000000 -b2 30000000 -m 23
./pm1 -bigstep 660 -b1 1000000 -b2 30000000 -m 28
./pm1 -bigstep 840 -b1 1000000 -b2 30000000 -m 24
./pm1 -bigstep 840 -b1 1000000 -b2 30000000 -m 25

===================================
Sep 2021: More thoughts re. generalized small-prime relocation:

Current: Given b1,b2 and bigstep D with p0 = smallest prime not dividing D (e.g. D = 210 => p0 = 11; D = 330 => p0 = 7),
primes in [b1,b2/p0] get remapped to [b1,b2/p0]*p0 = [b1*p0,b2].

Alternatively, could "on-demand relocation" primes in lower range of [b1,b2] to upper via any small-odd-multiplier which yields a product < b2. Said remappings would be used to fill in gaps in prime-pairing. Would require us to either first do all the prime-pairing mapping for the entire stage 2 interval before using the resulting bitmap to compute the stage 2 result, or process the upper part of the bitmap using such on-demand relocation, somehow tag the relocated primes, then go back and do the lower part of the s2 interval, using the primes in same which were not relocated.

===================================
Jan 2022:
p-1 stage 2:
o Currently implement bigstep/littlestep prime-pairing via accumulative-upmuls P *= (a^2 - b^2), using identity
  (a^2 - b^2) = (a+b).(a-b), where a = pow (s1 residue) raised to center of current s2 bigstep, b = pow raised
  to one of the bigstep-coprimes. a^2 needs upmul each bigstep loop-pass, the precomputed b^2-powers remain fixed.
o Can we combine 2 such quadratic-muls for different coprimes b and c?
  (a^2 - b^2).(a^2 - c^2) = (a+b).(a-b).(a+c).(a-c) = (a+b).(a-c).(a-b).(a+c)
Now, letting a* = a^2 - b.c and d := a.(b-c), we have
  (a+b).(a-c) = a^2 + a.(b-c) - b.c = a* + d
  (a-b).(a+c) = a^2 - a.(b-c) - b.c = a* - d,
and the product of the above 2 quadratic sub-terms = (a*+d).(a*-d) = a*^2 - d^2. Can this save us any work?
A: It seems not, since he per-loop upmul of a*^2 now needs 1 more FFT-mul than before (a^2 same upmul cost,
but now must subtract b.c from result and do a further FFT-autosquare), and - more importantly, since this applies
to each bigstep-coprime, also need to update-mul the a.(b-c) terms.

Revisit s2 loop-multiplier up-mul: pow1 = s1 residue, D = bigstep:

Have: pow1^((k*D)^2)	, exp1 = D^2*(k^2)
Want: pow1^(((k+1)*D)^2), exp2 = D^2*((k+1)^2) = D^2*(k^2 + (2*k + 1)) = exp1 + D^2*(2*k + 1),
	thus need modmul by mult = pow1^(D^2*(2*k + 1))
If we precompute the following multipliers prior to entering the Stage 2 loop:
	mult1 = pow1^(D^2*(2*k0 + 1))
	mult2 = pow1^(2*D^2)
then after the first (k = k0) pass thru the loop, we want to update mult1 to increment k = k0 to k = k0+1,
which means mult1 *= mult2 (mod n).

01/24/22: p-1 thought: Let
- s1 = stage 1 powering residue
- q0 = center of current 0-window
- D = bigstep
- c[i] = (i)th of the set of positive ints < D/2 and coprime to D.
Say we have multiple (possibly many) D-windows on either side of 0-window, but only precomputed powers of s1 raised to the smaller set of D-coprimes ... can we compute (this is symbolic, in terms of pwoers of s1)
	(q0 + D + c[i])*(q0 - D - c[i])
efficiently? For simply (q0 + c[i])*(q0 - c[i]) we precompute the needed square-powers of s1 and fwd-FFTs of same, then - again symbolically - compute 	(q0 + c[i])*(q0 - c[i]) = (q0^2 - c[i]^2) via invFFT(fwdFFT(q0) - fwdFFT(c^2[i])) .
Now, (A+B+C)*(A-B-C) = [A+(B+C)]*[A-(B+C)] = A^2 - (B+C)^2, so there's the rub: we need(B+C)^2 = B^2 + 2.B.C + C^2, i.e. (in terms of s1 powers)
	(q0 + D + c[i])*(q0 - D - c[i]) = [q0 + (D + c[i])]*[q0 - (D + c[i])] = q0^2 - (D + c[i])^2, now also need D^2 and 2.D.c[i] for each increment in window multiplicity M, which costs even more storage than the current precomputed powers of the coprimes < M*D.

