<HTML>
<HEAD>
<title>Mlucas README</title>
<LINK rel="shortcut icon" href="favicon.ico">
<meta Name="description"		Content="">
<meta Name="keywords"			Content="Ernst Mayer Mlucas Great Internet Mersenne Prime Search GIMPS Lucas Lehmer primality testing factoring FFT radix sse2 avx gcc inline assembler">
<meta Http-equiv="Content-Type"	Content="text/html; charset=iso-8859-1">
<meta Http-equiv="Content-Style-Type"	Content="text/css">
<meta Name="author"				Content="Ernst W. Mayer">
<meta Name="copyright"			Content="Copyright (C) 2015 Ernst W. Mayer. Permission is granted to copy, distribute and/or modify this documentunder the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.A copy of the license is included in the section entitled 'GNU Free Documentation License'.">
<meta Name="distribution"		Content="global">
<meta Name="robots"		Content="index, follow">
<meta Name="rating"		Content="Safe For Kids">
</HEAD>

<BODY>

<HR SIZE=2>
<a href="http://hogranch.com/mayer/home.html">
  <svg width="105" height="20">
    <image id="up1" width="20" height="20" x="0" y="0"
	   xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUBAMAAAB/pwA+AAAABGdBTUEAALGPC/xhBQAAACBjSFJN
AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAElBMVEXAwMAAAAAAAP+AgIAA
z//AwMBJynhnAAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAHdElNRQffBx4EJRo/wnmnAAAA
T0lEQVQI14XNwQ2AMAxDUVcsEHeDWizADt1/JopkV3Aip6+ntAGAhj29Uk1jo1RBhReaG7sGGX49
+838+2T40vccWbk3Z5lPJ7jKeZDe9dxvUAmU+fCuegAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNS0w
Ny0yOVQxNDoxNzo0NSswODowMB+r+7YAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTUtMDYtMTJUMDQ6
Mjk6MjcrMDg6MDD7gRwBAAAAAElFTkSuQmCC" />
    <text x='23' y='15' style="fill: #0000FF;">Ernst Home</text>
  </svg>
</a>

<H2 ALIGN=center>
  <svg width="16" height="16">
    <image id="image0" width="16" height="16" x="0" y="0"
	   xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJN
AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABrVBMVEXAwMAA3S8E6Cci+S4l
/SYK/C4D8zcA1S8AzC4p9jvd/92w/6tq/2AX/zcI8DkBzS8BricApCMd9i+u/6nH/8J0/2sW/0UF
3DMBvisBoyQBhBwAiB8A6Cxi/1iI/37L/8b///+Y/5Ma80oCxi0BrCcBlCABeR0BWhUD9y4p/zY2
/z6B/3k//1gIyzIBrygBmSIBghwBaRoBThIAUxIB8jYN/0IR+EQd+UwZ50YIxTABrCYBmCEBbxsB
WBQBQA4AOQsA1TAB1C8BzC4BwigBtCkBpCUBghsBXBYBRxABMQoANQkAuCoBtSkBpSUBiyEBex4B
axoBWhYBSBABNAoBLAkAMQgAoiMBlSIBkSEBiSABfhsBcRoBZBgBVRQBRRABNAsBLQ0BJgwAtigB
cxwBchsBbBsBYxgBWBUBSxEBPg4BMA4BLAgBJwwBIAoAeh0BURIBPg0BLg4BKg0BJQsBIQoAYxYB
Lw0BKgoBIwsBHgnBwcEzMzMATBAALw0ALgxsbGzExMSlpaWIiIhPT0+vr6+qqqqSkpJ6enpiYmJL
S0tISEhcXFxxcXGGhoabm5ux5ja/AAAAAXRSTlMAQObYZgAAAAFiS0dEILNrPYAAAAAHdElNRQff
Bx4EIwJ69EZ3AAAA2ElEQVQY02NgAANGIGBAAEYmZhZWNnYOOJ+Ti5uHl49fQBDKFxIW4RYVE5eQ
lJIGC8jIyskrKCopq6iqqYMVaGhqaSvq6OrpGxgaGYMETEzNzC0sraylbGzt7EECDo5Ozi6uqm42
7h6eXiABbx89X2s//4DAoOCQUJAhYeERkVHRMbFx8QmJYFuSklNS09IzMrOyc3IhDsnLN/IoiC8s
Ki6BObU0qyyhPKeiEsavqqquCa2tq66ubwBzG5vqm6uBoLm+qbGqiqGlpbWtvaOzurqru6e3r6UF
AB06NPiCOXZ9AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTA3LTI5VDE0OjE3OjQ1KzA4OjAwH6v7
tgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNS0wNi0xMlQwNDoyOToyNyswODowMPuBHAEAAAAASUVO
RK5CYII=" />
  </svg>
Welcome to the the <A href="http://www.mersenne.org/prime.htm">Great Internet Mersenne Prime Search!</A> (The not-PC-only version ;)
</H2>
<BR>
<P>
This ftp site contains <a href="http://hogranch.com/mayer/home.html">Ernst Mayer's</a> C source code for performing Lucas-Lehmer tests and sieve-based trial-factoring of prime-exponent Mersenne numbers. In short, everything you need to search for <A href="http://www.utm.edu/research/primes/mersenne.shtml">Mersenne primes</A> on your Intel, AMD or non-x86-CPU-based computer!
<BR>
<HR SIZE=2>

<H2>Quick Find Guide:</H2>

<ul>
<li> <A href="README.html#news       ">Recent News</A>
<li> <A href="README.html#oldrel     ">Descriptions of previous code releases</A>
<li> <A href="README.html#general    ">General Questions</A>
<li> <A href="README.html#download   ">Download and Build the Source Code</A>
<li> <A href="README.html#selftest   ">Performance-tune for your machine</A>
<li> <A href="README.html#reserve    ">Get exponents from PrimeNet</A>
<li> <A href="README.html#lltest     ">Lucas-Lehmer test</A>
<li> <A href="README.html#checkin    ">Report results</A>
<li> <A href="README.html#minesbigger">Tracking your contribution</A>
<li> <A href="README.html#faq        ">Just the FAQs, please (Frequently Asked Questions)</A>
<li> <A href="README.html#fdl        ">GNU Free Documentation License</A>
</ul>

<BR>
<H2><A NAME="news"></A>Recent News:</H2>

<HR SIZE=2>

<svg width="28" height="11">
  <image id="image0" width="28" height="11" x="0" y="0"
	 xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAALAgMAAAARsAUkAAAABGdBTUEAALGPC/xhBQAAACBjSFJN
AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACVBMVEX/////1gAAAACcIIho
AAAAAXRSTlMAQObYZgAAAAFiS0dEAmYLfGQAAAAHdElNRQffBx4EJQoidWnDAAAATklEQVQI12Ng
gAJWxgDGAFEGBjbHqaETJEMY2CbOWjk1MoWBLXVm6DQQHTlrIph2mxmQlgKkHWeGZi4JYWB1iFoZ
GpICNEE0lIEhBGYcAGF3E6zG8NL/AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTA3LTI5VDE0OjE3
OjQ1KzA4OjAwH6v7tgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNS0wNi0xMlQwNDoyOToyNyswODow
MPuBHAEAAAAASUVORK5CYII=" />
</svg><svg width="16" height="16">
  <image id="image0" width="16" height="16" x="0" y="0"
	 xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJN
AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABrVBMVEXAwMAA3S8E6Cci+S4l
/SYK/C4D8zcA1S8AzC4p9jvd/92w/6tq/2AX/zcI8DkBzS8BricApCMd9i+u/6nH/8J0/2sW/0UF
3DMBvisBoyQBhBwAiB8A6Cxi/1iI/37L/8b///+Y/5Ma80oCxi0BrCcBlCABeR0BWhUD9y4p/zY2
/z6B/3k//1gIyzIBrygBmSIBghwBaRoBThIAUxIB8jYN/0IR+EQd+UwZ50YIxTABrCYBmCEBbxsB
WBQBQA4AOQsA1TAB1C8BzC4BwigBtCkBpCUBghsBXBYBRxABMQoANQkAuCoBtSkBpSUBiyEBex4B
axoBWhYBSBABNAoBLAkAMQgAoiMBlSIBkSEBiSABfhsBcRoBZBgBVRQBRRABNAsBLQ0BJgwAtigB
cxwBchsBbBsBYxgBWBUBSxEBPg4BMA4BLAgBJwwBIAoAeh0BURIBPg0BLg4BKg0BJQsBIQoAYxYB
Lw0BKgoBIwsBHgnBwcEzMzMATBAALw0ALgxsbGzExMSlpaWIiIhPT0+vr6+qqqqSkpJ6enpiYmJL
S0tISEhcXFxxcXGGhoabm5ux5ja/AAAAAXRSTlMAQObYZgAAAAFiS0dEILNrPYAAAAAHdElNRQff
Bx4EIwJ69EZ3AAAA2ElEQVQY02NgAANGIGBAAEYmZhZWNnYOOJ+Ti5uHl49fQBDKFxIW4RYVE5eQ
lJIGC8jIyskrKCopq6iqqYMVaGhqaSvq6OrpGxgaGYMETEzNzC0sraylbGzt7EECDo5Ozi6uqm42
7h6eXiABbx89X2s//4DAoOCQUJAhYeERkVHRMbFx8QmJYFuSklNS09IzMrOyc3IhDsnLN/IoiC8s
Ki6BObU0qyyhPKeiEsavqqquCa2tq66ubwBzG5vqm6uBoLm+qbGqiqGlpbWtvaOzurqru6e3r6UF
AB06NPiCOXZ9AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTA3LTI5VDE0OjE3OjQ1KzA4OjAwH6v7
tgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNS0wNi0xMlQwNDoyOToyNyswODowMPuBHAEAAAAASUVO
RK5CYII=" />
</svg>
<b>11 Dec 2014: v14.1 released.</b>
Again thanks to Mike Vang for doing independent-build and QA work. This release features significant performance and accuracy improvements for all recent x86 platforms, and especial gains for Intel Haswell (and soon, Broadwell) users.
<p>
First, a note on version numbering: After many years frozen at 3.0x (since my x86 code was until recently wildly uncompetitive with Prime95), now that I'm < 2x slower (on Haswell+), resumed version numbering according to the scheme:
<p>
<i>
Major index = year - 2000<br>
Minor index = release # of that year, zero-indexed.
</i>
<p>
As before, a patch suffix of x, y, or z following the numeric index indicates an [alpha,beta,gamma] (experimental,unstable) code. Since I consider this release stable and it's the 2nd non-beta release of the year, thus 14.1 = [20]14.[--2][no xyz suffix].
<p>
<b>What's new/improved:</b>
<ol>
<li>Self-test now has prestored residues for 10000 iterations (at least though FFT length 18432K), in addition to the previously-supported 100 and 1000. As before, to use a non-default #iters (default is 100) for a given self-test range, add '-iters [1000 | 10000]' to the command line.

<li>One no longer needs any special flags like DFT_V* for any FMA-using routines - just DUSE_THREADS to enable multithreading and DUSE_[SSE2 | AVX | AVX2] to select an x86 SIMD-vector-instruction target.

<li>Propagated Fused multiply-add optimizations to all key discrete Fourier transform (DFT) and related arithmetic macros. "FMA everywhere" means Haswell users should see at least a 10% speedup for their AVX2 builds, compared to plain AVX.

<li>Overall accuracy should be appreciably better, meaning users should see very few roundoff warnings, even for 10Kiter self-tests.

<li>The program now only reports roundoff warnings if it encounters a fractional part > 0.40625 (previous was >= 0.4) during the carry step. Some self-tests (meaning exponents right at the upper limit for the given FFT length, by definition) were emitting slews of 0.40625 warnings, but as this error level is nearly always benign, I've silenced the warnings for it. Larger errors will still emit warnings as before;

<li>The accuracy-problematic radix-11 DFTs (used to build composite leading radices such as 44 and 176) have improved accuracy in SSE2 and AVX modes, but will still emit a few roundoff warnings in longer self-tests for certain radix combos in those build types. In AVX2 mode, however, the fact that "multiplies are free" (assuming we can fuse them with adds, which we can to a very large extent in this case) allowed me implement an entirely different radix-11 algorithm which is much more multiply-heavy, but has significantly better roundoff properties. Thus AVX2 builders will see dramatically lower roundoff errors for FFT lengths using the aforementioned leading radices 44 and 176.

<li>I added large-stride prefetching to all the carry routines, since the 2 DFTs (specifically the final-radix-pass of the inverse FFT, followed by the normalize/carry step, followed by the initial-radix-pass of the subsequent iteration's forward FFT) bookending the carry step in those access data in large strides and are thus problematic for the kinds of default data prefetching done by most x86 hardware. That "manual assist" prefetch should provide a nice boost (5-10% for me at FFT lengths in the Mdoubles range) for all build modes.
</ol>

<HR SIZE=2>

<H2><A NAME="oldrel"></A>Descriptions of recent previous code releases:</H2>

<ul>
<li> <A href="http://hogranch.com/mayer/README_oldrel.html#14.0">18 Sep 2014</a>
<li> <A href="http://hogranch.com/mayer/README_oldrel.html#14.x">23 Jun 2014</a>
<li> <A href="http://hogranch.com/mayer/README_oldrel.html#13.1">02 Oct 2013</a>
<li> <A href="http://hogranch.com/mayer/README_oldrel.html#13.0">04 Feb 2013</a>
<li> <A href="http://hogranch.com/mayer/README_oldrel.html#9.0" >06 Nov 2009</a>
<li> <A href="http://hogranch.com/mayer/README_oldrel.html#8.0" >15 Sep 2008</a>
</ul>

<BR>
<HR SIZE=2>

<H2><A NAME="general"></A>General Questions:</H2>

<p>
  <svg width="16" height="16">
    <image id="image0" width="16" height="16" x="0" y="0"
	   xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJN
AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABrVBMVEXAwMAA3S8E6Cci+S4l
/SYK/C4D8zcA1S8AzC4p9jvd/92w/6tq/2AX/zcI8DkBzS8BricApCMd9i+u/6nH/8J0/2sW/0UF
3DMBvisBoyQBhBwAiB8A6Cxi/1iI/37L/8b///+Y/5Ma80oCxi0BrCcBlCABeR0BWhUD9y4p/zY2
/z6B/3k//1gIyzIBrygBmSIBghwBaRoBThIAUxIB8jYN/0IR+EQd+UwZ50YIxTABrCYBmCEBbxsB
WBQBQA4AOQsA1TAB1C8BzC4BwigBtCkBpCUBghsBXBYBRxABMQoANQkAuCoBtSkBpSUBiyEBex4B
axoBWhYBSBABNAoBLAkAMQgAoiMBlSIBkSEBiSABfhsBcRoBZBgBVRQBRRABNAsBLQ0BJgwAtigB
cxwBchsBbBsBYxgBWBUBSxEBPg4BMA4BLAgBJwwBIAoAeh0BURIBPg0BLg4BKg0BJQsBIQoAYxYB
Lw0BKgoBIwsBHgnBwcEzMzMATBAALw0ALgxsbGzExMSlpaWIiIhPT0+vr6+qqqqSkpJ6enpiYmJL
S0tISEhcXFxxcXGGhoabm5ux5ja/AAAAAXRSTlMAQObYZgAAAAFiS0dEILNrPYAAAAAHdElNRQff
Bx4EIwJ69EZ3AAAA2ElEQVQY02NgAANGIGBAAEYmZhZWNnYOOJ+Ti5uHl49fQBDKFxIW4RYVE5eQ
lJIGC8jIyskrKCopq6iqqYMVaGhqaSvq6OrpGxgaGYMETEzNzC0sraylbGzt7EECDo5Ozi6uqm42
7h6eXiABbx89X2s//4DAoOCQUJAhYeERkVHRMbFx8QmJYFuSklNS09IzMrOyc3IhDsnLN/IoiC8s
Ki6BObU0qyyhPKeiEsavqqquCa2tq66ubwBzG5vqm6uBoLm+qbGqiqGlpbWtvaOzurqru6e3r6UF
AB06NPiCOXZ9AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTA3LTI5VDE0OjE3OjQ1KzA4OjAwH6v7
tgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNS0wNi0xMlQwNDoyOToyNyswODowMPuBHAEAAAAASUVO
RK5CYII=" />
  </svg> For general questions about the math behind the Lucas-Lehmer test, general primality testing or related topics (and also no small number of unrelated topics, such as <a href="http://www.mersenneforum.org/showthread.php?t=20003">this one</a> following in the literary-humor footsteps of Ambrose Bierce), check out the <A href="http://www.mersenneforum.org/">Mersenne Forum.</A>

<p>
  <svg width="17" height="16">
    <image id="image0" width="17" height="16" x="0" y="0"
	   xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAQCAMAAADH72RtAAAABGdBTUEAALGPC/xhBQAAACBjSFJN
AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAaVBMVEXAwMCgoKC5lgCofQDN
tQDJrgDFqAC1kACkdwCcawDWwQDaxwDezQDRuwC9nACtgwCgcQCUXgDq4ADu5gDm2gDBogCYZACM
UgCCgoL28gD6+ACAQADi0wCxiQCERgCITABkZGSQWAAAAACTpGNYAAAAAXRSTlMAQObYZgAAAAFi
S0dEIl1lXKwAAAAHdElNRQffBx4EJDjzuQkCAAAAiUlEQVQY043PyRaDIAwFUCZFBnFgiK0t4P//
ZDmgbRdd9O1yFy8JQn8HE0Ip/poZ63o+CHEZlkqr0UzzctGoV+uU5zTA1ki6233VVfZTHtY63T+H
ALEJk1orSUpPSk18V3dRARGacOKNIVQsKeYmmE4lBXY4BWExi3CkCHl733hAijF/oGLNz6dfxXUH
13qGNX0AAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMDctMjlUMTQ6MTc6NDUrMDg6MDAfq/u2AAAA
JXRFWHRkYXRlOm1vZGlmeQAyMDE1LTA2LTEyVDA0OjI5OjI3KzA4OjAw+4EcAQAAAABJRU5ErkJg
gg==" />
  </svg>For discussions specifically about Mlucas at the above venue, see the <A href="http://www.mersenneforum.org/forumdisplay.php?f=118">Mlucas subforum</A> there.

<BR>

<HR SIZE=2>


<CENTER>
<H2><A NAME="download"></A>STEP 1 - DOWNLOAD AND BUILD THE CODE</H2>
</CENTER>

<P>To do Lucas-Lehmer tests, you'll need to build the latest Mlucas C source code release. First get the release tarball, available in 2 different-zip-based forms:

<ul>
<li> If your system has bzip2 installed, get <A href="http://hogranch.com/mayer/src/C/Mlucas_12.11.2014.tbz2">Mlucas_12.11.2014.tbz2</a> -- 2.2 MB, md5 checksum = 8fffcf4222730cb831752c152974740b. (If the file extension looks unfamiliar, note that some people prefer a 'tar.bz2' extension, as would result from a 2-step 'first tar, then bzip2-compress' procedure). Then use 'tar xjf Mlucas_12.11.2014.tbz2' to one-step uncompress/unpack the archive.

<li> Otherwise, get <A href="http://hogranch.com/mayer/src/C/Mlucas_12.11.2014.tgz">Mlucas_12.11.2014.tgz</a> -- 3.2 MB, md5 checksum = d2cf3d80de68d9bc6361af7ce1942d8b. (If the file extension looks unfamiliar, note that some people prefer a 'tar.gz' extension, as would result from a 2-step 'first tar, then gzip-compress' procedure). Then use 'tar xzf Mlucas_12.11.2014.tgz' to one-step uncompress/unpack the archive.
</ul>

<!--
(Code snapshot for both of the above dated 11 Dec 2014, except for the following patched files: 12 Dec: Mlucas.c comment updates.)
-->
<p>

The build procedure is so simple, I use no makefile - let's illustrate using a multithreaded x86/SSE2 build under 64-bit linux. Note that there are some inline-assembler macros which use most of the 14 available general-purpose registers and as a consequence result in ran-out-of-registers errors in unthreaded mode, thus our default build mode is multithreaded:
<br><br><font color="#0000ff"><i>
gcc -c -Os -m64 -DUSE_SSE2 -DUSE_THREADS *.c<br>
rm -f rng*.o util.o qfloat.o<br>
gcc -c -O1 -m64 -DUSE_SSE2 -DUSE_THREADS rng*.c util.c qfloat.c<br>
gcc -o Mlucas *.o -lm -lpthread -lrt</i></font>
<br><br>
We use -Os (targeting a small object code size) because that yields best performance for SSE2 builds on pre-AVX architectures. For AVX builds on Sandy/Ivy Bridge and AVX2 builds on Haswell/Broadwell you may get a smidge better performance using -O3 or -Ofast instead of -Os, but I have not seen a consistent benefit from doing so, and more importantly (depending on your precise compiler/runtime setup) these don't always play nice with the -mavx/-mavx2 flags (detailed below), which generally will yield a 3-5% speedup on the Sandy/Ivy Bridge and Haswell/Broadwell CPU families, respectively.
<br><br>
The 'rm' command line and the 'gcc -O1' following it perform a rebuild of a trio of accuracy/optimization-sensitive files at a lower opt-level. None of these files is critical for performance, so it is recommended to always do this step even though many builds of all files with the higher opt level work just fine.
<br>
You should expect to see some compiler warnings, mostly of the "type-punned pointer", "signed/unsigned int", "unused variable" and "variable set but not used" (the latter with GCC 4.7 and later) varieties. The first of these is related to the quad-float emulation code used for high-precision double-float-const-initializations. (I try to keep on top of the latter kinds but with multiple build modes which which use various partially-overlapping subsets of variables, were I to set a goal of no such warnings, it would be a nearly full-time job and leave little time for actual new-code development). Other are mainly of the following kind:
<br><br><font color="#0000ff"><i>
[various]: warning: cast from pointer to integer of different size<br>
twopmodq80.c: In function `twopmodq78_3WORD_DOUBLE':<br>
twopmodq80.c:1032: warning: right shift count >= width of type<br>
twopmodq80.c:1032: warning: left shift count is negative<br>
</i></font><br>
These are similarly benign - the cast warnings are due to some array-alignment code which only needs the bottom few bits of a pointer, and the shift-count warnings are a result of compiler speculation-type optimizations.
<br><br>

The various other (including non-x86) build modes are all slight variants of the above example procedure:
<ul>
<li> For x86/AVX (Sandy/Ivy Bridge): replace -DUSE_SSE2 with -DUSE_AVX in the above;<br>
<li> For x86/AVX2+FMA3 (Intel Haswell and beyond): replace -DUSE_SSE2 with -DUSE_AVX2 in the above; <i>(sorry, no AMD FMA4 support - but AMD users can look forward to an AVX2+FMA3 - supporting chip release sometime in 2015.)</i><br>
<li> For non-x86-SIMD (i.e. scalar-double) builds, remove -DUSE_SSE2 in the above;<br>
<li> If using llvm/clang under MacOS, replace 'gcc' with 'clang' in the above, and append '-Xlinker --no-demangle' to the link step. (Note clang does not need explicit library-linkage of the math, pthread and realtime libraries, i.e. does not need the user to invoke -lm -lpthread -lrt at link time, although doing so is not a problem).
<li> For builds on Sandy/Ivy Bridge, you should see a small benefit from replacing '-Os' with '-Os -mavx' (GCC) or '-Os -march=core-avx' (clang).  For builds on Haswell, you should see a small benefit from replacing '-Os' with '-Os -mavx2' (GCC, but only supported in v4.7 and later; users of GCC 4.6 or earlier should use '-Os -mavx' on Haswell) or '-Os -march=core-avx2' (clang);
<li> For 32-bit SIMD builds (SSE2 only, no AVX) replace -m64 with -m32 in the above. NOTE that if you are using Clang under OS X, you still need to use GCC to compile a small subset of files (radix16*c and radix32*c) in order to work around Clang issues with 32-bit-mode builds of those files, which lead to "Bus Error" crashes and segfaults at runtime. If you still get crashes, I suggest using GCC to build all files, even though the build time will be 3-5x larger.<br>
</ul>

Once you have successfully linked a binary, I suggest you first try a spot-check at some smallish FFT length, say
<br><br><i>
time ./Mlucas -fftlen 192 -iters 100 -radset 0 -nthread 2<br>
</i><br>
This particular testcase should produce the following 100-iteration residues, with some platform-dependent variability in the roundoff errors :<br>
<pre>
100 iterations of M3888517 with FFT length 196608 = 192 K
Res64: 579D593FCE0707B2. AvgMaxErr = 0.260239955. MaxErr = 0.343750000. Program: E14.1
Res mod 2^36     =          67881076658
Res mod 2^35 - 1 =          21674900403
Res mod 2^36 - 1 =          42893438228
</pre>
[If the residues differ from these internally-pretabulated 100-iteration ones, the code will emit a visually-loud error message.]<br>
<br>
Once you have a working binary you can play with #threads ... it is most efficient to gauge the resulting effect on throughput by running one or more of the self-test FFT-length ranges (e.g. small, medium, large) with a user-set thread count, as detailed below.

<BR>
<BR>
<HR SIZE=2>
<CENTER>
<H2><A NAME="selftest"></A>STEP 2 - PERFORMANCE-TUNE FOR YOUR MACHINE</H2>
</CENTER>

<p>For a complete list of Mlucas command line options, type 'Mlucas -h'.

<p>After building the source code, the first thing that should be done is a set of self-tests to make sure the binary works properly on your system. During these self-tests, the code also collects various timing data which allow it to configure itself for optimal performance on your hardware. It does this by saving data about the optimal FFT radix combination at each FFT length tried in the self-test to a configuration file, named <font color="#0000ff"><i>mlucas.cfg</i></font>. Once this file has been generated, it will be read whenever the program is invoked to get the optimal-FFT data (specifically, the optimal set of radices into which to subdivide each FFT length) for the exponent currently being tested.

<p>To perform the needed self-tests for a typical-user setup (which implies that you'll be either doing double-checking or first-time LL testing), <b>first remove or rename any existing mlucas.cfg file from a previous code build/release in the run directory</b>, then type

<p><font color="#0000ff"><i>Mlucas -s m</i></font>

<p>This tells the program to perform a series of self-tests for FFT lengths in the 'medium' range, which currently (as of Fall 2014) means FFT lengths from 1024K-7680K, which covers Mersenne numbers with exponents from 20M - 143M. Note that the code will automatically do the needed self-tests at a given FFT length if it fails to find an mlucas.cfg file, or fails to find an entry for the FFT length in question in that file (e.g. if you get a double-check assignment for an exponent < 20M) so in fact this step is optional. but I still recommend running the above set of self-tests under unloaded or constant-load conditions before starting work on any real assignments, so as to get the most-reliable optimal-FFT data for your machine, and to be able to identify and work around any anomalous timing data. (See example below for illustration of that).

<p><b>Note:</b> the default in automated self-test mode is to use as many threads as there are detected cores ... to use some number different from that you must add the -nthread flag to the command line. This "user custom" mode also requires you to specify the desired number of self-test iterations; you should use one of the 3 standard values, '-iters 100', '-iters 1000' or '-iters 10000' for which the code stores pretabulated results which it uses to validate (or reject) self-test results. 100 is nice for early-stage testing since the self-test will complete in roughly 1/10th the time, but 1000 is better once you have a good idea of optimal thread count on your system, because it yields a more-precise timing and is better at catching radix sets which may yield an unsafely high level of roundoff error for exponents near the upper limit of what the code allows for a given FFT length.

Thus, to run the small, medium and large self-tests 2-threaded and with 1000 iterations per individual subtest:
<br><br><i>
./Mlucas -s s -iters 1000 -nthread 2<br>
./Mlucas -s m -iters 1000 -nthread 2<br>
./Mlucas -s l -iters 1000 -nthread 2<br>
</i><br>
To follow that with a 4-threaded set of tests for purposes of timing comparison, first move the 2-threaded mlucas.cfg file under a different name, e.g.
<br><br><i>
mv mlucas.cfg mlucas.cfg.2thr<br>
./Mlucas -s s -iters 1000 -nthread 4<br>
./Mlucas -s m -iters 1000 -nthread 4<br>
./Mlucas -s l -iters 1000 -nthread 4<br>
mv mlucas.cfg mlucas.cfg.4thr
</i><br>

<p>Once you have determined the best thread count for your system, <i>if this differs from the number of hardware cores</i>, to get the program to use said #nthreads you must create a file 'nthreads.ini' in the same dir as you are running in, enter the desired #threads, and save the file. Some users have reported up to 10% performance gains from using more threads than #cores on their systems (I have seen no such behavior on my Haswell or Macbook, so it is not clear yet what is responsible for such behavior), so this file-read-based thread count setting option is mostly for them.

<p>Lastly, if you have run multiple-thread-count tests as above, prior to starting production LL-testing, link to the desired thread-specific .cfg file. For instance if you have 6 cores but find 4-threaded to yield the best timings using the above namings, 'ln -s mlucas.cfg.4thr mlucas.cfg'.

<p><b>Additional Notes:</b>

<p>If you want to do the self-tests of the various available radix sets for one particular FFT length, enter

<p><font color="#0000ff"><i>Mlucas -s {FFT length in K} -iters [100 | 1000 | 10000]</i></font>

<p>For instance, to test all FFT-radix combo supported for FFT length 704K for 10000 iterations each, enter

<p><font color="#0000ff"><i>Mlucas -s 704 -iters 10000</i></font>

<p>The above single-FFT-length self-test feature is particularly handy if the binary you are using throws errors for one or more particular FFT lengths, which interrupt the complete self-test before it has a chance to complete the configuration file. In that case, after notifying me (please!) the user must skip the offending FFT length and go on to the next-higher one, and in this fashion build a .cfg file one FFT length at a time. (Note that each such test appends to any existing mlucas.cfg file, so make sure to comment out or delete any older entries for a given FFT length after running any new timing tests, if you plan to do any actual "production" LL testing.

<p>For SIMD-enabled (SSE2 and AVX) linux/GCC builds running on x86 platforms, the GCC compiler optimizer sometimes messes up the non-SIMD-enabled carry-step FFT radices, so during self-testing of a GCC build you may see an occasional error messages of this kind:

<p><font color="#0000ff"><i>M36987271 Roundoff warning on iteration        1, maxerr =  14.000000000000
 FATAL ERROR...Halting test of exponent 36987271
</i></font>
<p>As long as the SIMD-enabled radix combinations work - i.e. you get a valid mlucas.cfg file with no "gaps", such errors are ignorable.
<p>
<i>[Dec 2011 - Update: For GCC builds I have replaced the old "add and subtract rounding constant" trick for effecting fast double-precision nearest-int with a call to the compiler instrinsic <font color="#0000ff">lrint</font> macro. This - even when building in scalar (non-SSE2) mode - inlines a fast SSE2-based DNINT, which is roughly as fast as the above add/subtract trick, and most importantly, is not subject to being "optimized away" by the compiler. Thus, one should no longer see the above kinds of errors in GCC builds; the only remaining caveat related to the fused DFT-pass/normalize-and-propagate-carries routines in question is that the ones which were in the past affected by the above problem are ones where the code has not been SSE2-optimized (based on an expected cost/benefit analysis), so will be relatively slow. That is not an issue, because that simply means those radices will never make into the "golden" cfg-file sets, thus they will never be used for actually primality tests.]</i>

<P>If you are running multiple copies of Mlucas, a copy of the mlucas.cfg file should be placed into each working directory (i.e.wherever you have a worktodo.ini file). Note that the program can run without this file, but with a proper configuration file (in particular one which was run under unloaded or constant-load conditions) it will run optimally at each runlength.

<p><b>Format of the mlucas.cfg file:</b>

<P>What is contained in the configuration file? Well, let's let one speak for itself. The following mlucas.cfg file was generated on a 2.8 GHz AMD Opteron running RedHat 64-bit linux.  I've italicized and colorized the comments to set them off from the actual optimal-FFT-radix data:<br>

<pre><i>
	#
	# mlucas.cfg file
	# Insert comments as desired in lines beginning with a # or // symbol, as long as such commenting occurs below line 1, which is reserved.
	#
	# First non-comment line contains program version used to generate this mlucas.cfg file;</i>
	<font color="#0000ff">14.1</font><i>
	#
	# Remaining non-comment lines contain data about the optimal FFT parameters at each runlength on the host platform.
	# Each line below contains an FFT length in units of Kdoubles (i.e. the number of 8-byte floats used to store the
	# LL test residues for the exponent being tested), the best timing achieved at that FFT length on the host platform
	# and the range of per-iteration worst-case roundoff errors encountered (these should not exceed 0.35 or so), and the
	# optimal set of complex-FFT radices (whose product divided by 512 equals the FFT length in Kdoubles) yielding that timing.
	#</i>
	<font color="#0000ff">2048</font>  <i><font color="#ff0000">sec/iter =    0.134</font>  <font color="#7fff00">ROE[min,max] = [0.281250000, 0.343750000]</font></i>  <font color="#0000ff">radices =  32 32 32 32  0  0  0  0  0  0</font>  [Any text offset from the list-ending 0 by whitespace is ignored]
	<font color="#0000ff">2304</font>  <i><font color="#ff0000">sec/iter =    0.148</font>  <font color="#7fff00">ROE[min,max] = [0.242187500, 0.281250000]</font></i>  <font color="#0000ff">radices =  36  8 16 16 16  0  0  0  0  0</font>
	<font color="#0000ff">2560</font>  <i><font color="#ff0000">sec/iter =    0.166</font>  <font color="#7fff00">ROE[min,max] = [0.281250000, 0.312500000]</font></i>  <font color="#0000ff">radices =  40  8 16 16 16  0  0  0  0  0</font>
	<font color="#0000ff">2816</font>  <i><font color="#ff0000">sec/iter =    0.188</font>  <font color="#7fff00">ROE[min,max] = [0.328125000, 0.343750000]</font></i>  <font color="#0000ff">radices =  44  8 16 16 16  0  0  0  0  0</font>
	<font color="#0000ff">3072</font>  <i><font color="#ff0000">sec/iter =    0.222</font>  <font color="#7fff00">ROE[min,max] = [0.250000000, 0.250000000]</font></i>  <font color="#0000ff">radices =  24 16 16 16 16  0  0  0  0  0</font>
	<font color="#0000ff">3584</font>  <i><font color="#ff0000">sec/iter =    0.264</font>  <font color="#7fff00">ROE[min,max] = [0.281250000, 0.281250000]</font></i>  <font color="#0000ff">radices =  28 16 16 16 16  0  0  0  0  0</font>
	<font color="#0000ff">4096</font>  <i><font color="#ff0000">sec/iter =    0.300</font>  <font color="#7fff00">ROE[min,max] = [0.250000000, 0.312500000]</font></i>  <font color="#0000ff">radices =  16 16 16 16 32  0  0  0  0  0</font>
</pre>
Note that as of Jun 2014 the per-iteration timing data written to mlucas.cfg file have been changed from seconds to milliseconds, but that change in scaling is immaterial with respect to the notes below.
<p>
You are free to modify or append data to the right of the # signs in the .cfg file and to add or delete comment lines beginning with a # as desired. For instance, one useful thing is to add information about the specific build and platform at the top of the file. Any text to the right of the 0-terminated radices list for each FFT length is similarly ignored, whether it is preceded by a # or // or not. (But there must be a whitespace separator between the list-ending 0 and any following text).

<p><b>One important thing</b> to look for in a .cfg file generated on your local system is non-monotone timing entries in the sec/iter (seconds per iteration at the particular FFT length) data. for instance, consider the following snippet from an example mlucas.cfg file (to which I've added some boldface highlighting):

<pre>
	<font color="#0000ff">1536</font>  <font color="#ff0000"><i>sec/iter =    0.225</i></font>
	<font color="#0000ff">1664</font>  <font color="#ff0000"><i>sec/iter =    0.244</i></font>
	<font color="#0000ff">1792</font>  <font color="#ff0000"><i>sec/iter =    0.253</i></font>
<b>	<font color="#0000ff">1920</font>  <font color="#ff0000"><i>sec/iter =    0.299</i></font></b>
	<font color="#0000ff">2048</font>  <font color="#ff0000"><i>sec/iter =    0.284</i></font>
</pre>

<p>We see that the per-iteration time for runlength 1920K is actually greater than that for the next-larger vector length that follows it. If you encounter such occurrences in the mlucas.cfg file generated by the self-test run on your system, don't worry about it -- when parsing the cfg file the program always "looks one FFT length beyond" the default one for the exponent in question. If the timing for the next-larger-available runlength is less than that for the default FFT length, the program will use the larger runlength. The only genuinely problematic case with this scheme is if both the default and next-larger FFT lengths are slower than an even larger runlength further down in the file, but this scenario is exceedingly rare. (If you do encounter it, please notify the author and in the meantime just let the run proceed).

<p><b>Aside:</b> This type of thing most often occurs for FFT lengths with non-power-of-2 leading radices (which are algorithmically less efficient than power-of-2 radices) just slightly less than a power-of-2 FFT length (e.g. 2048K = 2<sup>21</sup>), and for FFT lengths involving a radix which is an odd prime greater than 7.  It can also happen if for some reason the compiler does a relatively poorer job of optimization on a particular FFT radix, or if some FFT radix combinations happen to give better or worse memory-access and cache behavior on the system in question. Such nonmonotonicities have gotten more rare with each recent Mlucas release, and especially so at larger (say, > 1024K) FFT lengths, but they do still crop up now and again.


<BR>
<BR>
<HR SIZE=2>
<CENTER>
<H2><A NAME="reserve"></A>STEP 3 - RESERVE EXPONENTS FROM PRIMENET</H2>
</CENTER>

<P>Assuming your self-tests ran successfully, reserve a range of exponents from the GIMPS PrimeNet server. Here's the procedure (for less-experienced users, I suggest toggling between the PrimeNet links and my explanatory comments):

<ul>
<li>	<b>A) CREATE AN ACCOUNT.</b> If you do not already have a PrimeNet account, you must <A href="http://www.mersenne.org/gettingstarted/">create one</A>. PrimeNet will not check out test exponent assignments to you or accept results without an account.
<br><br>
<li>	<b>B) CHECK OUT EXPONENTS.</b> After logging in to your Primenet account, go to the <A href="http://www.mersenne.org/manual_assignment">IPS Manual Test Assignments Check Out</A>. page and enter the number of cores (e.g. a Core2Duo machine is 2 cores) and the desired assignment type. (Mlucas users should select "World record tests", "Smallest available first-time tests" or "Double-check tests").
</ul>

<P>Each PrimeNet work assigment output line is in the form
<BR>
<BR>
<B>{assignment type}={Unique assignment ID},{Mersenne exponent},{known to have no factors with base-2 logarithm less than},{p-1 factoring has/has-not been tried}</B>
<BR>
<BR>
<P>A pair of typical assignments returned by the server follows:
<BR>
<BR>
<CENTER>
<TABLE border=2 cellPadding=2>
  <TBODY>
  <TR>
    <TD align=center><B>Assigment</B>
    <TD align=center><B>Explanation</B>
  <TR>
    <TD align=left bgColor=#7fff00><B>Test=DDD21F2A0B252E499A9F9020E02FE232,48295213,69,0</B>
    <TD align=left>M48295213 has not been previously LL-tested (otherwise the assignment would begin with "DoubleCheck=" instead of "Test="). The long hexadecimal string is a unique assignment ID generated by the PrimeNet v5 server as an anti-poaching measure. The ",69" indicates that M48295213 has been trial-factored to depth 2<sup>69</sup>. and had a default amount of p-1 factoring effort done with no factors found,
	The 0 following the 69 indicates that p-1 still needs to be done, but Mlucas currently does not support p-1 factoring, so perform a first-time LL test of M48295213.<BR>
  <TR>
    <TD align=left bgColor=#ffff00><B>DoubleCheck=B83D23BF447184F586470457AD1E03AF,22831811,66,1</B>
    <TD align=left><BR>M22831811 has already had a first-time LL test performed, been trial-factored to a depth of 2<sup>66</sup><BR>
    and has had p-1 factoring attempted, with no small factors found, so perform a second LL test of M22831811 in order to validate (or refute - in case of mismatching residues for the first-time test and the double-check a triple-check assignment would be generated by the server, whose format would however still read "Doublecheck") the results of the initial test.<BR>
  </TR>
</TBODY></TABLE></CENTER>

<p>Copy the Test=... or DoubleCheck=... lines returned by the server into the worktodo.ini file, which must be in the same directory as the Mlucas executable (or contain a symbolic link to it) and the mlucas.cfg file. If this file does not yet exist, create it. If this file already has some existing entries, append any new ones below them.

<p>Note that Mlucas makes no distinction between first-time LL tests and double-checks - this distinction is only important to the Primenet server.

<p>Most exponents handed out by the PrimeNet server have already been trial-factored to the recommended depth, so in most cases, no additional factoring effort is necessary. If you have exponents that require additional trial factoring, you'll need to do the trial factoring using Prime95 on a PC, as Mlucas currently has no trial factoring capability.

<p>If you wish to test some non-server-assigned prime exponent, you can simple enter the raw exponent on a line by itself in the worktodo.ini file.


<BR>
<BR>
<HR SIZE=2>
<CENTER>
<H2><A NAME="lltest"></A>STEP 4 - LUCAS-LEHMER TESTING</H2>
</CENTER>

<P>On a Unix or Linux system, cd to the directory containing the Mlucas executable (or a link to it), the worktodo.ini and the mlucas.cfg file and type

<P><font color="#0000ff"><i>nice ./Mlucas &</i></font>

<P>The program will run silently in background, leaving you free to do other things or to log out. Every 10000 iterations, the program writes a timing to the "p{exponent}.stat" file (which is automatically created for each exponent), and writes the current residue and all other data it needs to pick up at this point (in case of a crash or powerdown) to a pair of restart files, named "p{exponent}" and "q{exponent}." (The second is a backup, in the rare event the first is corrupt.) When the exponent finishes, the program writes the least significant 64 bits of the final residue (in hexadecimal form, just like Prime95) to the .stat and results.txt (master output) file. Any round-off or FFT convolution error warnings are written as they are detected both to the status and to the output file, thus preserving a record of them when the Lucas-Lehmer test of the current exponent is completed.

<P><b>ADDING NEW EXPONENTS TO THE WORKTODO.INI FILE:</b>
You may add or modify ALL BUT THE FIRST EXPONENT (i.e. the current one) in the worktodo.ini file while the program is running. When the current exponent finishes, the program opens the file, deletes the first entry and, if there is another exponent on what was line 2 (and now is line 1), starts work on that one.

<BR>
<BR>
<HR SIZE=2>
<CENTER>
<H2><A NAME="checkin"></A>STEP 5 - SEND YOUR RESULTS TO PRIMENET</H2>
</CENTER>

<P>To report results (either after finishing a range, or as they come in), login to your PrimeNet account and then proceed to the <A href="http://www.mersenne.org/manual_result">Manual Test Results Check In</A>. Paste the results you wish to report (i.e. the final line of the p*.stat file, or one or more lines of the results.txt file) into the large window immediately below.

<p>If for some reason you need more time than the 180-day default to complete a particular assignment, go to the <A href="http://www.mersenne.org/manual_extension">Manual Test Time Extension</A>.page and enter the assignment there.

<BR>
<BR>
<HR SIZE=2>
<CENTER>
<H2><A NAME="minesbigger"></A>TRACKING YOUR CONTRIBUTION</H2>
</CENTER>

<p>You can track your overall progress (for both automated and manual testing work) at the
<A href="http://www.mersenne.org/report_top_500/">PrimeNet server's producer page.</a> Note that this does not include pre-v5-server manual test results. (That includes most of my GIMPS work, in case you were feeling personally slighted ;).


<BR>
<BR>
<HR SIZE=2>
<CENTER>
<H2><A NAME="faq"></A>ALGORITHMIC Q & A</H2>
</CENTER>

<ul>
<li><b> 1) What type of an algorithm does Mlucas use?</b>
<p> It uses the well-known Lucas-Lehmer test for Mersenne numbers, which involves selecting an initial seed number (typically 4, but other values, such as 10, also work), then repeatedly squaring and subtracting 2, with the result of each squaring being reduced modulo M(p), the number under test. This square/subtract-2 step is done exactly p-2 times. If the result (modulo M(p)) is zero, M(p) is prime. For an excellent and much more in-depth discussion of the Lucas-Lehmer test and many other prime-related topics, please visit <A href="http://www.utm.edu/research/primes/mersenne.shtml">Chris Caldwell's web page on Mersenne numbers.</a>
</p>

<li><b> 2) Where does the code spend most of its time?</b>
<p> Since the numbers being tested (and hence the intermediate residues in the LL test) are so large that they typically must be distributed across millions of computer words, by far the most time-consuming part of the LL test is the modular squaring.
</p>

<li><b> 3) How does the code accomplish the squaring?</b>
<p> For a large integer occupying N computer words, a simple digit-by-digit ("grammar school") multiply operation (which needs on the order of N<sup>2</sup> machine operations) is much too slow to be practical. Rather, the code uses a multiply algorithm based on <i>discrete convolution</i>. (Math-geek joke: A discrete convolution is a convolution which doesn't kiss and tell.) The discrete convolution algorithm is best-known from the field of signal processing, but also proves to have a surprising and very nifty application to the task of multi-precision multiplication. Long story short, recasting the bignum multiply as a discrete convolution allows one to use highly efficient discrete-convolution-effecting algorithms, the best-known of which is the fast Fourier transform (FFT), which is described in many numerical analysis texts, such as the well-known Numerical Recipes (NR) books. (NR even has a set of so-called multiprecision integer routines, but I suggest staying away from them - they're awful.) For a back-of-the-envelope-style worked example illustrating the procedure, <a href="http://www.mersenneforum.org/showthread.php?t=120">see here</a>.

<p> The code also uses the now-well-known Discrete Weighted Transform technique of Crandall and Fagin (for a detailed reference, see the Mlucas.c source code header or <a href="http://hogranch.com/mayer/F24.pdf">this research paper</a>) to implicitly do the modding. This permits one to "fill" the digits of the input vector to the FFT-based squaring, and thus to reduce the vector length by a factor of 2 or more relative to any pre-1994 codes.

<p>The upshot is, to write the world's fastest Mersenne testing program, one must write (or make use of) the world's fastest FFT algorithm.
</p>

<li><b> 4) What type of FFT algorithm does Mlucas use?</b>
<p> Mlucas uses a custom FFT implementation written by me (EWM). I first started on this algorithmic journey in the late summer of 1996, and being a complete novice at transform-based arithmetic at the time, the first FFT routines I used were those from NR. Since then, the code has greatly evolved, and the FFT I currently use looks absolutely nothing like the original one, although it is doing basically the same thing (except for the non-power-of-2 vector length routines - NR has nothing along those lines.) In recent years I have also augmented the original generic high-level C-code FFT implementation with inline assembly code to take advantage of the more-recent x86 processors` <a href="http://en.wikipedia.org/wiki/SSE2">SIMD vector processing capabilities</a>. This more than doubles the program per-cycle throughput on AMD64 and Intel CPUs supporting SSE2 (roughly, Opteron through Core2), and nearly doubles it again on Intel CPUs supporting the newer AVX instruction set with its 256-bit-wide registers, each of which can hold 4 doubles.
<p>(Alas, at least of this mid-2014 writing AMD's AVX-supporting offerings are woeful -- their total throughput for AVX code is typically *less* than for an SSE2 build running on the same chip. One hopes this will be remedied soon, but it's not up to me.)

<li><b> 5) How does the Mlucas FFT compare to other high-performance FFT implementations, such as <A href="http://www.fftw.org/">the FFTW package?</a></b>
<p> I have not had time or desire to package the FFT core of Mlucas into a form suitable for inclusion in the FFTW benchmarks, but my own comparisons indicate that the Mlucas FFT is typically at least twice as fast as FFTW for the vector lengths of interest to Mersenne prime searchers (real vectors of length 128K and larger, where K=2<sup>10</sup>=1024) running on comparable hardware.

<BR>
<BR>
<HR SIZE=2>
<BR>
<CENTER>
Happy hunting - perhaps you will be the person to discover the next Mersenne prime!
</CENTER>

<br>

<HR SIZE=2>
<H3><A NAME="fdl"></A>GNU Free Documentation License</H3>

Copyright (C) 2015 Ernst W. Mayer. Permission is granted to copy, distribute and/or modify this documentunder the terms of the <a href="https://www.gnu.org/licenses/fdl.html">GNU Free Documentation License</a>, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
<br>
<br>

<HR SIZE=2>
<center>
http://hogranch.com/mayer/README.html -- Last Revised: 25 May 2015<BR>
Send mail to <A HREF="mailto:ewmayer@aol.com">ewmayer@aol.com</A><BR>
</center>

</BODY>
</HTML>

