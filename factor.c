/*******************************************************************************
*                                                                              *
*   (C) 1997-2006 by Ernst W. Mayer.                                           *
*                                                                              *
*  This program is free software; you can redistribute it and/or modify it     *
*  under the terms of the GNU General Public License as published by the       *
*  Free Software Foundation; either version 2 of the License, or (at your      *
*  option) any later version.                                                  *
*                                                                              *
*  This program is distributed in the hope that it will be useful, but WITHOUT *
*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or       *
*  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for   *
*  more details.                                                               *
*                                                                              *
*  You should have received a copy of the GNU General Public License along     *
*  with this program; see the file GPL.txt.  If not, you may view one at       *
*  http://www.fsf.org/licenses/licenses.html, or obtain one by writing to the  *
*  Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA     *
*  02111-1307, USA.                                                            *
*                                                                              *
*******************************************************************************/

/* NOTE: Default should simply include this sourcefile as part of an Mlucas build.
To build the sieve factoring code in standalone mode, see the compile instructions below!
*/

#include "factor.h"
#include "align.h"

#define FAC_DEBUG	0

#ifdef INCLUDE_PM1
	#include "gcd_lehmer.h"
#endif

#define ALLOW_PRP	0	/* Set nonzero to show Fermat base-2 pseudoprimes during small-prime-gen step
							(and to have the latter run 10-30x more slowly). The name here is perhaps
							a tad confusing: "allow" means "don't weed out via use of prestored tables."
						*/

#if(defined(USE_SSE2) && defined(COMPILER_TYPE_MSVC) && OS_BITS == 32)

	#define FERMAT_PSP2	0	/* Set nonzero to activate the special base-2 Fermat-pseudoprime functionality */

	#if FERMAT_PSP2
		#define MI64_IS_DIV_BY_SCALAR32P_X8_SSE2(\
			array_64x8inputs,\
			q,		\
			qinv,	\
			retval	\
		)\
		{\
			DBG_ASSERT(HERE, qinv == qinv*((uint32)2 - q*qinv), "mi64_is_div_by_scalar32p: bad qinv!");\
			DBG_ASSERT(HERE, ((uint32)&a[0] & 0x3f) == 0, "A-array not 64-byte aligned!");\
			__asm	mov	eax, array_64x8inputs	/* Assumes inputs a,b,c,d,... are 64-bit separated and &a[0} is 64-byte aligned */\
			__asm	lea	ebx, q\
			__asm	lea	ecx, qinv\
			__asm	movaps	xmm0,[eax     ]	/* ab: d3210 = [bhi|blo|ahi|alo] */\
			__asm	movaps	xmm1,[eax+0x10]	/* cd: d3210 = [dhi|dlo|chi|clo] */\
			__asm	movaps	xmm2,[eax+0x20]	/* ef: d3210 = [fhi|flo|ehi|elo] */\
			__asm	movaps	xmm3,[eax+0x30]	/* gh: d3210 = [hhi|hlo|ghi|glo] */\
			__asm	movaps	xmm6,xmm0	/* Circularly-permute [4,6,7] -> [6,7,4] here so the 2 packed outputs end up in xmm6,7 */\
			__asm	movaps	xmm5,xmm1\
			__asm	movaps	xmm7,xmm2\
			__asm	movaps	xmm4,xmm3\
			__asm	psrlq	xmm6, 32		/* d3210 = [  0|bhi|  0|ahi] */\
			__asm	psrlq	xmm5, 32		/* d3210 = [  0|dhi|  0|chi] */\
			__asm	psrlq	xmm7, 32		/* d3210 = [  0|fhi|  0|ehi] */\
			__asm	psrlq	xmm4, 32		/* d3210 = [  0|hhi|  0|ghi] */\
			__asm	psllq	xmm5, 32		/* d3210 = [dhi|  0|chi|  0] */\
			__asm	psllq	xmm4, 32		/* d3210 = [hhi|  0|ghi|  0] */\
			__asm	paddd	xmm6,xmm5		/* d3210 = [dhi|bhi|chi|ahi], xmm5 FREE */\
			__asm	paddd	xmm7,xmm4		/* d3210 = [hhi|fhi|ghi|ehi], xmm4 FREE */\
			__asm	movd	xmm4,[ebx]\
			__asm	movd	xmm5,[ecx]\
			__asm	pshufd	xmm4,xmm4,0x44	/* Broadcast q    to slots 0,2 of xmm4 */\
			__asm	pshufd	xmm5,xmm5,0x44	/* Broadcast qinv to slots 0,2 of xmm5 */\
			/* (a-h)[0]*qinv; Alas SSE2 has no 32-bit low-half packed MUL, so use 32x32->64 -bit and discard high halves */\
			__asm	pmuludq	xmm0,xmm5\
			__asm	pmuludq	xmm1,xmm5\
			__asm	pmuludq	xmm2,xmm5\
			__asm	pmuludq	xmm3,xmm5\
			/* cy[0-7] = MULH32(tmp[0-7]*q) - high halves of above MULQs automatically get overwritten: */\
			__asm	pmuludq	xmm0,xmm4\
			__asm	pmuludq	xmm1,xmm4\
			__asm	pmuludq	xmm2,xmm4\
			__asm	pmuludq	xmm3,xmm4\
			__asm	psrlq	xmm0, 32		/* d3210 = [  0|cy1|  0|cy0] */\
			__asm	psrlq	xmm1, 32		/* d3210 = [  0|cy3|  0|cy2] */\
			__asm	psrlq	xmm2, 32		/* d3210 = [  0|cy5|  0|cy4] */\
			__asm	psrlq	xmm3, 32		/* d3210 = [  0|cy7|  0|cy6] */\
			__asm	psllq	xmm1, 32		/* d3210 = [cy3|  0|cy2|  0] */\
			__asm	psllq	xmm3, 32		/* d3210 = [cy7|  0|cy6|  0] */\
			__asm	paddd	xmm0,xmm1		/* d3210 = [cy3|cy1|cy2|cy0], xmm1 FREE */\
			__asm	paddd	xmm2,xmm3		/* d3210 = [cy7|cy5|cy6|cy4], xmm3 FREE */\
			__asm	movaps	xmm3,xmm6		/* Copy of acbd[1] */\
			__asm	movaps	xmm1,xmm7		/* Copy of efgh[1] */\
			__asm	psubd	xmm6,xmm0		/* acbd[1] - cy0213, xmm0 FREE */\
			__asm	psubd	xmm7,xmm2		/* egfh[1] - cy4657, xmm2 FREE */\
			__asm	movaps	xmm2,xmm6		/* Copy of acbd[1] - cy0213 */\
			__asm	movaps	xmm0,xmm7		/* Copy of efgh[1] - cy4657 */\
			/* Had a borrow? Frickin' SSE2 only gives us signed packed-integer compares,\
			so need to emulate unsigned (x > y) via signed (x ^ 0x80000000) < (y ^ 0x80000000): */\
			__asm	pcmpeqd	xmm4,xmm4		/* All 1s  - will need to restore q to this register later */\
			__asm	pslld	xmm4, 31		/* 4-way 0x80000000 */\
			__asm	pxor	xmm6,xmm4		/* (acbd[1]-cy0213) ^ 0x80000000 */\
			__asm	pxor	xmm7,xmm4		/* (egfh[1]-cy4657) ^ 0x80000000 */\
			__asm	pxor	xmm3,xmm4		/* (acbd[1]) ^ 0x80000000 */\
			__asm	pxor	xmm1,xmm4		/* (egfh[1]) ^ 0x80000000 */\
			__asm	pcmpgtd	xmm6,xmm3		/* cy0213 = (acbd[1]-cy0213) > abcd[1], xmm3 FREE */\
			__asm	pcmpgtd	xmm7,xmm1		/* cy4657 = (egfh[1]-cy4657) > efgh[1], xmm1 FREE */\
			__asm	pshufd	xmm3,xmm2,0x31	/* xmm2 = [----|tmp1|----|tmp0], xmm3 = [----|tmp3|----|tmp2], don't care what's in ---- slots */\
			__asm	pshufd	xmm1,xmm0,0x31	/* xmm0 = [----|tmp5|----|tmp4], xmm1 = [----|tmp7|----|tmp6], don't care what's in ---- slots */\
			__asm	movd	xmm4,[ebx]		/* Restore q to xmm4 */\
			__asm	pshufd	xmm4,xmm4,0x44	/* Broadcast q    to slots 0,2 of xmm4 */\
			/* tmp[0-7]*qinv; Alas SSE2 has no 32-bit low-half packed MUL, so use 32x32->64 -bit and discard high halves */\
			__asm	pmuludq	xmm3,xmm5\
			__asm	pmuludq	xmm1,xmm5\
			__asm	pmuludq	xmm2,xmm5\
			__asm	pmuludq	xmm0,xmm5\
			/* Add carries 01/45, scatter carries 23/67 into slots of 01/45, add those...Since SSE2 compare result is ~()ed, add really means sub: */\
			__asm	psubd	xmm2,xmm6		/* xmm6 = [----|tmp1|----|tmp0], don't care what's in ---- slots */\
			__asm	psubd	xmm0,xmm7		/* xmm7 = [----|tmp5|----|tmp4], don't care what's in ---- slots */\
			__asm	pshufd	xmm6,xmm6,0x31\
			__asm	pshufd	xmm7,xmm7,0x31\
			__asm	psubd	xmm3,xmm6		/* xmm3 = [----|tmp3|----|tmp2], don't care what's in ---- slots */\
			__asm	psubd	xmm1,xmm7		/* xmm1 = [----|tmp7|----|tmp6], don't care what's in ---- slots */\
			/* cy[0-7] = MULH32(tmp[0-7]*q) - high halves of above MULQs automatically get overwritten: */\
			__asm	pmuludq	xmm2,xmm4\
			__asm	pmuludq	xmm0,xmm4\
			__asm	pmuludq	xmm3,xmm4\
			__asm	pmuludq	xmm1,xmm4\
			__asm	psrlq	xmm2, 32		/* d3210 = [  0|cy1|  0|cy0] */\
			__asm	psrlq	xmm0, 32		/* d3210 = [  0|cy5|  0|cy4] */\
			__asm	psrlq	xmm3, 32		/* d3210 = [  0|cy3|  0|cy2] */\
			__asm	psrlq	xmm1, 32		/* d3210 = [  0|cy7|  0|cy6] */\
			__asm	pshufd	xmm2,xmm2,0x58	/* [  0|  0|cy1|cy0] */\
			__asm	pshufd	xmm0,xmm0,0x58	/* [  0|  0|cy5|cy4] */\
			__asm	pshufd	xmm3,xmm3,0x85	/* [cy3|cy2|  0|  0] */\
			__asm	pshufd	xmm1,xmm1,0x85	/* [cy7|cy6|  0|  0] */\
			__asm	paddd	xmm2,xmm3		/* d3210 = [cy3|cy1|cy2|cy0] */\
			__asm	paddd	xmm0,xmm1		/* d3210 = [cy7|cy5|cy6|cy4] */\
			__asm	pcmpgtd	xmm7,xmm7		/* All 0s */\
			__asm	pcmpeqd	xmm2,xmm7		/* retval[0-3] */\
			__asm	pcmpeqd	xmm0,xmm7		/* retval[4-7] */\
			__asm	movmskps eax,xmm2		/* retval[0-3] */\
			__asm	movmskps ebx,xmm0		/* retval[4-7] */\
			__asm	shl		 ebx, 4		/* retval[4-7] << 4 */\
			__asm	add		 eax,ebx	/* retval[0-7] */\
			__asm	mov	retval,  eax	\
		}
	#endif
#endif

/*********** Small-prime-generation stuff: ************/

/* There are 10403 ( = 101*103) base-2 Fermat pseudoprimes < 2^32. [Cf. http://home.att.net/~numericana/answer/pseudo.htm#pseudoprime for
other tables related to the pseudoprimes of various types]. We split these into 2 subsets - those divisible by 3 or 5 and those not.

Some General Observations:

The largest base-2 Fermat pseudoprime < 2^32 is 4294901761 = 193*22253377 = 2^32 - 2^16 + 1,
which is reminiscent of the 64-bit (genuine) prime 2^64 - 2^32 + 1 used by Nick Craig-Wood in his pure-integer convolution code.

The only twin pseudoprimes < 2^32 are 4369 (which = 17*257, the product of the Fermat primes F2 and F3) and 4371. Similarly to F2*F3,
the product F3*F4 = 16843009 is a base-2 Fermat pseudoprime. Other products of Fermat primes are "near pseudoprimes" in the sense that
their base-2 Fermat residue is a power of 2, e.g. for n=17*65537, 2^(n-1)%n = 2^16.

The largest (gap/2) between adjacent pseudoprimes (either in the merged
length-10403 table or the f2psp[] one - the number is set by two adjacent elements of the latter - is 4199775, so no significant
compactification via a difference table is possible, as there is for the primes.
*/
/* Even though our simple 8-way sieve algo eliminates base-2 Fermat pseudoprimes divisible by 3 and 5 a priori,
here are the 1037 of those < 2^32, by way of reference:
*/
const uint32 f2psp_3_5[1037] = {
	561u,645u,1105u,1905u,2465u,4371u,8481u,10585u,11305u,12801u,16705u,18705u,23001u,25761u,33153u,34945u,39865u,41665u,55245u,62745u,72885u,74665u,83665u,87249u,107185u,121465u,129921u,154101u,157641u,206601u,208465u,212421u,215265u,223345u,266305u,278545u,289941u,332949u,427233u,449065u,451905u,464185u,493885u,526593u,588745u,656601u,743665u,757945u,800605u,825265u,831405u,898705u,915981u,1050985u,1106785u,1246785u,1275681u,1394185u,1472065u,1472505u,1485177u,1489665u,1520905u,1529185u,1608465u,1620385u,1643665u,1815465u,1830985u,1892185u,1908985u,2077545u,2113665u,2142141u,2162721u,2213121u,2232865u,2288661u,2290641u,2414001u,2419385u,2513841u,2531845u,2793351u,2882265u,3020361u,3181465u,3224065u,3370641u,3435565u,3664585u,3746289u,3779185u,4025905u,4229601u,4259905u,4371445u,4502485u,4535805u,4613665u,
	4895065u,5133201u,5400489u,5489121u,5529745u,5545145u,5560809u,5599765u,5632705u,6054985u,6135585u,6212361u,6235345u,6242685u,6628385u,7040001u,7177105u,7233265u,7693401u,7724305u,8012845u,8041345u,8137585u,8322945u,8656705u,9063105u,9223401u,9224391u,9582145u,9638785u,9816465u,10239985u,10275685u,10655905u,10680265u,10818505u,10974385u,11034365u,11119105u,11242465u,11473885u,11776465u,11875821u,11921001u,12067705u,12702145u,12945745u,12979765u,13187665u,13823601u,13899565u,13992265u,14556081u,14885697u,14892153u,15403285u,16263105u,18007345u,18137505u,19092921u,19260865u,19523505u,19569265u,19781763u,20494401u,20626165u,21584305u,22269745u,22665505u,23054601u,23517985u,23736385u,24161905u,25266745u,25270105u,25831585u,26296401u,26719701u,27032545u,27736345u,27986421u,28175001u,28787185u,30411201u,30653245u,31692805u,31880577u,32428045u,33018985u,33408145u,34487601u,34603041u,35967921u,36121345u,36168265u,36507801u,37354465u,37695505u,38453151u,38789913u,
	38790753u,39353665u,40280065u,40886241u,40933705u,41067665u,41102601u,41298985u,41424801u,42689305u,42998901u,45318561u,45593065u,45769645u,46282405u,46647745u,47006785u,48398065u,49430305u,51396865u,51890545u,52018341u,52452905u,53315605u,53661945u,55329985u,55961065u,57130161u,57561085u,57749185u,58498105u,58708761u,60112885u,60375745u,61679905u,62656985u,63560685u,64567405u,64644385u,64685545u,65350821u,65919745u,66437841u,67371265u,67968385u,68958681u,69776785u,70484065u,70938429u,71040561u,71479765u,72135505u,72192021u,72887585u,73346365u,73439185u,73451665u,74165065u,74698345u,75836905u,77082545u,77442905u,78397705u,81445585u,81612105u,81722145u,82847001u,82976181u,84028407u,84234745u,84417985u,86559045u,89148417u,89816545u,89915365u,90626185u,91453705u,92027001u,92343745u,93030145u,93869665u,93967105u,96386865u,96589585u,96653985u,97487785u,99861985u,101232145u,103065945u,105370805u,105859585u,106676301u,107023281u,109245585u,109583601u,110671341u,111463705u,112037185u,114202465u,114940945u,
	115542505u,116397345u,117450145u,118352697u,119532385u,121017261u,121701385u,122558185u,124167201u,125841633u,125999245u,128039241u,130032865u,130338321u,130497985u,131585421u,135303805u,135556345u,136446465u,137009181u,139336653u,139477405u,139489251u,139536865u,139892065u,141429009u,142585701u,143453905u,144200001u,144426085u,145124785u,145745601u,147105505u,149442879u,151833561u,152674705u,152814531u,154076541u,154510705u,154797085u,155172165u,156430345u,156858801u,158845569u,161030001u,161146385u,161242705u,162999145u,165163265u,165990651u,167187385u,168058045u,168147365u,168448105u,168752305u,170837409u,170947105u,171704065u,174352641u,175997185u,179223265u,179306345u,181828765u,185753121u,185887329u,187460785u,188133085u,192736965u,192844345u,193298365u,193622001u,194298189u,194579785u,200144253u,200767645u,201998965u,203095985u,205429533u,212841565u,213264745u,214865785u,215344345u,216192145u,216797601u,216838945u,218115265u,224073865u,225745345u,226018585u,226481905u,226791685u,226872685u,228549565u,230996949u,231194965u,232168105u,233955905u,235201461u,238018341u,238240465u,
	238527745u,246970945u,248031745u,254054505u,255655401u,257567545u,262412445u,265729465u,268042209u,269988445u,272479285u,273321665u,274014885u,276198245u,282049705u,285858145u,293609485u,294721945u,297243145u,297549501u,299120185u,301704985u,302751505u,305314465u,312734305u,312903921u,314089161u,316572385u,321197185u,324216685u,325546585u,327718401u,328176745u,328190185u,329379505u,332633665u,333065305u,334783585u,337420945u,348612265u,353987481u,357339745u,358466361u,360248785u,361458505u,367939585u,370874245u,372088401u,378123085u,385924105u,388515205u,389139265u,390512785u,390563185u,395136505u,396262945u,404514145u,405431121u,407131165u,408243865u,410620465u,413160265u,413210785u,413435121u,413631505u,415702105u,416392005u,417241045u,422514145u,424963281u,429553345u,435558565u,437921785u,440707345u,441529089u,445202605u,447596673u,447711745u,449984305u,456238945u,456465153u,457093585u,461328897u,466832665u,468362665u,469816705u,473930965u,474028161u,476177905u,476470401u,477726145u,483532105u,486484581u,488184445u,489868345u,492301041u,493654105u,495230905u,504577585u,504920305u,
	508958605u,518552785u,518599929u,519877345u,520256985u,523116561u,524806185u,525355285u,526491265u,527865801u,539419805u,544379181u,549117205u,551654065u,552385765u,554280805u,556418721u,557413165u,557910505u,558097345u,559246605u,561825265u,564862145u,571614681u,573478165u,574685545u,578847585u,582176001u,590754385u,592310181u,593444545u,595949005u,596913265u,602074585u,605033065u,606057985u,606338185u,608693905u,611397865u,611822541u,612347905u,613457065u,613681701u,621101185u,625436665u,628273405u,628485445u,629350345u,629470465u,636958945u,639969891u,642771921u,644051001u,647101585u,657160945u,661896145u,662086041u,669861505u,677280561u,681015021u,681942801u,684106401u,689880801u,694756585u,699735345u,703031253u,703638565u,712782561u,716846065u,723926841u,741969537u,743597065u,744866305u,745864945u,747822945u,747923905u,753129505u,755613145u,763233745u,767681853u,780140451u,787267041u,791348811u,792418705u,799751361u,803219365u,807912865u,810389105u,817461745u,818379745u,822161665u,831464305u,831652257u,831807145u,832938261u,834508585u,838200805u,842182881u,844034241u,847249131u,
	849255177u,851009545u,852808881u,854197345u,860056705u,860751985u,864048865u,865517185u,869664801u,871320385u,874017145u,895316305u,896263705u,902325201u,905934745u,906323601u,914255785u,914801665u,915873505u,916354209u,920711045u,921678081u,926007985u,928761505u,936189745u,939331345u,940492785u,944919141u,945959365u,947058085u,949035585u,955718345u,956186121u,958970545u,966830545u,968014401u,971730985u,979121545u,981567505u,981621145u,1018928485u,1022479705u,1029858621u,1047198909u,1047312085u,1060476385u,1061977645u,1064686085u,1073823745u,1074363265u,1078551145u,1090519105u,1090842145u,1091003665u,1101775533u,1102719385u,1109260545u,1112691009u,1115335585u,1115578101u,1117499601u,1121315385u,1122044365u,1122283713u,1122892881u,1130057601u,1132988545u,1133922565u,1136739745u,1138817785u,1147671505u,1153997885u,1155869485u,1180004001u,1210178305u,1210968265u,1213950585u,1214695945u,1227023785u,1231457305u,1239702465u,1239992065u,1252438705u,1255009105u,1255698145u,1255792385u,1262015301u,1267600105u,1271632465u,1276614145u,1278598945u,1285445305u,1288363105u,1297725105u,1310486905u,1312114945u,1312832665u,1327232481u,1331331065u,1332521065u,
	1333565065u,1337805505u,1338604345u,1363200385u,1371964945u,1377457005u,1392386421u,1396555161u,1399850245u,1402482445u,1405146085u,1411029445u,1411256001u,1417268665u,1418724681u,1419324985u,1420379065u,1435342385u,1442692285u,1452092005u,1455287901u,1470287001u,1474069345u,1477140085u,1490078305u,1490522545u,1506520401u,1509030645u,1511781985u,1512164841u,1517574745u,1520579589u,1533511945u,1534274841u,1538242161u,1548716065u,1553485137u,1553860945u,1560125785u,1561719145u,1568731305u,1573657345u,1574300001u,1583347105u,1587511245u,1596900865u,1600976785u,1607105865u,1608120865u,1610102649u,1615335085u,1618206745u,1622644765u,1623010705u,1637220201u,1641323905u,1643300785u,1649718505u,1663458265u,1665952345u,1672323745u,1673055385u,1674309385u,1677594045u,1688801545u,1719963505u,1730985985u,1734436705u,1755047785u,1764517701u,1771104385u,1776450565u,1778357505u,1783167145u,1784156001u,1789181065u,1792705965u,1792843585u,1793546665u,1801635265u,1802301445u,1814039605u,1816572745u,1829030545u,1834853905u,1835082145u,1845871105u,1848112761u,1853263365u,1868715465u,1872058105u,1872674805u,1879749145u,1880388885u,1889722045u,1889866945u,1900461745u,1917829585u,1918052065u,1928602677u,
	1935995601u,1943227585u,1950276565u,1953988345u,1954174465u,1962287601u,1962804565u,1964958805u,1975038717u,1983819565u,1984685185u,1986739105u,1987908805u,1999004365u,1999167185u,2013655645u,2018054721u,2049791185u,2058444865u,2080544005u,2088928465u,2106753265u,2126956105u,2169795745u,2176838049u,2187426385u,2202907345u,2208119001u,2212935985u,2217605545u,2225745145u,2232385345u,2276082537u,2281251505u,2287363585u,2336266765u,2339494851u,2367946945u,2395916965u,2407376665u,2409052465u,2417888121u,2434042465u,2434465705u,2443115305u,2452594285u,2457411265u,2458488385u,2479305985u,2485120353u,2491794985u,2494621585u,2495281285u,2538002545u,2569766109u,2571292585u,2572706305u,2574493345u,2579037801u,2589172285u,2592053871u,2602452685u,2602863865u,2607029965u,2607116865u,2615264785u,2658644301u,2666771185u,2668885185u,2677955505u,2689459345u,2693081973u,2696384545u,2699904385u,2709434065u,2710143129u,2719932865u,2721882801u,2722710201u,2723630365u,2738975905u,2741816065u,2758254265u,2769136833u,2785731411u,2851612221u,2866916065u,2867450545u,2868506785u,2869114305u,2872608369u,2878775005u,2896234705u,2907393385u,2920050561u,2936443105u,2945912905u,2958413185u,2965273851u,2972569705u,
	2976144865u,2983101265u,2986509205u,3006731665u,3022354401u,3022614805u,3023421265u,3037396461u,3047384845u,3047863105u,3060957153u,3082944561u,3085053801u,3108154105u,3118667245u,3159422785u,3165936265u,3166051105u,3167288301u,3168479665u,3169353265u,3177443721u,3180288385u,3181493665u,3187740205u,3188744065u,3195446905u,3206944945u,3211036165u,3215147001u,3222053185u,3224575165u,3224936121u,3232450585u,3233256265u,3249390145u,3253611985u,3253987045u,3263564305u,3265116261u,3274299505u,3274587345u,3277595665u,3280282465u,3281905705u,3285783865u,3307322305u,3325267401u,3328293745u,3340297105u,3348463105u,3361551145u,3366611905u,3374360965u,3379764081u,3397718545u,3401753545u,3403018945u,3417734945u,3425782465u,3464613505u,3467555785u,3471738405u,3496809985u,3507685105u,3517248801u,3518855601u,3519837505u,3521391985u,3521441665u,3525082345u,3532381585u,3541133245u,3556250065u,3574014445u,3575798785u,3597794065u,3608154201u,3609962301u,3626245041u,3631048401u,3637405045u,3647939065u,3661505985u,3668553505u,3699249085u,3712335985u,3716718765u,3719904385u,3726405865u,3732931005u,3737002305u,3790810465u,3802495269u,3808686801u,3809101465u,3811133305u,3812949505u,3824300065u,3858045985u,
	3860623585u,3864815601u,3886188865u,3892568065u,3896087361u,3908503585u,3929842945u,3956345185u,3958461865u,3959719765u,3987784945u,4015894485u,4016054485u,4017065185u,4020221245u,4020330385u,4020744981u,4024696705u,4028398585u,4056093445u,4089165445u,4097797341u,4105241481u,4133718505u,4153698865u,4157970501u,4160578521u,4173593905u,4188153865u,4192137505u,4202755165u,4205689705u,4218989545u,4238700985u,4239832521u,4268757921u,4280622865u
};

/* Here are the 9366 base-2 Fermat pseudoprimes < 2^32 not divisible by 3 or 5: */
const uint32 f2psp[9366] = {
	341u,1387u,1729u,2047u,2701u,2821u,3277u,4033u,4369u,4681u,5461u,6601u,7957u,8321u,8911u,10261u,13741u,13747u,13981u,14491u,15709u,15841u,18721u,19951u,23377u,29341u,30121u,30889u,31417u,31609u,31621u,35333u,41041u,42799u,46657u,49141u,49981u,52633u,57421u,60701u,60787u,63973u,65077u,65281u,68101u,75361u,80581u,83333u,85489u,88357u,88561u,90751u,91001u,93961u,101101u,104653u,113201u,115921u,123251u,126217u,129889u,130561u,137149u,149281u,150851u,158369u,162193u,162401u,164737u,172081u,176149u,181901u,188057u,188461u,194221u,196021u,196093u,204001u,215749u,219781u,220729u,226801u,228241u,233017u,241001u,249841u,252601u,253241u,256999u,258511u,264773u,271951u,272251u,275887u,276013u,280601u,282133u,284581u,285541u,294271u,
	294409u,314821u,318361u,323713u,334153u,340561u,341497u,348161u,357761u,367081u,387731u,390937u,396271u,399001u,401401u,410041u,422659u,423793u,435671u,443719u,448921u,452051u,458989u,476971u,481573u,486737u,488881u,489997u,493697u,512461u,513629u,514447u,530881u,534061u,552721u,556169u,563473u,574561u,574861u,580337u,582289u,587861u,604117u,611701u,617093u,622909u,625921u,635401u,642001u,647089u,653333u,657901u,658801u,665281u,665333u,665401u,670033u,672487u,679729u,680627u,683761u,688213u,710533u,711361u,721801u,722201u,722261u,729061u,738541u,741751u,742813u,745889u,748657u,769567u,769757u,786961u,818201u,838201u,838861u,841681u,847261u,852481u,852841u,873181u,875161u,877099u,916327u,934021u,950797u,976873u,983401u,997633u,1004653u,1016801u,1018921u,1023121u,1024651u,1033669u,1052503u,1052929u,
	1053761u,1064053u,1073021u,1082401u,1082809u,1092547u,1093417u,1104349u,1109461u,1128121u,1132657u,1139281u,1141141u,1145257u,1152271u,1157689u,1168513u,1193221u,1194649u,1207361u,1251949u,1252697u,1277179u,1293337u,1302451u,1306801u,1325843u,1333333u,1357441u,1357621u,1373653u,1397419u,1398101u,1419607u,1433407u,1441091u,1457773u,1459927u,1461241u,1463749u,1472353u,1493857u,1500661u,1507561u,1507963u,1509709u,1530787u,1533601u,1533961u,1534541u,1537381u,1549411u,1569457u,1579249u,1584133u,1615681u,1678541u,1690501u,1711381u,1719601u,1730977u,1735841u,1746289u,1755001u,1773289u,1801969u,1809697u,1811573u,1826203u,1827001u,1837381u,1839817u,1840357u,1857241u,1876393u,1896961u,1907851u,1909001u,1937881u,1969417u,1987021u,1993537u,1994689u,2004403u,2008597u,2035153u,2081713u,2085301u,2089297u,2100901u,2113921u,2121301u,2134277u,2144521u,2163001u,2165801u,2171401u,2181961u,2184571u,2205967u,
	2233441u,2261953u,2264369u,2269093u,2284453u,2299081u,2304167u,2313697u,2327041u,2350141u,2387797u,2433601u,2434651u,2455921u,2487941u,2491637u,2503501u,2508013u,2510569u,2528921u,2537641u,2603381u,2609581u,2615977u,2617451u,2626177u,2628073u,2649029u,2649361u,2670361u,2704801u,2719981u,2722681u,2746477u,2746589u,2748023u,2757241u,2773981u,2780731u,2797921u,2811271u,2827801u,2867221u,2880361u,2899801u,2909197u,2921161u,2940337u,2944261u,2953711u,2976487u,2977217u,2987167u,3048841u,3057601u,3059101u,3073357u,3090091u,3094273u,3116107u,3125281u,3146221u,3165961u,3186821u,3225601u,3235699u,3316951u,3336319u,3337849u,3345773u,3363121u,3375041u,3375487u,3400013u,3413533u,3429037u,3471071u,3539101u,3542533u,3567481u,3568661u,3581761u,3605429u,3656449u,3679201u,3726541u,3755521u,3763801u,3814357u,3828001u,3898129u,3911197u,3916261u,3936691u,3985921u,4005001u,4014361u,4038673u,4069297u,4072729u,
	4082653u,4097791u,4101637u,4151869u,4154161u,4154977u,4181921u,4188889u,4209661u,4314967u,4335241u,4360621u,4361389u,4363261u,4415251u,4463641u,4469471u,4480477u,4504501u,4513841u,4567837u,4650049u,4670029u,4682833u,4698001u,4706821u,4714201u,4767841u,4806061u,4827613u,4835209u,4863127u,4864501u,4868701u,4869313u,4877641u,4903921u,4909177u,4917331u,4917781u,4922413u,4974971u,4984001u,5016191u,5031181u,5034601u,5044033u,5049001u,5095177u,5131589u,5148001u,5173169u,5173601u,5176153u,5187637u,5193721u,5250421u,5256091u,5258701u,5271841u,5284333u,5310721u,5351537u,5423713u,5444489u,5456881u,5481451u,5489641u,5524693u,5551201u,5575501u,5590621u,5672041u,5681809u,5733649u,5758273u,5766001u,5804821u,5859031u,5872361u,5919187u,5968261u,5968873u,5977153u,6027193u,6049681u,6118141u,6122551u,6140161u,6159301u,6183601u,6189121u,6226193u,6233977u,6236257u,6236473u,6255341u,6278533u,6309901u,6313681u,
	6334351u,6350941u,6368689u,6386993u,6474691u,6539527u,6617929u,6631549u,6658669u,6732817u,6733693u,6749021u,6779137u,6787327u,6836233u,6840001u,6868261u,6886321u,6912079u,6952037u,6955541u,6973057u,6973063u,6998881u,7008001u,7017193u,7207201u,7215481u,7232321u,7259161u,7273267u,7295851u,7306261u,7306561u,7414333u,7416289u,7428421u,7429117u,7455709u,7462001u,7516153u,7519441u,7546981u,7656721u,7674967u,7725901u,7759937u,7803769u,7808593u,7814401u,7820201u,7883731u,7995169u,8036033u,8043841u,8095447u,8134561u,8137633u,8180461u,8209657u,8231653u,8239477u,8280229u,8321671u,8341201u,8355841u,8362201u,8384513u,8388607u,8462233u,8534233u,8640661u,8646121u,8650951u,8719309u,8719921u,8725753u,8727391u,8745277u,8812273u,8830801u,8902741u,8916251u,8927101u,8992201u,9006401u,9037729u,9040013u,9046297u,9056501u,9069229u,9073513u,9084223u,9106141u,9131401u,9143821u,9273547u,9345541u,9371251u,9439201u,
	9480461u,9494101u,9533701u,9564169u,9567673u,9585541u,9588151u,9591661u,9613297u,9692453u,9724177u,9729301u,9774181u,9834781u,9863461u,9890881u,9908921u,9920401u,9995671u,10004681u,10024561u,10031653u,10033777u,10079521u,10084177u,10134601u,10185841u,10226161u,10251473u,10266001u,10267951u,10317601u,10323769u,10331141u,10386241u,10393201u,10402237u,10402561u,10403641u,10425511u,10505701u,10513261u,10545991u,10606681u,10610063u,10635751u,10700761u,10712857u,10763653u,10802017u,10837321u,10877581u,10956673u,10958221u,10974881u,11075857u,11081459u,11115037u,11157721u,11205601u,11328409u,11335501u,11367137u,11433301u,11541307u,11585293u,11592397u,11644921u,11767861u,11777599u,11972017u,12032021u,12096613u,12261061u,12262321u,12263131u,12273769u,12322133u,12327121u,12376813u,12407011u,12490201u,12498061u,12584251u,12599233u,12643381u,12659989u,12711007u,12757361u,12783811u,12854437u,12932989u,12936763u,12939121u,13057787u,13073941u,13216141u,13295281u,13333441u,13338371u,
	13357981u,13421773u,13446253u,13448593u,13500313u,13554781u,13635289u,13635649u,13694761u,13696033u,13747361u,13757653u,13773061u,13838569u,13856417u,13942081u,13971841u,13991647u,13996951u,14012797u,14026897u,14154337u,14179537u,14282143u,14324473u,14469841u,14589901u,14609401u,14671801u,14676481u,14684209u,14709241u,14794081u,14796289u,14865121u,14870801u,14898631u,14899751u,14913991u,14980411u,15082901u,15101893u,15124969u,15139199u,15162941u,15188557u,15207361u,15220951u,15247621u,15248773u,15268501u,15472441u,15479777u,15510041u,15525241u,15560461u,15583153u,15603391u,15621409u,15698431u,15700301u,15716041u,15732721u,15757741u,15802681u,15829633u,15888313u,15913261u,15976747u,15978007u,16046641u,16053193u,16070429u,16132321u,16149169u,16149601u,16153633u,16158331u,16324001u,16349477u,16360381u,16435747u,16539601u,16666651u,16705021u,16717061u,16773121u,16778881u,16818877u,16822081u,16843009u,16853077u,16879501u,16973393u,16998961u,17020201u,17098369u,17116837u,17134043u,17208601u,
	17236801u,17316001u,17327773u,17375249u,17405537u,17429861u,17450569u,17509501u,17585969u,17586361u,17590957u,17641207u,17698241u,17759681u,17777191u,17812081u,17870561u,17895697u,18003349u,18067501u,18073817u,18151861u,18162001u,18300241u,18307381u,18366937u,18443701u,18454921u,18468901u,18487267u,18490381u,18535177u,18541441u,18595801u,18607009u,18653353u,18736381u,18740971u,18779761u,18900973u,18985627u,19020191u,19054933u,19149571u,19328653u,19384289u,19404139u,19471033u,19607561u,19683001u,19734157u,19985269u,20081953u,20099017u,20117467u,20140129u,20202481u,20234341u,20261251u,20417311u,20489239u,20647621u,20770621u,20964961u,20968501u,21042001u,21224401u,21303343u,21306157u,21355951u,21359521u,21397381u,21400481u,21414169u,21417991u,21459361u,21474181u,21559741u,21585313u,21623659u,21654533u,21715681u,21789901u,21814417u,21880801u,21907009u,22066201u,22075579u,22087477u,22137809u,22203181u,22215961u,22351249u,22369621u,22397497u,22432201u,22480381u,22487101u,22509691u,22513457u,
	22564081u,22591301u,22669501u,22711873u,22848541u,22849481u,22885129u,22899097u,22953673u,23247901u,23261713u,23283037u,23286781u,23315977u,23382529u,23386441u,23405341u,23464033u,23577497u,23634181u,23734901u,23808721u,23822329u,23828017u,23872213u,23963869u,23966011u,24037021u,24158641u,24214051u,24356377u,24726773u,24776557u,24904153u,24913681u,24929281u,25080101u,25150501u,25276421u,25326001u,25457833u,25520833u,25540291u,25557121u,25603201u,25629913u,25640641u,25696133u,25768261u,25840081u,25846913u,25873381u,25909453u,25947959u,26254801u,26280073u,26377921u,26465089u,26470501u,26474581u,26553241u,26634301u,26758057u,26813221u,26821601u,26840269u,26877421u,26886817u,26921089u,26932081u,26977001u,27062101u,27108397u,27118601u,27128201u,27168337u,27218269u,27219697u,27271151u,27279409u,27331921u,27336673u,27380831u,27392041u,27401401u,27402481u,27409541u,27476641u,27491237u,27492581u,27509653u,27600001u,27664033u,27700609u,27714961u,27798461u,27808463u,27846721u,27966709u,28011001u,
	28029001u,28071121u,28172629u,28312921u,28325881u,28406953u,28449961u,28527049u,28572961u,28629613u,28717483u,29020321u,29111881u,29137021u,29143633u,29214541u,29581501u,29593159u,29732221u,29878381u,30022129u,30058381u,30069721u,30090817u,30185569u,30219757u,30295141u,30296761u,30338593u,30388753u,30418957u,30529693u,30576151u,30662497u,30718441u,30739969u,30740417u,30881551u,30894307u,30951181u,30958201u,30971161u,30992401u,30996001u,31040833u,31118221u,31146661u,31150351u,31166803u,31198693u,31405501u,31436123u,31735621u,31759121u,31766983u,31794241u,32080651u,32091781u,32095057u,32158621u,32168117u,32264029u,32285041u,32368609u,32497921u,32676481u,32701297u,32756581u,32899201u,32914441u,33146717u,33193117u,33298337u,33302401u,33596641u,33600533u,33627301u,33704101u,33840397u,33848311u,33872593u,33965261u,34003061u,34043101u,34100821u,34111441u,34124641u,34196401u,34386121u,34540801u,34581457u,34657141u,34856167u,34890481u,34901461u,34944001u,35428141u,35498467u,35571601u,35576599u,
	35626501u,35703361u,35820937u,35851037u,35926801u,35932441u,35976721u,36255451u,36291193u,36307981u,36338653u,36354449u,36448387u,36721021u,36724591u,36765901u,36852481u,36861901u,36919681u,36942157u,36974341u,36981601u,37109467u,37167361u,37280881u,37376509u,37439201u,37469701u,37491301u,37727341u,37769887u,37938901u,37962541u,37964809u,37988497u,38010307u,38046817u,38118763u,38151361u,38171953u,38210323u,38239741u,38342071u,38404501u,38439523u,38560861u,38584801u,38624041u,38637361u,38801089u,38903287u,38971661u,39016741u,39052333u,39117439u,39126313u,39465091u,39467377u,39512773u,39573073u,39655153u,39684157u,39789841u,40094341u,40160737u,40165093u,40238797u,40315441u,40325041u,40361197u,40374901u,40430401u,40622401u,40629601u,40778989u,40782589u,40801861u,40827473u,40841821u,40917241u,40928701u,40987201u,41017681u,41073241u,41121433u,41262073u,41341321u,41396921u,41471521u,41541241u,41568101u,41590297u,41604109u,41607721u,41642681u,41662297u,41840809u,41866001u,41987111u,42009217u,
	42344609u,42485119u,42490801u,42623017u,42694279u,42697873u,42702661u,42709591u,42763501u,42984589u,43039501u,43136821u,43224397u,43235641u,43286881u,43331401u,43363601u,43397551u,43584481u,43620409u,43661257u,43798457u,43914949u,44070841u,44081101u,44238481u,44314129u,44347381u,44465221u,44472001u,44482901u,44521301u,44671001u,44695211u,44731051u,44823241u,44824501u,44912701u,44953441u,44963029u,45100177u,45175201u,45219329u,45393601u,45414433u,45485881u,45563027u,45819541u,45830161u,45877861u,45879941u,45890209u,46045117u,46055851u,46094401u,46104697u,46256489u,46325029u,46386589u,46469809u,46483633u,46517857u,46657181u,46679761u,46860001u,46878601u,47063611u,47220367u,47253781u,47349373u,47356171u,47647117u,47734141u,47744209u,47759041u,47903701u,47918581u,47930023u,47953621u,48064021u,48191653u,48269761u,48277081u,48316321u,48316969u,48321001u,48369727u,48400753u,48448661u,48462301u,48506581u,48551161u,48563089u,48592393u,48628801u,48650641u,48656869u,49075417u,49084321u,49303801u,
	49333201u,49411801u,49439237u,49459801u,49472281u,49664207u,50155733u,50176477u,50193793u,50201089u,50376019u,50443201u,50473501u,50523661u,51030601u,51129781u,51283501u,51302353u,51340807u,51500521u,51509161u,51627817u,51803821u,52072021u,52119289u,52142221u,52181407u,52204237u,52365457u,52869601u,53154337u,53245921u,53283169u,53399449u,53542147u,53560801u,53656021u,53675623u,53695721u,53711113u,53728921u,53795521u,54029741u,54060721u,54177949u,54215161u,54448153u,54449431u,54468001u,54545821u,54651961u,54767881u,54772381u,55035001u,55109401u,55176097u,55200181u,55318957u,55324801u,55462177u,55610837u,55729957u,56052361u,56420033u,56479897u,56608201u,56643181u,56669041u,56687821u,56810137u,57172501u,57421219u,57707209u,57762433u,58003213u,58422409u,58449847u,58489201u,58509977u,58679941u,58755877u,58903741u,59408497u,59426221u,59469697u,59586241u,59589973u,59631211u,59840537u,59913157u,59953741u,59955331u,59999011u,60155201u,60352921u,60514129u,60547831u,60558841u,60566431u,60581401u,
	60696661u,60738257u,60761701u,60769051u,60925879u,60957361u,60998653u,61198921u,61201009u,61219789u,61309333u,61330291u,61377109u,61754941u,61755751u,61794709u,61832377u,62176661u,62248649u,62289541u,62490901u,62633371u,62756641u,63001801u,63002501u,63065281u,63127681u,63167743u,63294553u,63318169u,63328469u,63337393u,63346999u,63388033u,63526519u,63729073u,63781901u,63884521u,63919801u,64009261u,64148717u,64162693u,64238021u,64377991u,64477249u,64605041u,64735897u,64774081u,64940041u,65037817u,65144501u,65241793u,65254393u,65301013u,65350801u,65359477u,65427701u,65523781u,65565457u,66024901u,66096253u,66296401u,66384121u,66760471u,66790057u,66849091u,66886417u,66932851u,66976273u,66977281u,67194401u,67213801u,67529437u,67541761u,67559383u,67642513u,67653433u,67763803u,67902031u,67928221u,67940449u,67994641u,68033801u,68075177u,68102641u,68154001u,68165761u,68275873u,68512867u,68621701u,68776561u,68800501u,68830021u,68839597u,69030901u,69128641u,69176647u,69228967u,69231061u,69331969u,
	69414301u,69485281u,69612061u,69615793u,69678307u,69705529u,69741001u,69885649u,69917371u,70006021u,70030501u,70147561u,70149631u,70195501u,70461331u,70463489u,70488001u,70541099u,70561921u,70593931u,70626301u,70695769u,70728121u,71079661u,71107681u,71570017u,71572957u,71711839u,71734417u,71804161u,72108421u,72286501u,72348409u,72498253u,72543547u,72595951u,72680431u,72734041u,72803809u,72805981u,72884701u,73522051u,73562833u,73645001u,73721341u,73988641u,74193769u,74217487u,74329399u,74411131u,74658629u,74705401u,74874869u,74927161u,74945953u,75140137u,75143251u,75151441u,75187669u,75501793u,75565873u,75676861u,75681541u,75765313u,75927853u,76595761u,76704433u,76725091u,76745101u,76923461u,76969621u,77295961u,77334769u,77477401u,77518981u,77533123u,77576401u,77594653u,77648941u,77812153u,77817979u,77826001u,77858221u,78073801u,78091201u,78120001u,78206917u,78526729u,78671651u,78795181u,78844801u,78905989u,78939089u,79398901u,79411201u,79417801u,79464533u,79525261u,79539197u,79624621u,
	79625701u,79739713u,79786523u,79854409u,79895401u,80142761u,80146909u,80282161u,80375707u,80556337u,80687881u,80787421u,80891009u,80918281u,80927821u,81189433u,81433591u,81480601u,81638401u,81680941u,81789301u,81926461u,81954133u,82023649u,82139471u,82219801u,82268033u,82273201u,82279741u,82416101u,82452061u,82506439u,82870517u,82882753u,82929001u,82995421u,83058481u,83083001u,83099521u,83103329u,83204801u,83814151u,83966401u,84164033u,84311569u,84350561u,84375761u,84421081u,84487457u,84758389u,84809521u,84998503u,85030921u,85207669u,85328717u,85374577u,85400701u,85519337u,85759147u,85761481u,85823401u,85875361u,86027329u,86067241u,86114117u,86204977u,86438857u,86484269u,86530621u,86968981u,86999837u,87211573u,87318001u,87483241u,87499651u,87558127u,87571121u,87694261u,88099339u,88123141u,88256449u,88368853u,88407361u,88466521u,88615801u,88661861u,88689601u,88735921u,88930463u,89244901u,89308771u,89670001u,89784581u,89896717u,89961421u,90014653u,90270613u,90278161u,90341197u,90532141u,
	90665789u,90670861u,90698401u,90803429u,91367431u,91433281u,91587289u,91659283u,92139433u,92438581u,92625121u,92631001u,92645437u,92677273u,92829781u,92974921u,93431521u,93473953u,93541537u,93571633u,93591721u,93614521u,93643201u,93677761u,93839201u,93845161u,93926197u,94316401u,94502701u,94536001u,94790401u,95053249u,95200561u,95423329u,95451361u,95452781u,96135601u,96259681u,96271681u,96618397u,96791881u,96888641u,96895441u,96904081u,96916279u,96925921u,97047301u,97255801u,97420141u,97496449u,97655933u,97676723u,97796953u,97863529u,97924217u,98124481u,98523877u,98586541u,98602381u,98735209u,98756281u,99036001u,99115297u,99486889u,99551881u,99789673u,99830641u,99898801u,99945007u,99971821u,100017223u,100302301u,100359337u,100427041u,100462141u,100463443u,100618933u,100860997u,100907047u,100943201u,101141461u,101152133u,101158093u,101218921u,101270251u,101276579u,101592973u,101612641u,101649241u,101929681u,101954077u,101957401u,102004421u,102090781u,102134113u,102237721u,102443749u,102678031u,102690677u,102690901u,
	102696901u,102757501u,102922117u,102940993u,103022551u,103301633u,104078857u,104086801u,104233141u,104404861u,104484601u,104524421u,104569501u,104852881u,104857391u,104891761u,104988673u,105007549u,105085981u,105117481u,105305443u,105309289u,105517621u,105569101u,105869401u,105919633u,105941851u,106041937u,106169761u,106402801u,106485121u,106622353u,106743073u,106775761u,107085007u,107101513u,107264521u,107360641u,107543333u,107714881u,108145741u,108150661u,108596953u,108870961u,108927721u,108952411u,109052113u,109118791u,109231229u,109316593u,109322501u,109393201u,109437751u,109541461u,109577161u,109879837u,110135821u,110139499u,110301121u,110312773u,110413333u,110495083u,110717861u,110851741u,111202297u,111291181u,111370141u,111654401u,111837181u,112032001u,112402981u,112792519u,112828801u,112844131u,113352401u,113359321u,113589601u,113605201u,113730481u,113886361u,113892589u,114046381u,114305441u,114329881u,114362281u,114469073u,114507121u,114701341u,114712753u,114842677u,114910489u,115007581u,115039081u,115085701u,115174681u,115196033u,115497901u,115582741u,115595701u,115756201u,
	115804501u,115873801u,116090081u,116148649u,116151661u,116321617u,116463007u,116617289u,116682721u,116696161u,116964289u,116998669u,117246949u,117251641u,117445987u,117744901u,117959221u,117987841u,118216981u,118466401u,118634977u,118712881u,118886401u,118901521u,119051101u,119074501u,119092801u,119118121u,119204809u,119261113u,119273701u,119327041u,119378351u,119558011u,119743537u,119811601u,119940853u,120296677u,120517021u,120557053u,120570409u,120838609u,120981601u,121062001u,121128361u,121247281u,121374241u,121422301u,121472359u,121609489u,122166307u,122396737u,122401441u,122569993u,122649901u,122785741u,122941981u,123054841u,123191797u,123330371u,123481777u,123559837u,123671671u,123718861u,123877081u,123886003u,123987793u,124071977u,124116763u,124145473u,124593301u,124630273u,124793521u,124818601u,125284141u,125686241u,125707681u,125739361u,125848577u,126132553u,126619741u,126682753u,126886447u,127050067u,127306081u,127479097u,127664461u,127710563u,128027831u,128079409u,128124151u,128396921u,128468957u,128536561u,128622781u,128626219u,128665319u,128697361u,128987429u,129205781u,
	129255841u,129256273u,129357061u,129461617u,129524669u,129569881u,129604321u,129762001u,129812761u,129924451u,130497361u,130513429u,130556329u,130651753u,130693393u,130766239u,130922221u,130944133u,131023201u,131117941u,131421541u,131567929u,131701921u,131821747u,131922701u,131938561u,132239521u,132332201u,132338881u,132440521u,132511681u,132575071u,132841369u,132901561u,132915601u,133157701u,133205761u,133216381u,133302781u,133344793u,133427449u,133467517u,133496221u,133800661u,134188381u,134384069u,134564501u,134696801u,134767153u,134809921u,134857801u,134868029u,135263269u,135296053u,135308881u,135437129u,135866017u,135945853u,135969401u,136043641u,136217251u,136545067u,136578421u,136625941u,136645561u,136661201u,136722433u,137345221u,137415821u,137763037u,137897881u,137972561u,138012733u,138030721u,138223009u,138280381u,138336661u,138403981u,138511441u,138652921u,138736153u,138828821u,139133611u,139295701u,139319293u,139363927u,139487041u,139592101u,139952671u,140047921u,140167729u,140197051u,140201569u,140241361u,140249201u,140285377u,140296861u,140710421u,140723401u,140996401u,
	141165361u,141574219u,142525333u,142825033u,142922413u,143071601u,143106133u,143168581u,143258689u,144014833u,144093313u,144218341u,145082201u,145206361u,145334821u,145348529u,145856701u,146023351u,146156617u,146272901u,146659801u,146843929u,146884393u,147028001u,147269251u,147287141u,147868201u,148087801u,148109473u,148171769u,148392781u,148705481u,148910653u,149065489u,149069989u,149389633u,149762017u,149796001u,150017401u,150260893u,150379693u,150418801u,150846961u,150886681u,150960239u,150966901u,150988753u,151530401u,151533377u,151589881u,151813201u,152192041u,152255611u,152486551u,152716537u,152922001u,152991841u,153365521u,153369061u,153384661u,153393637u,153449101u,153589801u,153754873u,153927961u,153928133u,153958321u,154045801u,154195801u,154287451u,154364221u,154513633u,154910869u,154944533u,155094121u,155102221u,155156581u,155203361u,155255881u,155358529u,155840777u,156114061u,156226321u,156532799u,156538201u,157010389u,157069189u,157368661u,157405249u,157725829u,157731841u,157852201u,158068153u,158115721u,158192317u,158397247u,158404141u,158496911u,158544401u,158864833u,
	158895281u,159412051u,159420457u,159492061u,159874021u,160348189u,160378861u,160491329u,160587841u,160672201u,160730389u,161035057u,161109613u,161184013u,161216021u,161289649u,161293249u,161304001u,161341181u,161369101u,161423377u,161498681u,161913961u,162026869u,162067441u,162690481u,162771337u,162776041u,163021423u,163442551u,163759753u,163849393u,163954561u,164008321u,164111281u,164391481u,164916001u,165061909u,165224321u,165479113u,165538447u,165654721u,165886561u,165892501u,165938653u,166082309u,166099501u,166339057u,166406561u,166444181u,166724041u,166827943u,167188861u,167579497u,167582377u,167692141u,167881121u,167958961u,167979421u,168132601u,168566501u,168659569u,169004921u,169057801u,169570801u,169655641u,169930549u,170640961u,170782921u,170853211u,170856533u,171068893u,171149749u,171438001u,171454321u,171567481u,171679561u,171747577u,171804061u,171823693u,172028053u,172116181u,172272187u,172290241u,172295761u,172430401u,172436713u,172596601u,172947529u,173085121u,173401621u,173405233u,173928601u,174156481u,174479729u,174638419u,174769621u,175313401u,175484291u,175656601u,
	175747457u,176030977u,176571089u,176597821u,176609441u,176659201u,176977921u,177167233u,177254533u,177349147u,177693521u,177702241u,177927641u,177951973u,178451857u,178482151u,178837201u,178956971u,179083601u,179285137u,179695321u,179820257u,180115489u,180497633u,180703451u,180801253u,181111951u,181154701u,181234801u,181285001u,181285537u,181299811u,181382401u,181397161u,181449073u,181542601u,181647497u,181870591u,182082901u,182356993u,182383111u,182688661u,183349453u,183502369u,183554407u,183677341u,183739141u,183788161u,184353001u,184411567u,184527101u,185203921u,185206757u,185265809u,185365141u,185653333u,185697121u,186183469u,186393481u,186654241u,186739057u,186782401u,186846301u,186983521u,187050529u,187155383u,187188001u,187667969u,187761241u,187823141u,188082301u,188382487u,188481601u,188516329u,188519653u,188689501u,188719381u,188821951u,188985961u,189184661u,189714193u,189738361u,189941761u,190212181u,190382161u,190667851u,190824817u,190913297u,191191933u,191233813u,191326141u,191648161u,191752093u,191981609u,192070081u,192081097u,192112921u,192346153u,192857761u,192920161u,
	193004281u,193009861u,193330237u,193638337u,193708801u,193816351u,193910977u,193949641u,194120389u,194296369u,194523121u,194556451u,194675041u,195412621u,195475351u,195827521u,196035001u,196049701u,196231393u,196358977u,196958161u,197168401u,197200201u,197466361u,197526421u,197747377u,197781221u,198982759u,199674721u,200143351u,200453401u,200479301u,200753281u,201081001u,201246139u,201261061u,201646801u,201789127u,202006441u,202130197u,202156813u,202538857u,202900021u,203049721u,203215297u,203269177u,203331877u,203505697u,203789951u,203875001u,203886241u,204280501u,204582457u,204669829u,204766381u,204821401u,205057561u,205374961u,205534681u,205997401u,206028271u,206304961u,206453509u,206472961u,206504033u,206529737u,206623873u,206804701u,206955841u,207008569u,207030541u,207104041u,207132481u,207399917u,207477001u,207487561u,207618781u,207767281u,208051201u,208096681u,208474669u,208715221u,208965421u,208969201u,208969223u,209246701u,209404369u,209990881u,210431761u,210565981u,210592873u,210628657u,210636707u,210687841u,210842113u,211734271u,212007601u,212027401u,213035761u,213111163u,
	213228121u,213349039u,213350681u,213451549u,213545473u,213804191u,213835861u,214038533u,214110541u,214850881u,214852609u,214858717u,215036641u,215107201u,215436241u,215878531u,215957281u,215973001u,216431041u,216821881u,217123069u,217145881u,217472501u,217517653u,217875571u,218321797u,218603617u,218642029u,218698921u,218947121u,219621781u,219716641u,220261861u,220507561u,220531501u,220883521u,221368153u,221415781u,221669953u,221884001u,222010721u,222123889u,222354721u,222436501u,222524347u,222630193u,223435261u,223449463u,223625851u,223782263u,223846129u,224074369u,224080921u,224136013u,224460181u,224578081u,224582221u,224617541u,224769241u,224957893u,225000007u,225028117u,225651469u,225853633u,226359547u,226450297u,226509361u,227132641u,227319001u,227444101u,227475481u,227518271u,227752993u,228652201u,228842209u,228988033u,229330441u,229589413u,229906711u,230029021u,230357761u,230630401u,230879041u,231383461u,231405701u,231575761u,231638797u,231821659u,231927781u,232114433u,232265881u,232460821u,232674541u,232771501u,232794253u,233082331u,233110081u,233424841u,233812657u,234420481u,
	234564829u,234691381u,234743041u,234869009u,234870301u,235426913u,235476697u,235562041u,235742513u,235928071u,236530981u,237023281u,237570191u,237597361u,237791143u,237984241u,237994381u,238001653u,238199941u,238244041u,238432201u,238565713u,238568749u,238833421u,239194171u,239582401u,239604301u,239612297u,240068041u,240175321u,240371713u,240694513u,240785047u,240982561u,241031701u,241048081u,241180369u,241242001u,241477039u,241505377u,241533527u,241927861u,241955701u,242067841u,242131889u,242214721u,242239321u,242641153u,242650717u,242729401u,242819809u,242860069u,243583201u,243829261u,243955141u,244175779u,244306151u,244528561u,244883981u,244973431u,245006623u,245388781u,245950561u,245956501u,246099317u,246282511u,246434761u,246446929u,246658441u,246975481u,247095361u,247318957u,247321301u,247416101u,247536811u,247704757u,247800709u,248290927u,249582481u,249679501u,249993101u,250200721u,250385401u,250436033u,250612831u,250707073u,250958401u,250988173u,251528401u,251663837u,251737993u,251855893u,252141121u,252778681u,252853921u,253571291u,253610281u,253880641u,253893397u,255160621u,
	255318001u,255416897u,255955393u,256192861u,256828321u,256831433u,256901569u,256979609u,257059279u,257495641u,257590661u,257595457u,257725693u,258020473u,258043229u,258172333u,258234401u,258434749u,258634741u,258676741u,258910513u,258943741u,258944401u,259763093u,259765747u,259913501u,260005141u,260035741u,260156101u,260518801u,260736341u,260963389u,261186001u,261312481u,261430237u,261523801u,261598213u,261703417u,261870841u,261938561u,262700137u,262979501u,263428181u,264269449u,264350521u,264384469u,264724201u,265020001u,265584133u,265728101u,265735969u,265836161u,266003101u,266462701u,266790481u,266811169u,266925601u,266983501u,267559627u,268359001u,268505089u,268554313u,268787701u,269053681u,269081509u,269392201u,269470501u,269800741u,269953489u,270495841u,270525737u,270857521u,271272569u,271481329u,271682651u,271763467u,271794601u,271826629u,271950829u,272223557u,272263501u,272786737u,272946241u,272973517u,273361789u,273480637u,273769921u,273853801u,274455457u,274566721u,274569601u,274683421u,274701913u,274810241u,274919401u,275283401u,275529559u,275619961u,275933281u,276018913u,
	276131137u,276542401u,276638321u,276693121u,277241401u,277739767u,277787141u,277897813u,278152381u,278388881u,278943061u,279377281u,279729661u,280067761u,280761481u,280885153u,281719351u,282240721u,282253141u,282471853u,282599101u,282707461u,282721297u,282769771u,283900961u,283936001u,284166877u,284301751u,284631061u,284666111u,284736091u,284830273u,284834299u,285212689u,285600601u,285820501u,286065571u,286316801u,287160301u,287449091u,287715121u,288099001u,288117721u,288120421u,288728761u,288735277u,289109941u,289765981u,289766701u,289795837u,289860481u,290020061u,290344753u,290495101u,290643601u,290706781u,290743459u,290953921u,291088513u,291461633u,291848401u,292153681u,292236841u,292244833u,292290181u,292433321u,292776121u,292902481u,293346637u,293847721u,293938261u,294184801u,294911401u,295308433u,295419097u,295643089u,295665409u,295743017u,295826581u,295981687u,296023729u,296509357u,296559361u,296639869u,297411661u,297624961u,297798961u,297812677u,298212601u,298811017u,299041381u,299367877u,299671921u,299736181u,300614161u,301030801u,301068001u,301413001u,302214817u,302560501u,
	302635351u,303373801u,303532201u,303639337u,303817411u,303899149u,304080001u,304875553u,304929613u,305594101u,305897131u,306143647u,306703801u,306842401u,306859861u,306871201u,307367171u,307629401u,307694323u,307972801u,308119141u,308448649u,308483209u,308550061u,308980321u,309666361u,310302901u,310474249u,310585771u,310978027u,311157901u,311177213u,311295601u,311297701u,311388337u,311411629u,311655829u,311671361u,312408113u,312614021u,312703093u,312890689u,313338061u,313533529u,313748611u,313980913u,314184487u,314292889u,314721001u,314970121u,315034513u,315145477u,315351521u,316126081u,316349281u,317137969u,317365933u,317501401u,317520401u,317641171u,317657341u,317796119u,318266641u,319053281u,319161361u,319374577u,319440769u,319726177u,320326003u,320454751u,320819941u,320894687u,321324589u,321524281u,321602401u,321831181u,321850849u,322020973u,322469701u,322941881u,323192521u,323654041u,323901007u,324171541u,324477697u,325028089u,325352101u,325546873u,325645321u,325842481u,326266051u,326405713u,326469137u,326628721u,326694301u,326695141u,326695357u,326854981u,327073601u,327093409u,
	327201121u,327398009u,327642613u,328098601u,328135051u,328302901u,328375501u,328573477u,328719601u,329153653u,329326621u,329558329u,329725981u,329769721u,329788981u,330133321u,330198331u,330396701u,330759617u,331240001u,331458739u,331658081u,331934989u,332162521u,332448229u,332737121u,332981293u,333229141u,333619357u,333801937u,333874333u,334849321u,335429641u,335480759u,336098957u,336183697u,337135501u,337420679u,337665901u,337783981u,337799701u,338018617u,338125537u,338395681u,338455153u,338458807u,338740417u,338896369u,338914369u,339006841u,339023833u,339195097u,339396401u,339492169u,339780041u,339794641u,339858541u,341174821u,341505829u,341958121u,341994131u,342838313u,343017529u,343052833u,343915321u,344040061u,344201441u,344255551u,344776301u,346080391u,346808881u,347347087u,347540401u,348089281u,348140881u,348989101u,349369021u,349752913u,350015257u,350031973u,350244577u,350638597u,351058753u,351143101u,351177769u,351593899u,352418041u,352802803u,352932337u,353815801u,353932801u,354062809u,354099089u,354313441u,354815761u,354938221u,355033729u,355552561u,356037241u,356604421u,
	356836819u,357277921u,357348601u,357380101u,357872971u,358416577u,358554841u,358856641u,358940737u,359112857u,359394751u,359499781u,359727073u,360018361u,360067201u,360145633u,360375181u,360787771u,361223941u,361307521u,361312337u,361430161u,361536869u,362569201u,363170837u,363245581u,363430637u,364155793u,364209199u,364282381u,364550761u,364590721u,364637701u,364857751u,364992481u,365077373u,365231401u,365461741u,365932297u,366069601u,366333613u,366487201u,366532321u,366652201u,367328977u,367559501u,367632301u,367649569u,367804801u,368016949u,368113411u,368476501u,369269551u,369372193u,369667561u,369930133u,369985681u,370851481u,370988521u,371011801u,371611153u,372128149u,372167101u,373012777u,373241089u,373501441u,373533617u,373632673u,373647313u,373669453u,373906513u,374008321u,374296627u,374325841u,374346361u,374469847u,374636353u,374703127u,374988661u,375504791u,376261117u,376446889u,376957153u,377192353u,377199661u,377300557u,377334497u,377458849u,377616421u,377806687u,377869031u,378682537u,378792649u,379732501u,379843309u,380137633u,382304161u,382536001u,382837729u,383221033u,
	383425351u,383443201u,383813431u,383955481u,384046273u,384100001u,384824441u,385175113u,385319089u,385454161u,385606981u,385702681u,386563801u,387072661u,387082453u,387188561u,387833531u,388695301u,389064589u,389841661u,390357793u,390489121u,390507001u,390609941u,390612221u,390922741u,391014937u,391880497u,391938301u,392099401u,392534231u,392679737u,393122521u,393513121u,393611653u,393716701u,394255261u,394723177u,395044651u,395264101u,395900557u,396036877u,396539101u,396864469u,396899581u,397460911u,398661901u,398679121u,398724701u,399156661u,399302581u,399647221u,399906001u,400374253u,400385701u,400557109u,400748657u,400898233u,400943401u,401100881u,401518657u,402507769u,403043257u,403095421u,403095967u,403219201u,403293313u,403317421u,404496401u,404864701u,405042001u,405739681u,405782623u,406122361u,406544461u,407282851u,407737201u,407889161u,408344851u,408910133u,409090501u,409280851u,409302001u,409419811u,409458241u,409724569u,409927057u,410613809u,410680357u,411618241u,411782089u,411851389u,412659721u,412836689u,412919041u,413058601u,413138881u,413429801u,413778817u,414216461u,
	414368641u,414395281u,414395701u,415200361u,415204501u,415476343u,415770103u,415787041u,415878541u,416219161u,416964241u,416998207u,417027451u,417102767u,417275677u,417767201u,417779909u,417924361u,418019701u,418044563u,418226581u,418616161u,418617281u,418667401u,419065921u,419184481u,419394781u,419520241u,420468481u,420607441u,421121701u,421335721u,421942951u,422103133u,422372821u,422429041u,422594201u,422625391u,422928101u,423006781u,423122057u,423384001u,423465001u,423857701u,424165163u,424175761u,424411501u,424431541u,425671429u,425750689u,425794601u,425854241u,425967301u,426174101u,426219649u,426462997u,426770437u,426783811u,426821473u,426846577u,426876397u,427294141u,427750291u,428175073u,428180191u,428314531u,428373401u,428758201u,428965741u,429105041u,429135841u,429202541u,429509837u,430017701u,430046857u,430381921u,430646401u,430733701u,430733941u,430802101u,431230801u,431350561u,431975089u,432227449u,432347371u,434042801u,434330401u,434343601u,434932961u,435016187u,435267001u,435358657u,435648901u,435882901u,435993301u,436189051u,436465501u,437128861u,437247841u,437289029u,
	437462101u,437597101u,437866087u,438359041u,438740149u,439309261u,439331491u,439849181u,440219011u,440306461u,440359921u,441354497u,441650591u,441758461u,442050577u,442181291u,442543553u,442921609u,443708917u,444660421u,445102183u,445429693u,445448641u,446414621u,446619617u,447018521u,447191893u,447555361u,447884857u,447940141u,447949201u,448197589u,449372551u,449501761u,449881081u,450016901u,450612001u,450807481u,450866021u,450872573u,452178673u,452877841u,452990401u,453085381u,453366029u,453652381u,453967739u,454133953u,454302241u,454328281u,454607281u,454745773u,454934401u,455106601u,455193113u,455198563u,455398903u,455918257u,456082001u,457050361u,457274161u,457320533u,457376401u,457457617u,458140957u,458368201u,459127189u,459785089u,459817133u,460251733u,460336801u,460486921u,460585861u,461151121u,461272267u,461329601u,461502097u,461854261u,462199681u,462357739u,462587329u,462639409u,462701513u,462755521u,463161601u,463164451u,464012033u,464021641u,464169259u,464560921u,464790781u,464826781u,464955857u,465505633u,466290949u,466331041u,466679251u,466758181u,466998301u,467100937u,
	467430913u,467491753u,467832421u,468410113u,468663481u,468950021u,469832401u,470120257u,470122777u,470268137u,470579831u,470644021u,470896201u,471168253u,471275713u,471441001u,471535373u,471664513u,471812701u,471905281u,472443517u,472814413u,473581057u,473847121u,474892741u,474970501u,474983881u,475468927u,475723849u,476011901u,476301649u,476669557u,477006181u,478317601u,478614067u,479131969u,479317561u,479445613u,479489557u,479962009u,480668347u,481153501u,481239361u,481593997u,482082601u,482164597u,482417857u,482455717u,482488393u,482517217u,482823469u,482824669u,482921297u,483006889u,483029821u,483226741u,483351217u,483570301u,483786433u,483945601u,484200289u,484487641u,484662529u,484914001u,486063001u,486070213u,486902929u,486913681u,487855681u,487896601u,488062901u,488104681u,488169289u,488585521u,488656981u,488844301u,489994201u,490045501u,490057837u,490099681u,490378981u,490503601u,490518181u,490806121u,490950461u,491738801u,492291673u,492559141u,492805261u,492989281u,493108481u,493961737u,494288677u,494657791u,495062443u,495426541u,495909871u,496050841u,496109729u,496560349u,
	496803553u,497148599u,497163121u,497285713u,498059647u,498195961u,498434437u,498443401u,498662561u,498706651u,498905189u,499310197u,500117773u,500448821u,500747293u,501172241u,501423361u,501472333u,501497569u,502041931u,502541803u,502686713u,503080201u,503590573u,503758801u,504142381u,504187021u,504454879u,504870241u,505473263u,505532773u,505798213u,505955737u,506349421u,506852161u,507142567u,507206701u,507323521u,507726901u,507960001u,508606771u,509033161u,509302873u,509551201u,509776741u,509801183u,509822401u,510048529u,510825601u,510925609u,511009801u,511098521u,511215521u,511338241u,511611673u,512096761u,512330281u,512626201u,514044301u,514738981u,515199901u,515675161u,516045197u,516097051u,516259657u,516684961u,516764063u,517662001u,517937581u,518117041u,518216201u,518548801u,518706721u,521501473u,521972081u,521980201u,522390109u,522758233u,523551601u,523756711u,523842337u,524151253u,524810861u,525255197u,525565441u,526067821u,526359289u,526686889u,526698937u,527761081u,528013333u,528043753u,528220117u,528820501u,529456033u,529782121u,529984801u,530443201u,530630701u,530714887u,
	531095029u,531681281u,532126801u,532526401u,532688401u,532758241u,532800133u,533429881u,533860309u,534782293u,535252867u,535428577u,535517581u,536003333u,536114197u,536300821u,536342419u,536357053u,536484031u,536562937u,536682511u,536870911u,537209921u,537302701u,539019361u,539234821u,539443213u,539799481u,540066241u,540207097u,540621181u,540654409u,540680141u,541672957u,541935901u,542497201u,542536457u,542626201u,543226321u,543459961u,544101481u,544861633u,545220869u,545363281u,545550433u,545570641u,545622401u,546102481u,546117301u,546322201u,546649741u,546748931u,547652161u,548080513u,548205841u,548289001u,548409401u,548409473u,548871961u,548989561u,549308761u,549333121u,549538081u,549659521u,550122001u,550132741u,550230409u,550635373u,550853137u,551140129u,551313001u,551672221u,551686201u,551840221u,552022219u,552573793u,552894301u,552914071u,553027201u,553079179u,553125937u,554050861u,554104261u,554487121u,554599051u,554964001u,555046097u,555321007u,555465601u,555726421u,556001377u,556069849u,556095433u,556114609u,556199281u,556450777u,557160241u,557165209u,557437999u,557795161u,
	558235109u,558570961u,558900821u,558977761u,559043941u,559547773u,559702153u,561448487u,561481921u,561492181u,561777121u,562367821u,562854601u,563298061u,563947141u,564084841u,564276061u,564298489u,564535441u,564651361u,564689381u,565422001u,565566001u,565664761u,565707061u,566530849u,566620201u,566689927u,567094501u,567358513u,567468721u,567596401u,568227241u,568773361u,568902001u,568967221u,569332177u,569495809u,569708161u,570012121u,570326401u,570491461u,570699181u,570941881u,571389001u,571623583u,572116501u,572123521u,572189941u,572228929u,572430769u,572567353u,572936869u,573183451u,573817861u,573862021u,573896881u,573911857u,574998841u,575326033u,575574049u,576691741u,576724219u,577210181u,577240273u,577337761u,577352641u,577613261u,578595989u,579139561u,579342673u,579373873u,579606301u,579956653u,580087873u,580565233u,580660081u,581618143u,582389641u,582584941u,582799951u,583248601u,583527601u,584414041u,585261637u,586014067u,586019071u,586538503u,586706821u,586877351u,587336401u,587343541u,587422609u,588049001u,588450061u,588469649u,589196881u,590356357u,590473801u,591242653u,
	591717787u,591822001u,592170601u,592467451u,592468777u,593102881u,593198497u,593234929u,593420941u,593628481u,593682169u,593728489u,593970769u,594734257u,595405201u,595590841u,596642713u,597537361u,597717121u,599135767u,599945293u,600026131u,600240181u,600507277u,600892993u,600893921u,600926509u,601606487u,601830881u,602379181u,602426161u,602593441u,603255001u,604584221u,604596601u,604611019u,605221501u,605341837u,605454917u,605961049u,606662281u,606682081u,606872449u,607148653u,607263553u,607540033u,607600871u,607677181u,607706401u,607750681u,608421637u,608442121u,608761297u,608917753u,608961241u,609046957u,609361567u,609414961u,609813781u,609865201u,610000501u,611097401u,611146861u,611374453u,611770513u,611812321u,611817421u,612006253u,612185029u,612587521u,612816751u,613782601u,613849601u,614742241u,615020401u,615344227u,615361183u,615623737u,615760133u,615895897u,616280897u,616458961u,616463809u,616523701u,616544101u,617087701u,617984101u,618068881u,619239457u,619268401u,619365121u,619480601u,619656001u,620052301u,620072251u,620169409u,620544961u,620580961u,620755537u,620827621u,
	621078301u,621100741u,621338641u,621769669u,622047427u,622137601u,622905661u,623100457u,623613961u,623735953u,624303241u,624732421u,625060801u,625482001u,626717471u,627886657u,628832881u,628868467u,629134081u,629692801u,630022069u,630496621u,630622753u,630811513u,630888481u,631071001u,631677421u,631767943u,631974613u,632997001u,633289807u,633639097u,634399417u,635147101u,635155291u,635291077u,635319361u,635907581u,636021211u,636097177u,636111451u,636130769u,636287653u,636337073u,636936697u,637907581u,638502913u,638837761u,638959321u,639305921u,639807781u,639894421u,639925441u,640650931u,640804243u,640977373u,641468401u,641686081u,641835811u,642708001u,642795427u,643036321u,643316461u,643445881u,643552909u,643767931u,644004817u,644453633u,644457551u,644731357u,644900257u,645556481u,645589351u,645986401u,647065321u,647190253u,648056449u,648328801u,648408773u,648993961u,650028061u,650506321u,650663861u,651011329u,651064681u,651109537u,651151801u,651514753u,651830821u,652469641u,652684201u,652969351u,653235841u,653260633u,654000061u,654255467u,654947101u,655264369u,655503913u,656187001u,
	656189101u,656723161u,656958061u,657732349u,658126621u,658476001u,658831741u,659526601u,659846021u,660095641u,660754117u,661122881u,661207177u,662134201u,663699961u,663760681u,664384321u,664574653u,665096941u,665462081u,665498107u,665743429u,666455581u,666673261u,668498321u,668734753u,670976641u,670987021u,671024389u,671271581u,671716921u,672103001u,672108193u,672389641u,672533921u,672579671u,672687133u,673326013u,673352629u,673389601u,673725469u,673778561u,673778827u,674503921u,674666641u,675168193u,675260477u,675651469u,676243261u,676280221u,676359391u,676880821u,677451241u,678481693u,678981871u,679033681u,680863261u,680972909u,680983817u,681019921u,681124207u,681303241u,682528687u,683032801u,683316001u,683362681u,683379841u,684350833u,684979693u,685201141u,685374691u,686023537u,686043661u,686059921u,686071009u,686129221u,686551351u,687741401u,688431601u,688436893u,688607101u,688804399u,689235121u,689537341u,689537441u,690035713u,690562601u,691131349u,691395871u,691830811u,691847573u,691914161u,692535637u,692597647u,692895421u,692948029u,693456521u,694031221u,694116893u,694656901u,
	696042901u,696321949u,696447181u,696998251u,697821857u,697906561u,698192041u,698548201u,698784361u,698819711u,700932961u,701043421u,701247001u,702683101u,703995733u,704934361u,705101761u,705303457u,705351583u,705890219u,706368713u,706728377u,706979341u,707469841u,707691601u,707926801u,707941081u,708621217u,708843241u,709409993u,709436557u,710382401u,710408917u,710541481u,710617861u,710721001u,711374401u,711832061u,711981649u,713383171u,713588401u,713778661u,713917891u,714490481u,714663139u,715614901u,716406481u,716652001u,716923729u,717096641u,717164449u,717653129u,717831211u,718731001u,718902241u,719256497u,719605393u,719617249u,720767521u,720931121u,721244161u,722508229u,722923201u,722955773u,723645001u,724160251u,724274671u,724677797u,724947337u,724969087u,725508241u,725525137u,726242881u,726501601u,727083001u,728708401u,728816401u,728851507u,728931841u,729094843u,730144441u,730364137u,730925713u,731276521u,731894131u,732627401u,732736621u,732738097u,732805681u,732812353u,733098913u,733219201u,733995883u,734166217u,734590837u,734652901u,734770681u,734895721u,735432773u,736668013u,
	737261953u,738820351u,739036541u,739444021u,739576801u,740988151u,741182401u,741203281u,741214237u,741470549u,741795133u,741965821u,742017181u,742039441u,742550401u,743397733u,743404663u,744500641u,745493761u,745745461u,745823881u,745960501u,746110201u,746296993u,746331041u,746706961u,746793763u,747406801u,748419127u,748638001u,748959709u,749172821u,749640161u,750616739u,750632137u,750970801u,751226401u,751705597u,752102401u,752186593u,752780161u,753022201u,753233717u,753532781u,753574537u,753594001u,753776173u,754020361u,754722001u,754874257u,756205633u,756249901u,756271909u,756318751u,756980137u,757639387u,758581651u,758687581u,758875601u,758901701u,759085273u,759129229u,759252367u,759266621u,759472561u,759502081u,759622753u,759638881u,759691801u,760264009u,762278161u,762428071u,762645313u,762699649u,763488241u,763596709u,763907741u,764033999u,764240611u,764636569u,764923477u,765067321u,765245881u,765378241u,765946441u,766303693u,766503409u,766661221u,766823797u,766836481u,768440063u,768653281u,769006153u,769445561u,770056141u,770201221u,770909107u,770937931u,771043201u,771337891u,
	771350581u,771721949u,772495777u,773131927u,773807401u,774346981u,775006201u,775086481u,775135201u,775368901u,775866001u,775896181u,776176261u,776443769u,777218989u,777668401u,777778561u,778762501u,779708281u,779819587u,780417001u,781347841u,781420097u,781471001u,781517881u,782823281u,783170137u,784242901u,784450393u,784586881u,784777393u,784783477u,784966297u,784990921u,785901313u,786262321u,787085857u,787209277u,788046901u,788378701u,788931361u,789082001u,790020001u,790239241u,790453049u,790623289u,790799801u,791118043u,792049381u,792144161u,792145729u,793045561u,794201333u,794399041u,794910961u,794937601u,795064909u,796072003u,796200901u,796560703u,797418997u,797834017u,798695191u,798770161u,798823081u,799104721u,799146601u,799162561u,799275961u,799518721u,799630753u,799808401u,799865461u,799898833u,799916101u,800368261u,800712901u,801093011u,801227269u,801606401u,801866647u,803073601u,803264281u,803756449u,803823553u,804232261u,804801313u,804802777u,804978721u,805505957u,805589621u,805771501u,805797433u,807115753u,807218413u,807857389u,808107301u,808214161u,808857721u,809702401u,
	809790881u,809883361u,810023881u,810455101u,810514081u,810543301u,810915701u,811110301u,811374709u,811478533u,811607777u,811730923u,812070721u,814056001u,814832177u,815430533u,815737177u,815796413u,816024161u,816075457u,816215401u,816549121u,816588901u,816799369u,816890561u,817013401u,817832329u,818126311u,818391211u,818401321u,818742961u,818762569u,819019201u,819466201u,819743233u,819891679u,820009831u,821561203u,821652601u,822018961u,822531841u,823106593u,823286701u,823536781u,824389441u,824405041u,826004467u,826841641u,828380791u,828499393u,829450909u,829512001u,829678141u,829932601u,830295901u,830664451u,831933901u,832048447u,832060801u,832127489u,832169857u,832251421u,833079121u,833608321u,833610751u,834147721u,834244501u,834589801u,834720601u,835051057u,836154047u,836515681u,836683849u,836794843u,837311761u,837766217u,837843931u,838357141u,839268139u,839275921u,839280691u,839908217u,840749761u,841217653u,841340521u,841399021u,841402801u,841552921u,841660961u,841776001u,842202361u,842429809u,842785841u,842824981u,842960981u,843161887u,843463501u,843704401u,843983191u,844075051u,
	844523569u,844545271u,844788757u,845376533u,846063361u,846961321u,847178641u,847324843u,847491361u,848090377u,848755969u,849064321u,849245167u,849548671u,850141207u,850193401u,850885141u,851703301u,851778817u,851934601u,852081121u,852163157u,852432769u,852571951u,852645691u,852729121u,852888961u,854094781u,854172271u,854319269u,854868257u,855429841u,855674041u,855734401u,855762559u,856379057u,857009881u,857100421u,857902861u,858336529u,858687103u,858895921u,859096477u,859481921u,859889917u,859996477u,860334301u,860736889u,861533821u,861752809u,861993793u,862082677u,862678081u,863196181u,863471521u,863609113u,863744701u,863984881u,864014581u,865242841u,866008153u,867022747u,867110501u,867638201u,867800701u,867836593u,867965251u,868088341u,868111597u,868234081u,868691401u,868967401u,869019481u,870248821u,870985223u,871102441u,871157233u,871195561u,871840261u,871908481u,873503401u,873631027u,875828101u,876850801u,877542481u,878492941u,878529601u,878603701u,878940833u,879995689u,880105381u,880288049u,880870513u,880922657u,881186801u,881290609u,882185941u,882516991u,882796321u,882866161u,
	883276549u,883571401u,884304037u,884701441u,884952001u,885177541u,885336481u,885390017u,885501721u,885510239u,886002481u,886180429u,886526641u,886975441u,887526251u,887795221u,888700681u,888868441u,891706861u,892650067u,892740853u,893466301u,893601541u,893692819u,894264337u,894872071u,895893433u,895992721u,896231953u,896901461u,897063677u,897087361u,897283213u,897387481u,897395201u,897842401u,897880321u,898343713u,898384501u,898966801u,899019353u,899104501u,900736411u,901074259u,901848301u,902566501u,902645857u,903108821u,903390643u,905040953u,906008281u,906060169u,906187381u,907378669u,907670501u,907711561u,908005249u,910202509u,910651393u,910867481u,911040481u,911484421u,913394881u,914348737u,914688433u,914906539u,915641821u,915743251u,917041301u,917704081u,918023891u,918063343u,918661501u,919941841u,920375821u,920696653u,920834197u,920849761u,921858631u,922050481u,922845241u,923437213u,923810401u,924528061u,925265551u,925276681u,925972201u,926181361u,926586001u,926756881u,927106561u,927749203u,927877001u,928040131u,928152673u,928447861u,928482241u,929159941u,930530701u,930745621u,
	931050721u,931694401u,932148253u,933184801u,933243301u,933729421u,934168861u,934784929u,935794081u,936421141u,937477801u,937675393u,938376181u,939408601u,939706021u,939947009u,940123801u,941056273u,941116177u,941734657u,942088201u,942911461u,943271569u,943795201u,944157061u,944832533u,946033201u,946034057u,946378657u,946787377u,947105461u,947829889u,947878081u,947950501u,947993761u,949317217u,949697233u,949891321u,951204961u,951941161u,952282801u,952893881u,953022151u,954551431u,954608761u,954711241u,954732853u,954924013u,955134181u,955160701u,955237141u,955359901u,955527301u,956094193u,956422657u,957044881u,957600541u,957631249u,958131157u,958304893u,958588681u,958669921u,958735681u,958762729u,959080601u,960269377u,960946321u,962415721u,962442001u,962489557u,962491237u,962500561u,962523169u,962769553u,963163201u,963168193u,964245001u,964412837u,964435969u,965490677u,965501857u,967172909u,967266451u,967270129u,967287751u,967714021u,967790401u,968283247u,968324881u,968413217u,968553181u,968751241u,968915521u,969528337u,970299721u,970586713u,971032861u,971454661u,971515777u,971975071u,
	974113601u,974471243u,974774401u,974864521u,975303121u,975576281u,975705781u,975765787u,976396961u,976938061u,977392711u,977483449u,977737321u,977755351u,977892241u,979363153u,979408801u,979421111u,980056507u,980725201u,980957461u,981484561u,981789337u,981855281u,981914401u,982492561u,983456377u,983778269u,984133441u,984252001u,985052881u,985075681u,986088961u,986392021u,987465151u,987842101u,988008337u,989739829u,990061957u,990409421u,990893569u,993420289u,993905641u,994133479u,994964251u,995586373u,995650921u,996524101u,997170931u,997695661u,997753901u,997836841u,998489017u,998590601u,998596741u,998724481u,999828727u,1001152801u,1001723911u,1002261781u,1002381871u,1002439153u,1002781441u,1003062061u,1003509511u,1005402133u,1005654601u,1005833971u,1006207021u,1006679401u,1006800829u,1007246431u,1007608753u,1008032689u,1008777001u,1008839999u,1009025263u,1009140161u,1010324161u,1010394001u,1010979817u,1011319501u,1011333061u,1011570457u,1011754423u,1011909271u,1012438391u,1013833153u,1013996821u,1015339441u,1015626151u,1016597737u,1017517501u,1017748057u,1017817801u,1018878001u,1019089369u,1020220661u,1020515761u,1021026601u,
	1021281301u,1021314001u,1022336611u,1022616097u,1023267281u,1024041853u,1024123501u,1024249933u,1024605121u,1025035129u,1025067241u,1026583801u,1026738161u,1027334881u,1027354321u,1027744453u,1028360593u,1028494429u,1030401901u,1031750401u,1032101461u,1033161841u,1033449121u,1033480201u,1033501877u,1034252929u,1034261881u,1034283421u,1034736121u,1034958601u,1035608041u,1036335301u,1036816633u,1037560681u,1037935813u,1038148801u,1038165961u,1038880753u,1039224121u,1039579451u,1040234231u,1040449769u,1042855801u,1043938369u,1044959501u,1046080339u,1046508373u,1046656501u,1049116069u,1049584313u,1049790001u,1050102901u,1050506101u,1050535501u,1050721561u,1051080913u,1054999441u,1055009117u,1055384929u,1056121453u,1057367593u,1057426651u,1058575981u,1059193297u,1059282001u,1060291849u,1061013301u,1061075197u,1061084701u,1061413151u,1061609761u,1063212481u,1063801909u,1064926801u,1065508321u,1065602281u,1066415191u,1066603681u,1066938769u,1066972301u,1067494861u,1067917501u,1069388497u,1069731901u,1070011321u,1070639389u,1070659201u,1070941987u,1071512749u,1071643249u,1072096201u,1072570801u,1072581277u,1072812001u,1072898711u,1072915921u,1073159281u,1073288581u,1073299501u,1073356831u,
	1073484823u,1075100041u,1077133397u,1078014301u,1078467589u,1079237809u,1079556193u,1080124657u,1080255241u,1081176601u,1081798061u,1082472553u,1082553121u,1084187521u,1084241341u,1084444481u,1086444001u,1087190371u,1088953921u,1089174013u,1089682837u,1089991981u,1090858081u,1092518407u,1092558013u,1093150081u,1093297661u,1093352833u,1093526353u,1093552201u,1093690621u,1093916341u,1094042321u,1095414601u,1095474121u,1097416321u,1098027601u,1098743563u,1098895249u,1100624857u,1100674561u,1101270457u,1101623381u,1101673501u,1102573501u,1102750013u,1103102191u,1103145121u,1104194521u,1105024481u,1105038871u,1105322653u,1105779277u,1106410033u,1106529761u,1106580817u,1106595493u,1107011521u,1107138961u,1107263521u,1107717841u,1108135381u,1108485001u,1108706857u,1109052001u,1109304913u,1110293101u,1110582947u,1111205873u,1111939201u,1112103541u,1112247289u,1112495671u,1112502403u,1112671603u,1113541073u,1114277221u,1115910727u,1116379301u,1117202557u,1117610033u,1117785881u,1117828001u,1117890019u,1119075841u,1119412321u,1119793501u,1120068001u,1120076281u,1120258657u,1120981021u,1121176981u,1122922801u,1122947101u,1123406047u,1123625501u,1123727617u,1123942387u,1124396521u,1124841577u,
	1124925913u,1125038377u,1126587151u,1126602961u,1127040769u,1127596801u,1128169441u,1128950281u,1129146481u,1130473361u,1130933429u,1131092381u,1131222841u,1132002847u,1134010801u,1134044821u,1134367777u,1135263583u,1135679761u,1136410943u,1136940031u,1137966061u,1138049137u,1138289041u,1138607233u,1139109121u,1139137057u,1139434453u,1140441121u,1140573601u,1141269481u,1141781461u,1142092081u,1142466151u,1142770133u,1143378419u,1143427861u,1144088101u,1144357201u,1144839697u,1144998841u,1145170153u,1145677201u,1147357559u,1147434289u,1148063573u,1148237861u,1148578201u,1150229761u,1150270849u,1150534747u,1151670001u,1152161191u,1152793621u,1153049341u,1153164097u,1153366501u,1153440289u,1153642501u,1154343961u,1154691409u,1154987209u,1155939709u,1156761911u,1156993373u,1157585329u,1157627353u,1157839381u,1159421509u,1159712737u,1160527501u,1160737201u,1160804419u,1160844821u,1161306721u,1161531601u,1161907201u,1162202581u,1163044681u,1163098249u,1163168077u,1163227759u,1163523241u,1163659861u,1164033613u,1164218641u,1164340237u,1164430657u,1165552697u,1165717129u,1166016373u,1166475601u,1166598217u,1168108201u,1168221121u,1168256953u,1168492417u,1171525681u,1171811653u,1172155601u,
	1172449351u,1172800729u,1173229201u,1173545533u,1174300093u,1174476913u,1174614001u,1175799241u,1177195201u,1177773421u,1177800481u,1177874587u,1178196859u,1178717713u,1180398961u,1180817569u,1180954321u,1180970407u,1181566219u,1182047401u,1182875401u,1183104001u,1183338241u,1184291641u,1184554801u,1185589913u,1185605209u,1186325981u,1187082001u,1187235193u,1188180001u,1189238401u,1190524651u,1190790721u,1190895301u,1191153937u,1191216133u,1191545929u,1192314817u,1192412033u,1192903531u,1193043601u,1193229577u,1193557093u,1194508873u,1194866101u,1195400641u,1195524181u,1195556653u,1196189281u,1196364727u,1196852273u,1196969707u,1198387201u,1198650961u,1198880261u,1200456577u,1200778753u,1202050873u,1202142061u,1203090379u,1204119731u,1204176751u,1204205449u,1204218709u,1205606533u,1205772499u,1206057601u,1206843463u,1207193149u,1207252621u,1209112633u,1209998077u,1210393801u,1210562701u,1210653541u,1211686849u,1212081517u,1212725137u,1212919201u,1213153201u,1213245001u,1213619761u,1213981441u,1214027137u,1214341129u,1214703721u,1214770577u,1216631521u,1217181061u,1217823517u,1217924159u,1218132761u,1218501181u,1219493437u,1219816261u,1219858921u,1220114377u,1220491691u,1221044653u,
	1221127013u,1221367057u,1222568707u,1222861271u,1223475841u,1223531677u,1223884969u,1223941657u,1224437833u,1225128829u,1225506217u,1226230297u,1226855293u,1227133513u,1227220801u,1227280681u,1227474431u,1227493081u,1227743401u,1228425121u,1228962197u,1229491063u,1229536801u,1229746393u,1229751667u,1230330817u,1230393241u,1230446653u,1231002901u,1231153561u,1231362793u,1231637761u,1231726981u,1231869601u,1232445677u,1232469001u,1233715393u,1233759241u,1234125721u,1234646533u,1235188597u,1235864033u,1236313501u,1236442421u,1236640021u,1236691021u,1237091401u,1237712617u,1238018797u,1238825569u,1239010201u,1239896701u,1241120881u,1241293681u,1242171349u,1242227647u,1242858317u,1242958501u,1243518373u,1244576881u,1246588201u,1247375273u,1247688961u,1247750111u,1248314761u,1248453361u,1249166881u,1249785941u,1250656621u,1250896849u,1251295501u,1251748807u,1251992281u,1252236421u,1252489057u,1252957501u,1253314693u,1254277909u,1254318481u,1254580541u,1255135501u,1255665613u,1256276581u,1256780071u,1256855041u,1257102001u,1257216577u,1258094801u,1258903981u,1258962541u,1259851321u,1260332137u,1260404821u,1262641501u,1262991913u,1263293281u,1263344581u,1264145401u,1264264561u,1264505863u,
	1265477791u,1265740717u,1266003461u,1266025351u,1266273793u,1266425101u,1267154071u,1267345081u,1267643557u,1267834459u,1268104993u,1268604001u,1268946253u,1269171049u,1269211021u,1269295201u,1269835201u,1270193401u,1270489621u,1270667353u,1271325841u,1272558739u,1272866167u,1273165921u,1273691791u,1278280081u,1278649441u,1280045989u,1280074081u,1280727701u,1281100549u,1281344689u,1282369321u,1282371091u,1282447477u,1282568741u,1282637521u,1284321611u,1284796801u,1284816583u,1284997429u,1285636801u,1286298133u,1286298263u,1287250021u,1290156841u,1290927751u,1291773451u,1291933501u,1292581751u,1293180481u,1293866533u,1293971041u,1295577361u,1295948431u,1296613501u,1297090081u,1297092721u,1297443913u,1299072721u,1299656821u,1299784141u,1299963601u,1301509249u,1301715949u,1301926081u,1302607801u,1302745481u,1303352353u,1304553251u,1304780431u,1306742221u,1306836001u,1307004641u,1307520469u,1307823661u,1308196201u,1308758533u,1308998741u,1309440001u,1309531861u,1309723213u,1309983901u,1310329567u,1311070657u,1311255661u,1311616153u,1312332001u,1312573123u,1312845661u,1312944931u,1313396221u,1313428201u,1313596201u,1315858381u,1316052893u,1316169541u,1316417173u,1316958721u,1317828601u,
	1317912541u,1318126321u,1318717531u,1318755439u,1318853537u,1319136661u,1319182201u,1319695501u,1319736601u,1319978701u,1319992181u,1320793813u,1321058213u,1321545961u,1321983937u,1322437201u,1322916253u,1323378001u,1323668917u,1324857293u,1325172421u,1325329297u,1327551233u,1328081833u,1328256247u,1329174601u,1329431689u,1330202273u,1330655041u,1331226121u,1331419321u,1331973329u,1332123661u,1332313291u,1333144561u,1336210313u,1336288669u,1338317293u,1338579257u,1339223509u,1341010577u,1341026401u,1341042361u,1341672913u,1341871777u,1341926401u,1342185841u,1343575381u,1343851867u,1343872153u,1344039841u,1344597577u,1344975721u,1345227361u,1345514101u,1345523401u,1346316973u,1347387361u,1347914701u,1348114069u,1348964401u,1349536981u,1349671681u,1349855497u,1350371821u,1350685001u,1351126261u,1352453257u,1352531269u,1353051517u,1353976801u,1354991653u,1355042833u,1356241321u,1356328121u,1356661711u,1357459183u,1358288471u,1358662669u,1361195551u,1361355751u,1362132541u,1362463807u,1362515701u,1362742561u,1363178701u,1363519501u,1363563397u,1364828257u,1365662917u,1365746491u,1365783961u,1366587661u,1366608377u,1367490601u,1367732161u,1368769681u,1369166239u,1370776577u,1371090721u,
	1371908137u,1372681861u,1373410081u,1373986801u,1375322101u,1376550737u,1376781601u,1376799577u,1376844481u,1376906041u,1377829441u,1378231633u,1378483393u,1378646179u,1379464633u,1379937781u,1381243709u,1381568059u,1381581481u,1382114881u,1382453333u,1382557969u,1383283129u,1384157161u,1384701409u,1385142661u,1385656829u,1385804161u,1385920693u,1386705433u,1386734761u,1388232241u,1388400751u,1388972353u,1389353941u,1389975149u,1391564161u,1391890033u,1392189569u,1393253191u,1393851553u,1394640941u,1394746081u,1394942473u,1395564127u,1396134997u,1397357851u,1398883201u,1400575177u,1400859847u,1401840833u,1404008369u,1404111241u,1404228421u,1404253369u,1404403273u,1406826241u,1406851249u,1407060181u,1407548341u,1407818749u,1408352401u,1409372779u,1410521941u,1410833281u,1411728571u,1412193601u,1412437501u,1413067501u,1413803197u,1414154827u,1414529533u,1415969101u,1417292911u,1417986901u,1419339691u,1419459121u,1419575167u,1419706601u,1420093081u,1420613161u,1420784281u,1421475031u,1422477001u,1422713161u,1423668961u,1424503849u,1425860101u,1426319563u,1426534201u,1427771089u,1428432349u,1428966001u,1429093261u,1430262769u,1431677941u,1432227601u,1432354901u,1433624401u,1434177821u,
	1435091377u,1435146077u,1435768771u,1435921201u,1436131621u,1436452381u,1436976289u,1437330241u,1437717847u,1438648993u,1439328001u,1439492041u,1440231941u,1440922891u,1441139641u,1441316269u,1441678411u,1442374801u,1442761201u,1442945689u,1443388481u,1443742273u,1445084173u,1445581801u,1446247001u,1446298309u,1446434677u,1446818651u,1448221297u,1448921633u,1450115101u,1450478459u,1451635201u,1452201241u,1452759401u,1452767521u,1453391941u,1453645663u,1454282449u,1454445413u,1455726097u,1456527461u,1457137201u,1457378449u,1458756721u,1458995371u,1459654561u,1461026953u,1461307717u,1462393201u,1463030101u,1463065501u,1463178817u,1463992661u,1464568381u,1465290841u,1465307351u,1465454101u,1465749451u,1465908193u,1465945417u,1466169829u,1466414119u,1468540477u,1468824787u,1469059481u,1469074321u,1469768653u,1469960377u,1470080501u,1470650851u,1471628401u,1471883641u,1472221921u,1472772421u,1472970421u,1473580001u,1474936871u,1475200441u,1475841511u,1476304501u,1476648901u,1477289941u,1481619601u,1481626513u,1482152101u,1482274513u,1482876673u,1483199641u,1483873861u,1483918801u,1484080291u,1485061471u,1485162721u,1485880921u,1486285801u,1486564301u,1489587997u,1490046481u,1490056501u,
	1490247841u,1490564881u,1490621461u,1490636449u,1493114149u,1494352861u,1494595801u,1494714493u,1495190699u,1497221281u,1497262321u,1497965713u,1499971457u,1499989177u,1500142001u,1500884581u,1501011001u,1501165097u,1501194397u,1502171117u,1502403121u,1502570513u,1502770193u,1503240559u,1503705601u,1504139521u,1504604101u,1504651681u,1504728541u,1504832033u,1505010991u,1505432881u,1506674521u,1507243681u,1507746241u,1508119081u,1508953447u,1509156013u,1509600001u,1509677401u,1510474841u,1510860121u,1510870241u,1511558533u,1513888157u,1514608559u,1515175087u,1515664153u,1515785041u,1515874921u,1516071547u,1516962241u,1517039371u,1518014689u,1518066829u,1518290707u,1518521401u,1519801381u,1520190341u,1520467201u,1521221473u,1521835381u,1522302121u,1522573921u,1522669051u,1522918201u,1524137041u,1525345097u,1525655461u,1526732803u,1526967961u,1527236341u,1527578209u,1528936501u,1529298541u,1529544961u,1529648231u,1529819971u,1530159247u,1530275671u,1530495289u,1530757801u,1531436401u,1532383217u,1532419099u,1532569681u,1532586601u,1532755369u,1533343261u,1534063081u,1535020133u,1535505301u,1536112001u,1536251047u,1536883357u,1537433899u,1537641691u,1538012449u,1538753581u,1539068401u,
	1539171289u,1539219781u,1539583921u,1539804001u,1540454761u,1540550413u,1541004451u,1541047813u,1541755909u,1541818321u,1541849761u,1541955409u,1544145121u,1545019813u,1545177581u,1545387481u,1545914371u,1546106773u,1546340401u,1546508057u,1547140841u,1547543161u,1547712601u,1549308001u,1549477837u,1549698481u,1550256481u,1550643139u,1550924873u,1552778501u,1553233481u,1554270481u,1557118081u,1560312001u,1560620041u,1561800833u,1563607081u,1565074699u,1565683181u,1565893201u,1566001801u,1566594551u,1566654481u,1567830241u,1568101591u,1568471813u,1568916311u,1569488977u,1569663271u,1569843451u,1571111587u,1571503801u,1572279791u,1572932089u,1573132561u,1573895701u,1574362441u,1574601601u,1575340921u,1576187713u,1576826161u,1577983489u,1578009401u,1578114721u,1579869361u,1580201501u,1580449201u,1580591377u,1581576641u,1581714481u,1581943837u,1582212101u,1582783777u,1582886341u,1583230241u,1583582113u,1583658649u,1584405649u,1584443341u,1584462331u,1586436193u,1587483001u,1587650401u,1588246561u,1588247851u,1589307919u,1590394313u,1590564601u,1592109751u,1592668441u,1593706201u,1594212061u,1595120473u,1595622997u,1595647351u,1595887921u,1597009393u,1597330813u,1597821121u,1598197201u,
	1600952221u,1602517949u,1603188841u,1603765021u,1603810561u,1603994701u,1604440111u,1606734481u,1609913059u,1609916491u,1609935913u,1611716401u,1611842101u,1612121473u,1612702621u,1613347741u,1614290641u,1614400417u,1614508267u,1615204669u,1615565953u,1615744261u,1616387653u,1616873413u,1617795181u,1617921667u,1618070737u,1619447741u,1620646177u,1620653761u,1622134801u,1622809111u,1623368293u,1623794113u,1625667121u,1626167341u,1627103521u,1627151197u,1627636561u,1627733341u,1627898401u,1628059501u,1628692201u,1630062253u,1630307617u,1631314609u,1631394961u,1632082141u,1632286673u,1632513601u,1632785701u,1633044241u,1633771873u,1633931461u,1635241153u,1635548221u,1636046389u,1636185601u,1636572253u,1637176801u,1637434657u,1637436457u,1637930893u,1638294661u,1638983347u,1639256641u,1639351981u,1639846391u,1640144461u,1641086371u,1641971701u,1642207051u,1642814653u,1643317237u,1643962069u,1644637051u,1645228621u,1645253989u,1645413001u,1645677811u,1646426881u,1646645041u,1646923201u,1647225529u,1647290503u,1648076041u,1648130977u,1649422981u,1649430889u,1649684401u,1650117809u,1650265549u,1650581593u,1650682153u,1651154581u,1651880413u,1652420197u,1652932513u,1654940509u,1655660761u,
	1656229921u,1656280033u,1656812521u,1656917377u,1657700353u,1659009601u,1659935761u,1659965077u,1661202113u,1662320881u,1662684661u,1662784117u,1663998337u,1664852161u,1667600101u,1668037621u,1668926629u,1669843891u,1669893661u,1670044321u,1670388229u,1670729281u,1671033401u,1671603667u,1671714241u,1672125131u,1672719217u,1673480161u,1674091141u,1674256441u,1674658133u,1674944881u,1675348201u,1675352701u,1675978193u,1676203201u,1676641681u,1678274581u,1678305451u,1678569121u,1679130641u,1679881681u,1680187537u,1680901381u,1682056201u,1683174533u,1685266561u,1685433413u,1686001861u,1686495601u,1686886081u,1687248001u,1688214529u,1688639041u,1689411601u,1689957383u,1690230241u,1690380901u,1690914781u,1691249869u,1691745821u,1692605041u,1693101241u,1693715101u,1694128129u,1695158921u,1696572001u,1696574449u,1696893101u,1697213407u,1698623641u,1698707377u,1699279441u,1699471117u,1700250049u,1700978401u,1701016801u,1701516961u,1702210861u,1704682753u,1705231921u,1705470481u,1706302153u,1707704461u,1708102201u,1708179229u,1708549501u,1709127811u,1709157169u,1709909293u,1710375121u,1710616321u,1710753001u,1712127241u,1712392321u,1713319453u,1713600049u,1714322377u,1714721059u,1716160321u,
	1716714793u,1716774481u,1718013133u,1718088301u,1718341409u,1718769241u,1718951873u,1719020161u,1719122653u,1719197621u,1720434001u,1720630759u,1721061497u,1721290741u,1721986313u,1722007169u,1722685777u,1722703501u,1723305403u,1725547321u,1725675451u,1726007797u,1726372441u,1729884511u,1730231101u,1730281121u,1730549017u,1730644201u,1731048937u,1731995497u,1732625713u,1732924001u,1733027341u,1733474197u,1733628961u,1734059291u,1734285601u,1734795361u,1735071913u,1736188201u,1736392801u,1736481601u,1738687469u,1740214841u,1740420577u,1740980431u,1741490323u,1741920301u,1742288881u,1742815621u,1742969041u,1743166441u,1743275521u,1744315363u,1744576687u,1744605097u,1745114581u,1745441701u,1746692641u,1746721681u,1749124829u,1749580561u,1750412161u,1751246641u,1752710401u,1753588081u,1754818561u,1757055847u,1757148121u,1758731941u,1759540693u,1760014561u,1760460481u,1762570553u,1762742477u,1764717781u,1765554061u,1766984389u,1767200059u,1767234613u,1769031901u,1769091241u,1769267761u,1769846321u,1770236893u,1771044773u,1771303801u,1772267281u,1773486001u,1773582977u,1775611201u,1775668129u,1775919601u,1776439261u,1776723349u,1776820033u,1777380301u,1778373961u,1778382541u,1778644561u,
	1779649381u,1779892577u,1780945501u,1781537773u,1784291041u,1784306273u,1784323201u,1784638309u,1784975941u,1785500081u,1785507361u,1785843547u,1786005521u,1787127817u,1787934881u,1789167931u,1789656931u,1790023861u,1790101633u,1791157537u,1791426787u,1792442737u,1792588813u,1793417341u,1794814103u,1795163161u,1795216501u,1795674131u,1797382823u,1798502641u,1798706521u,1799674471u,1799805547u,1801369369u,1801558201u,1801774081u,1801818901u,1802099569u,1802510669u,1802778901u,1803278401u,1803308057u,1803768091u,1804906517u,1804954201u,1805947313u,1806597937u,1807352209u,1809888967u,1811514721u,1813073653u,1813474321u,1813625893u,1816408273u,1817067169u,1818108721u,1819829749u,1820306953u,1820514241u,1821514633u,1821689101u,1821792457u,1822160341u,1823541721u,1824612241u,1825017521u,1825140241u,1825428781u,1825568641u,1825794097u,1827554653u,1828377001u,1828682101u,1828887061u,1829375209u,1830949313u,1831048561u,1831258601u,1832689801u,1833166333u,1833179041u,1833328621u,1835112241u,1835114401u,1836304561u,1836484651u,1837156049u,1837599769u,1837837729u,1839568981u,1840920361u,1841034961u,1841099261u,1841479501u,1841683681u,1843610041u,1844028961u,1845128533u,1846171781u,1846817281u,
	1847811673u,1848681121u,1849811041u,1849964117u,1850233897u,1850598961u,1852496761u,1853926777u,1854001513u,1854084649u,1854583381u,1854940231u,1855100017u,1855139341u,1856689453u,1857221281u,1857695281u,1857893401u,1858098497u,1858197961u,1858395529u,1859554957u,1859668021u,1860373241u,1861026133u,1861039021u,1861880689u,1862880401u,1862883311u,1864009153u,1865227651u,1866409861u,1867165249u,1867485781u,1867906721u,1868076451u,1868682241u,1868951881u,1869875281u,1871987041u,1872538273u,1872937057u,1873177693u,1874634721u,1874849929u,1875796561u,1876652713u,1877555681u,1878156001u,1878691753u,1879088401u,1879111697u,1879480513u,1879623157u,1879775501u,1879965781u,1882301201u,1883377441u,1883509633u,1883699581u,1883785681u,1883814337u,1885915841u,1887933601u,1888407781u,1892333521u,1892911801u,1894344001u,1894909141u,1894955311u,1896789349u,1896961801u,1897700113u,1898107681u,1899081757u,1899525601u,1899768763u,1900687381u,1900823653u,1902297601u,1902303721u,1902900241u,1902938401u,1903447841u,1904558701u,1904658913u,1904833393u,1904842033u,1905958891u,1906709281u,1908088001u,1909566073u,1910134309u,1911197947u,1912950241u,1913016001u,1913258311u,1914303841u,1914413761u,1915391521u,
	1916729101u,1916987593u,1917363361u,1917397637u,1917525961u,1918534901u,1918699771u,1918820593u,1919767681u,1920301951u,1921295359u,1921309633u,1922092567u,1922687293u,1922906161u,1923224689u,1923311317u,1923845801u,1923932251u,1923972751u,1924201501u,1925042737u,1928482601u,1928903971u,1929862849u,1930403333u,1930447501u,1930534453u,1930915169u,1931085433u,1932025921u,1932608161u,1933798321u,1934350351u,1935121321u,1938264241u,1938285701u,1940048881u,1941454657u,1941746161u,1942183909u,1942608529u,1943951041u,1944125633u,1945042181u,1947867361u,1948642561u,1949584501u,1949646601u,1950483601u,1950987193u,1951469101u,1952298811u,1952513369u,1952968753u,1955324449u,1955898841u,1955950129u,1957009981u,1957073329u,1957283461u,1957705177u,1958102641u,1958468491u,1958613601u,1959519601u,1959659857u,1959880321u,1960708261u,1962810571u,1963149553u,1965007601u,1965258361u,1966146451u,1968002149u,1968134897u,1968237601u,1968661801u,1969734313u,1970065681u,1970097001u,1971139733u,1973398141u,1974420721u,1974474049u,1975591801u,1976295241u,1977147019u,1977257441u,1977619249u,1978602271u,1982123893u,1982259721u,1982826961u,1984089601u,1985348527u,1985652361u,1985754961u,1986262201u,1987020361u,
	1987464449u,1988071801u,1988713189u,1988835713u,1988965861u,1989192277u,1989985453u,1990822961u,1991063449u,1992023461u,1992841201u,1995211801u,1995784961u,1995830761u,1996231189u,1996339649u,1997844157u,1998780001u,1999053601u,1999111801u,1999743661u,2000241751u,2000436751u,2004299641u,2005360351u,2007646961u,2011080751u,2012581441u,2013208681u,2013554869u,2013757681u,2013834961u,2016058681u,2016481477u,2017021333u,2017509601u,2018268253u,2019530113u,2019564769u,2020813873u,2021392369u,2021884343u,2022021001u,2022794641u,2023073101u,2023351681u,2023528501u,2025055033u,2025223597u,2025677161u,2026001341u,2026574201u,2026654201u,2027675701u,2028279793u,2028631361u,2028685753u,2028812399u,2029554241u,2029651561u,2029830409u,2030600833u,2035858117u,2035948201u,2036224321u,2036326501u,2037732451u,2038957921u,2040131809u,2041025581u,2042467741u,2042940563u,2043173273u,2043400681u,2044366633u,2046320701u,2048443501u,2048751901u,2049191761u,2049204781u,2049293401u,2049842203u,2050617713u,2050864921u,2051270221u,2051369281u,2051790521u,2052149221u,2053128361u,2054711381u,2055634561u,2056892761u,2057188501u,2057267941u,2057516461u,2057835781u,2058072041u,2058874201u,2059585921u,2059739221u,
	2060732161u,2062612033u,2064236401u,2064373921u,2065230833u,2065240801u,2065503961u,2066334463u,2067887557u,2068399201u,2068867841u,2069032057u,2069151931u,2070739441u,2071397101u,2071597009u,2071904761u,2072285209u,2072624761u,2073312253u,2073560401u,2075827501u,2075853001u,2076192007u,2078133421u,2080442881u,2080680481u,2080995841u,2081039297u,2081551753u,2082146617u,2083034113u,2083997441u,2084800121u,2084833081u,2085453649u,2085882661u,2086645009u,2086737761u,2088286201u,2089977121u,2090066947u,2092981129u,2093300401u,2095181881u,2095627153u,2096046457u,2097317377u,2099613601u,2100043933u,2100292841u,2100522313u,2101078729u,2101170097u,2101470541u,2101590361u,2101744837u,2101873501u,2102670961u,2104994449u,2105594401u,2106147457u,2107148761u,2107535221u,2108275489u,2108353523u,2108761201u,2111416021u,2111488561u,2111732857u,2112030361u,2114643217u,2115769633u,2115986557u,2116483027u,2116541221u,2117031263u,2117555641u,2117725921u,2117955451u,2118621097u,2120096161u,2121791101u,2121877801u,2123334577u,2123601751u,2124078653u,2124691213u,2125053721u,2125367881u,2126689501u,2126800747u,2127197489u,2127768481u,2127818161u,2128104001u,2128392631u,2128719853u,2128925989u,2129304997u,
	2129331241u,2129796781u,2130134533u,2130804481u,2131004737u,2131811501u,2134906957u,2136546061u,2137052881u,2139155051u,2140082101u,2140483381u,2140538401u,2140699681u,2140771609u,2141236021u,2141340833u,2141576599u,2141744221u,2141843041u,2142324367u,2144961253u,2146582621u,2147022749u,2147291821u,2147418113u,2147429509u,2147744041u,2148929761u,2150812709u,2150849317u,2151835381u,2152627801u,2154446641u,2155046141u,2155416251u,2156100421u,2156151313u,2158577569u,2159003281u,2159678053u,2160272353u,2161342261u,2163951217u,2164282177u,2164862701u,2165183077u,2165266621u,2165571857u,2166133001u,2166414851u,2167577527u,2168431201u,2168869949u,2169158479u,2169278881u,2170186021u,2170282969u,2171029609u,2172155819u,2173227301u,2173499329u,2173540951u,2173579801u,2174349029u,2174837281u,2175126601u,2175406201u,2175646177u,2177374321u,2177537543u,2177645557u,2177694541u,2178082901u,2178672517u,2178939221u,2178944461u,2179389889u,2179515601u,2180221201u,2182200907u,2182281601u,2182693717u,2182802689u,2183385271u,2184384961u,2185223041u,2185362233u,2186762569u,2187717761u,2188955501u,2190477121u,2193980881u,2194205311u,2194228201u,2194363861u,2195201321u,2195607943u,2195768161u,2195936501u,
	2197126009u,2199617701u,2199700321u,2199931651u,2200115713u,2201169601u,2201474969u,2201924341u,2202101761u,2202205897u,2202735301u,2203226131u,2203539433u,2203649197u,2203856497u,2204338501u,2205160651u,2206095589u,2209642849u,2210578759u,2212405273u,2213431729u,2214761251u,2215407601u,2215782997u,2216255041u,2216430721u,2216960929u,2217299821u,2217708769u,2217879901u,2217951073u,2218767773u,2218852801u,2219069281u,2219072017u,2220067081u,2220157681u,2221010749u,2222229767u,2223876601u,2224252801u,2224278253u,2224519921u,2228123521u,2229468697u,2230305949u,2231332357u,2232701251u,2233031701u,2233186201u,2233511281u,2234003857u,2239622113u,2240507821u,2241880033u,2241982009u,2243686501u,2244048913u,2244356401u,2244932281u,2245519981u,2245804561u,2245921201u,2246762899u,2246796721u,2246916001u,2248354153u,2248929271u,2249509159u,2249681281u,2249831201u,2251732033u,2254314241u,2254757077u,2254796281u,2255172841u,2255274001u,2255678881u,2256197761u,2256653161u,2256748777u,2256751837u,2258118721u,2260569001u,2260734301u,2262315823u,2262861901u,2264617261u,2265650401u,2266645757u,2268655381u,2269307587u,2269348171u,2270483281u,2272748401u,2274584089u,2276463553u,2276530261u,2278091971u,
	2278677961u,2279223661u,2280284137u,2280630241u,2280656953u,2282310577u,2283289681u,2284148113u,2284416181u,2284569169u,2284660351u,2284775533u,2286701621u,2287788841u,2288451961u,2289251669u,2289624793u,2290316377u,2290910257u,2291205461u,2292068143u,2293939117u,2295209281u,2296894753u,2296995121u,2298291121u,2298727121u,2299190401u,2299876417u,2300628601u,2300795353u,2301292753u,2301745249u,2301828211u,2301931801u,2302024969u,2302419601u,2302695253u,2303036741u,2303523541u,2303611381u,2303681821u,2304120001u,2304344813u,2304710123u,2305087201u,2305360981u,2305787881u,2306909593u,2308955947u,2308966661u,2309027281u,2309241601u,2309405617u,2311558021u,2311575001u,2312542981u,2313774001u,2314756081u,2315137261u,2315727601u,2315820001u,2316123181u,2317802761u,2318497201u,2319724441u,2320224481u,2320527613u,2320690177u,2321591371u,2322648901u,2323147201u,2323329821u,2323952161u,2324742421u,2324799049u,2324867399u,2325338821u,2326319101u,2329267501u,2329584217u,2330569541u,2331181621u,2332301401u,2332627249u,2335341601u,2335379707u,2335640077u,2338157597u,2338728001u,2339165521u,2339464681u,2340460487u,2341131967u,2341590901u,2342644921u,2342993797u,2343710101u,2344310101u,2344578077u,
	2345651137u,2345907961u,2346273961u,2347597981u,2347910461u,2348226091u,2349467389u,2349644449u,2351311921u,2352371251u,2352960361u,2353309981u,2353548601u,2353639681u,2354453561u,2355230749u,2355320101u,2355622721u,2355649921u,2355735089u,2356272367u,2357292421u,2358534361u,2358622897u,2359020301u,2359147141u,2359686241u,2360261989u,2361232477u,2361669521u,2362421953u,2366169241u,2366765851u,2367379201u,2368671661u,2370163001u,2370275041u,2370771181u,2370928337u,2371036361u,2371350101u,2371681081u,2372122963u,2372976563u,2373987781u,2374232977u,2375415841u,2377166401u,2377871941u,2378309041u,2380339837u,2380603501u,2381782597u,2382364601u,2382678101u,2383164577u,2383939741u,2384234281u,2384804129u,2385370261u,2385574201u,2385911809u,2389072321u,2389544977u,2391137281u,2392008631u,2393708761u,2394311233u,2394852601u,2395190161u,2396357041u,2397946357u,2397958381u,2398393661u,2398798801u,2401060117u,2401166041u,2401992349u,2402976967u,2404912501u,2405599561u,2405665297u,2407276081u,2407532629u,2411128441u,2411277019u,2412172153u,2412675721u,2413973071u,2414167741u,2414829781u,2418525607u,2421244921u,2422296241u,2423011501u,2423401681u,2423727433u,2425053643u,2425249601u,2426927329u,
	2427180301u,2428648967u,2428870753u,2428986913u,2429123761u,2429407961u,2430556381u,2430697513u,2430813001u,2431136401u,2431144801u,2432761633u,2432860273u,2433791593u,2433943891u,2434785571u,2434964321u,2434974433u,2435091221u,2436691321u,2436927907u,2437711381u,2437907779u,2438403661u,2438778413u,2439162433u,2442050353u,2442115021u,2442454561u,2443205821u,2443708961u,2443829641u,2444950561u,2445236353u,2448039497u,2448374689u,2449037593u,2449452361u,2449575001u,2449637281u,2449856317u,2449977757u,2450701501u,2452396871u,2453212081u,2453473049u,2453931649u,2454285751u,2455563041u,2456536681u,2457846161u,2459217349u,2459637181u,2461902001u,2462440753u,2463491233u,2463713281u,2463980401u,2467813621u,2468730097u,2470348441u,2470397329u,2470869253u,2470894273u,2471205361u,2473120961u,2473189441u,2473616017u,2473823353u,2474308069u,2474676949u,2475994501u,2476283239u,2477771731u,2477814193u,2478643907u,2480097421u,2480147521u,2480343553u,2482435981u,2482682131u,2484033481u,2484408301u,2485414801u,2486017249u,2486988361u,2488420801u,2488507201u,2488591117u,2489462641u,2490707401u,2490994549u,2492474401u,2492480233u,2494465921u,2494660033u,2494984321u,2495834329u,2497638781u,2498508937u,
	2499327041u,2500452361u,2501012599u,2501091451u,2501748901u,2501771329u,2502274321u,2502317413u,2502525637u,2503908433u,2504008609u,2506087441u,2506529257u,2506733189u,2507121037u,2507909851u,2508178843u,2509198669u,2509698601u,2509860961u,2510085721u,2510363909u,2513230891u,2514105301u,2514589561u,2514929581u,2516684801u,2517516001u,2517572671u,2517767473u,2519297089u,2519621857u,2519819281u,2519926201u,2521333801u,2522790721u,2523182101u,2523193417u,2523476981u,2523947041u,2524474297u,2525070241u,2526525001u,2526566041u,2526678901u,2526866021u,2527395421u,2527812001u,2528291341u,2529410281u,2529827821u,2529854713u,2530351561u,2531277001u,2531449921u,2531575201u,2532226393u,2532559393u,2532630787u,2533465661u,2533797017u,2535516173u,2536014041u,2536808941u,2537105761u,2538074701u,2538376441u,2539024741u,2539406281u,2539736257u,2539967281u,2540469901u,2541660367u,2542479481u,2543019301u,2544020641u,2544590161u,2545660981u,2545934077u,2547492713u,2547621973u,2547796681u,2548051801u,2548840801u,2549080981u,2550139253u,2550780277u,2551365769u,2552418761u,2552575159u,2552782849u,2552791969u,2553272929u,2554610521u,2555219713u,2555391481u,2558637901u,2560104001u,2560600351u,2560891327u,
	2561945401u,2562814621u,2564272621u,2564536201u,2564889601u,2565186137u,2566731217u,2567761057u,2568157801u,2568646001u,2569316113u,2570087521u,2570239441u,2571180247u,2572432801u,2573073721u,2573686441u,2574243721u,2575060949u,2575260241u,2575737361u,2576686861u,2577345541u,2577477889u,2577770561u,2579288041u,2582092189u,2582246701u,2582863921u,2582952769u,2583322381u,2584115101u,2584460701u,2585810161u,2586927553u,2587287001u,2588054401u,2588218777u,2588333293u,2588582089u,2588653081u,2589001309u,2590120501u,2590323877u,2590663681u,2592565417u,2593065721u,2593070011u,2593182901u,2593490153u,2594603437u,2595276353u,2596671001u,2597289241u,2597294701u,2597928961u,2597953639u,2598933481u,2599972453u,2600611861u,2601144001u,2602343521u,2602378721u,2603237713u,2604465013u,2604803701u,2605557781u,2607056761u,2607162961u,2607237361u,2609525161u,2609814313u,2611122229u,2611461529u,2612738161u,2613382201u,2614688801u,2616180821u,2616662881u,2617181281u,2617563031u,2617882807u,2620066681u,2621080741u,2621977627u,2622124597u,2622993661u,2623338001u,2624513401u,2624549929u,2625665701u,2625903601u,2626783921u,2626987277u,2627169121u,2627284987u,2629554353u,2629564561u,2629870153u,2630374741u,
	2630643401u,2631365281u,2632022009u,2632605049u,2634284801u,2634804481u,2634820813u,2635031701u,2635245361u,2638067881u,2639099233u,2642025673u,2642159809u,2642582251u,2643735931u,2645695781u,2646751249u,2646790033u,2648662777u,2648671957u,2649907201u,2650820329u,2651412401u,2651507713u,2654176861u,2654716321u,2654851387u,2656296091u,2656494271u,2657502001u,2658630913u,2658696301u,2659265701u,2659745089u,2659939453u,2660336701u,2661150961u,2661744961u,2662372621u,2662524361u,2662700041u,2662709641u,2663616901u,2664020341u,2665141921u,2668095181u,2668469431u,2670187297u,2670972949u,2672236801u,2672605657u,2672651521u,2674021681u,2676053333u,2677147201u,2677821121u,2678785621u,2678867821u,2679197521u,2680883617u,2680980823u,2681041843u,2682823681u,2683078273u,2683256401u,2683742491u,2684284441u,2685422593u,2685856537u,2687655169u,2688124001u,2688238471u,2689248241u,2689427281u,2690408533u,2690867401u,2690902201u,2692079167u,2693302921u,2693739751u,2693939401u,2694515761u,2695064653u,2695115473u,2696970277u,2700582301u,2700818017u,2700891839u,2701479001u,2701878941u,2702470861u,2704546027u,2704957909u,2705647141u,2705912357u,2706863833u,2707661501u,2708811001u,2708826841u,2709611521u,
	2710638353u,2711314801u,2713095841u,2715586237u,2716157989u,2716275007u,2716368733u,2717428033u,2718074881u,2718920101u,2719319513u,2719940041u,2720754401u,2721666817u,2721721939u,2721727801u,2723194601u,2723330701u,2723753341u,2723859001u,2724552907u,2725357249u,2725818481u,2726438581u,2726640001u,2727014851u,2728102651u,2730680821u,2732475241u,2732995387u,2733156029u,2733329101u,2733494401u,2733504737u,2735309521u,2736316301u,2737916641u,2738184697u,2738645521u,2740336561u,2740575121u,2740576313u,2741749889u,2741814361u,2741937199u,2741992201u,2742234841u,2742823681u,2744329909u,2744634061u,2746021741u,2748148261u,2749015171u,2749138393u,2750055841u,2751708961u,2753333227u,2753538001u,2753722153u,2757680773u,2758158601u,2759392633u,2765323397u,2766006253u,2766065681u,2766172501u,2766901501u,2767672189u,2768304961u,2769080161u,2769602333u,2770560241u,2770687921u,2774295577u,2775563029u,2775827921u,2776874941u,2777887297u,2778304273u,2778517681u,2778813041u,2779302241u,2779477741u,2781117721u,2781226477u,2783289961u,2783626249u,2783647441u,2785732741u,2786028337u,2787998641u,2789218909u,2789540051u,2791053541u,2791678681u,2791893511u,2794689601u,2794946701u,2797002901u,2799557641u,
	2800048717u,2800352011u,2801124001u,2802534877u,2804551741u,2805762961u,2806205689u,2806759801u,2807723737u,2809635901u,2810596741u,2810679481u,2811315361u,2812672981u,2813372869u,2813594521u,2814748201u,2815304401u,2817814001u,2820490961u,2823570433u,2823624181u,2823851773u,2823996961u,2824256377u,2824804693u,2824854913u,2825939801u,2827031221u,2827131841u,2828205397u,2828435941u,2830122181u,2830242961u,2831134657u,2831510881u,2831801401u,2832384133u,2832480001u,2832743713u,2833704841u,2833846561u,2835565063u,2837373883u,2837697773u,2837917633u,2839343689u,2840634109u,2840871041u,2841190381u,2841474601u,2841642301u,2842912381u,2844725941u,2845651033u,2846470453u,2847894377u,2848466281u,2848621987u,2848722131u,2849718781u,2849949991u,2852595517u,2852990449u,2855046421u,2855071801u,2855512909u,2858298301u,2860516693u,2861403841u,2862066481u,2863069201u,2863404727u,2864884771u,2865483601u,2866005139u,2866028551u,2866527841u,2866872781u,2867755969u,2869121641u,2870377309u,2871536561u,2872327321u,2872527733u,2872948321u,2874382853u,2876065951u,2877769501u,2879499169u,2880052969u,2881429741u,2882370481u,2883582901u,2884418629u,2885594497u,2885966161u,2885972701u,2886284401u,2887282129u,
	2887955533u,2890316801u,2890414873u,2892426029u,2893195201u,2894667781u,2895004927u,2898058801u,2899294889u,2899527661u,2899835959u,2900730001u,2903776129u,2906853349u,2914350209u,2915953633u,2916247819u,2918295451u,2919550393u,2919669901u,2920085641u,2920691161u,2923042141u,2923286953u,2923693501u,2924158001u,2924317621u,2924708401u,2927264341u,2928676747u,2929062533u,2929106753u,2929239937u,2930420351u,2930570501u,2930831641u,2931690049u,2931708097u,2932327549u,2932664803u,2933809621u,2933894341u,2934429961u,2936227603u,2936491273u,2936958181u,2937299663u,2939179643u,2941174897u,2941343633u,2942328961u,2942952481u,2943030781u,2943556201u,2944266733u,2944555681u,2944677961u,2945208001u,2945517433u,2945549881u,2947521721u,2948225281u,2948673901u,2950375561u,2951104333u,2951136343u,2951771761u,2954187413u,2955113161u,2956210741u,2956724317u,2957155441u,2957320351u,2958697897u,2959558561u,2961709741u,2964816109u,2964930697u,2965085641u,2965700233u,2966800033u,2967053953u,2967689941u,2968206601u,2969736001u,2974312081u,2974506841u,2975096953u,2975377429u,2976929281u,2976930001u,2977476989u,2978096701u,2978196001u,2978766341u,2979186421u,2979367561u,2980689601u,2980916821u,2982028981u,
	2982072601u,2982283951u,2984619001u,2986025677u,2986570081u,2987230541u,2987414977u,2988134717u,2988607051u,2989297741u,2990152901u,2993462713u,2993495041u,2993666521u,2994098281u,2994415201u,2998202353u,2998467901u,2998850401u,2998919873u,2999691217u,3000688381u,3001561441u,3002281981u,3002647829u,3002823901u,3003310927u,3004007231u,3004443679u,3006704701u,3007909837u,3007991701u,3008110141u,3009628301u,3009756751u,3010328101u,3011304901u,3011421841u,3012089203u,3012624161u,3013708057u,3014101261u,3015502181u,3016350457u,3016957381u,3017144701u,3017444761u,3017887471u,3017920123u,3018147217u,3018576689u,3018720481u,3019333681u,3019916461u,3021190921u,3023095511u,3024108001u,3024774901u,3025350343u,3025708561u,3026575553u,3028586471u,3029349073u,3030393901u,3030469201u,3030758401u,3030994513u,3031135141u,3033332281u,3033332641u,3033369991u,3034203361u,3034402681u,3034817209u,3035175121u,3035375047u,3035837161u,3036079729u,3036809483u,3037203431u,3037295801u,3037781251u,3038190337u,3038880473u,3039463801u,3039681457u,3041984353u,3042630533u,3042763501u,3043917001u,3044238121u,3044430361u,3044970001u,3045287797u,3047241553u,3047896621u,3048014201u,3048159841u,3048432241u,3048467381u,
	3048928861u,3048937849u,3049386451u,3049610257u,3050190163u,3050401681u,3050533861u,3051569233u,3051985681u,3052082593u,3052234081u,3053183869u,3053783161u,3056100623u,3056160929u,3057111721u,3057886591u,3058670677u,3059251301u,3059397793u,3060527041u,3063685633u,3063875881u,3065023921u,3065998717u,3066077161u,3066671479u,3068106301u,3068534701u,3069196417u,3070465561u,3072080089u,3072094201u,3072578741u,3072942211u,3073935481u,3075075901u,3075098041u,3076070257u,3076505209u,3077122133u,3077220301u,3077802001u,3078386641u,3079496551u,3080954449u,3081886603u,3082054697u,3082068013u,3082246801u,3083053387u,3083537689u,3083884651u,3084642001u,3085326181u,3086414761u,3086434561u,3088134721u,3088408429u,3089013313u,3090578401u,3091019777u,3092164069u,3093256537u,3093959257u,3094763851u,3097001401u,3097527577u,3099670657u,3100791421u,3102175297u,3102234751u,3103800701u,3104207821u,3105567361u,3105710609u,3107812849u,3112471297u,3112955209u,3112974481u,3114125071u,3114343441u,3114896689u,3115667521u,3116438417u,3116456071u,3117899161u,3118328161u,3118762921u,3119101921u,3120445697u,3120891757u,3121279201u,3121418161u,3122001001u,3122287981u,3127462001u,3128623561u,3129914881u,3131816689u,
	3132198001u,3132209761u,3133899409u,3135040133u,3136813417u,3138302401u,3139995937u,3140524801u,3141144721u,3143282221u,3144216673u,3145410761u,3147032701u,3149633341u,3149833609u,3150972917u,3151546609u,3154371361u,3155747869u,3156599161u,3156643141u,3157579861u,3157741801u,3158553853u,3159919621u,3159939601u,3160342417u,3163106953u,3163296193u,3164060809u,3164207761u,3165237361u,3165594769u,3166504273u,3167442721u,3167795521u,3169830751u,3170262409u,3172658653u,3172880101u,3175204531u,3175255717u,3176208541u,3176257481u,3177449713u,3178375201u,3179632801u,3180632833u,3181356263u,3181391641u,3182606857u,3182655361u,3182891401u,3184139701u,3185472001u,3185571181u,3185704801u,3186499009u,3187035113u,3187421077u,3187939921u,3189888001u,3190894201u,3191212729u,3193382881u,3193414093u,3195176401u,3195867961u,3196344061u,3196397821u,3196431829u,3197565001u,3197632441u,3197911001u,3197911741u,3198074423u,3199081621u,3199164901u,3199264201u,3199915981u,3203380891u,3203895601u,3205663921u,3206193277u,3207297773u,3207744541u,3208806001u,3208902491u,3210950341u,3212465437u,3213007669u,3213538651u,3214169201u,3215031751u,3215441951u,3217412881u,3218502001u,3219767461u,3219808411u,3220158517u,
	3221580281u,3222693421u,3222889921u,3223077001u,3223878001u,3224143441u,3225020401u,3225049381u,3225081473u,3226002913u,3227082823u,3227209057u,3227618521u,3228648151u,3229131137u,3230915377u,3231743593u,3232060741u,3232475401u,3233558021u,3237992101u,3238307941u,3240392401u,3242533897u,3243596491u,3243805111u,3244517521u,3244709161u,3245204161u,3245477761u,3246206701u,3246238801u,3248236309u,3248313913u,3248891101u,3249258013u,3249266749u,3250348417u,3250552201u,3250700737u,3252148621u,3253665241u,3254927089u,3257334541u,3258647809u,3258892801u,3261114601u,3262284721u,3262472797u,3263097641u,3263568901u,3263626957u,3264628081u,3264820001u,3265122451u,3267417677u,3267776161u,3268506541u,3268841941u,3270933121u,3271076771u,3271999249u,3272030401u,3272256001u,3272702497u,3273449257u,3274264033u,3275218171u,3275671969u,3276075709u,3276102787u,3276238333u,3277047649u,3277653133u,3278640289u,3280067129u,3280593611u,3281736601u,3282974857u,3284228881u,3284630713u,3285566101u,3285725701u,3287174129u,3288757249u,3290428801u,3292356943u,3294029377u,3295362727u,3296403601u,3297427561u,3299246833u,3299956747u,3301164901u,3301335577u,3302322241u,3304307341u,3305644849u,3305829073u,3306393751u,
	3306686659u,3306957593u,3307124821u,3308325301u,3309632321u,3310858777u,3311484121u,3312489577u,3312536569u,3313196881u,3313744561u,3314111761u,3315139717u,3316525801u,3316579981u,3319323601u,3320669437u,3323308501u,3323590463u,3323829169u,3326617057u,3326665537u,3326971301u,3327488893u,3328354801u,3328437481u,3329284561u,3330883781u,3331422343u,3332101201u,3332184841u,3332800021u,3333016177u,3334350781u,3335190001u,3336236461u,3336384031u,3337776883u,3339299881u,3340160881u,3340214413u,3341638441u,3342005633u,3342769921u,3342871081u,3343770001u,3343969981u,3344191241u,3345585407u,3345878017u,3346172189u,3347570941u,3347908801u,3348140401u,3348271081u,3349218881u,3349275151u,3349340611u,3350342477u,3350993969u,3352091557u,3353166181u,3353809537u,3355382857u,3355610977u,3355953001u,3356529001u,3357417181u,3359737921u,3360511981u,3361897441u,3363360841u,3366862633u,3369139201u,3369251047u,3370514011u,3371024521u,3371452921u,3371693063u,3372667121u,3373086601u,3373454161u,3373684081u,3374598781u,3377265607u,3378014641u,3380740301u,3381052177u,3381901921u,3385842877u,3386603221u,3387014401u,3387487351u,3388007161u,3388350181u,3389030261u,3394104121u,3394456381u,3395091311u,3399205591u,
	3399890413u,3402234749u,3404705473u,3405294361u,3406329577u,3407609221u,3407652721u,3407772817u,3407952169u,3408135121u,3408200641u,3409339393u,3409497181u,3411250081u,3411338491u,3411574801u,3411829693u,3412575097u,3413440801u,3413656441u,3413894617u,3414918001u,3415025629u,3415379701u,3415832137u,3417522841u,3419588767u,3420143941u,3421044901u,3421562401u,3421845001u,3423222757u,3423580481u,3424593481u,3427038721u,3427050673u,3428133103u,3429457921u,3429982081u,3430422407u,3430804297u,3431460781u,3432192961u,3432695921u,3432997537u,3433439341u,3433458073u,3434575327u,3435973837u,3438709681u,3438721441u,3439583521u,3439633681u,3440195713u,3441837421u,3441861481u,3442631257u,3443019667u,3443704261u,3445230661u,3447654211u,3448817281u,3449768513u,3450717901u,3453354607u,3453900913u,3458257741u,3461605561u,3461861761u,3462426241u,3463737019u,3463907761u,3464236901u,3465389899u,3466026061u,3466158361u,3466560241u,3468903571u,3470006161u,3470716657u,3471001777u,3474335437u,3476582701u,3478650721u,3479004107u,3479711509u,3479716321u,3480174001u,3481937341u,3482161261u,3482948917u,3483556021u,3483871969u,3485027911u,3485607139u,3485747521u,3487441321u,3488303281u,3489958697u,3490107373u,
	3491763493u,3492178873u,3492883081u,3493262761u,3493832401u,3495447929u,3495943153u,3496558301u,3496727521u,3497607433u,3499095601u,3499146721u,3501194797u,3502404577u,3502454401u,3502917061u,3504132113u,3504570301u,3504722521u,3505631677u,3508507801u,3512030497u,3512291021u,3512369857u,3512949529u,3513604657u,3515023801u,3516565057u,3517415749u,3519318721u,3520175581u,3520491283u,3520909237u,3520934177u,3521945041u,3523954141u,3524086333u,3525088961u,3529119361u,3529669501u,3529864391u,3532687201u,3533662129u,3533856913u,3534510001u,3535036441u,3535644241u,3535849801u,3536476021u,3537280361u,3538213381u,3542303047u,3543203333u,3543220801u,3543755801u,3544181551u,3547777349u,3548378341u,3549286001u,3549988261u,3552158521u,3553567057u,3553728841u,3554383141u,3555636481u,3556116361u,3557646401u,3559062241u,3560114681u,3561826129u,3562963973u,3563021449u,3563340457u,3566428301u,3567688213u,3568781399u,3571146091u,3571451677u,3572979481u,3573005701u,3573842581u,3574532221u,3574891757u,3575706133u,3576237301u,3576804001u,3576818293u,3577228201u,3577288121u,3577354741u,3577836991u,3578189341u,3579028597u,3579288691u,3579940513u,3582711841u,3583249921u,3583604161u,3584800801u,3586143541u,
	3586803661u,3586833253u,3587553971u,3587802901u,3588111721u,3589937261u,3590409439u,3593259181u,3593276353u,3593464957u,3593541601u,3594110081u,3594300841u,3594968821u,3595600801u,3595874801u,3596491907u,3596815169u,3597270517u,3597761761u,3598497631u,3598772761u,3600918181u,3602006101u,3602171311u,3602890507u,3603030637u,3604182121u,3604213909u,3605151241u,3607369481u,3607806313u,3611571121u,3612298321u,3612825221u,3614770573u,3615565681u,3616574081u,3618244081u,3618918001u,3620631169u,3624041701u,3627991081u,3628512301u,3628526287u,3629431741u,3630291841u,3630596257u,3631828481u,3632452741u,3634571473u,3635771833u,3635993089u,3636657361u,3637718281u,3637831753u,3639975553u,3640175341u,3642747313u,3649116277u,3649180601u,3649965281u,3650158849u,3651572609u,3653803501u,3656355841u,3658678849u,3658730893u,3658741021u,3662387977u,3662503093u,3663084541u,3663549001u,3664146889u,3665242951u,3665439361u,3666600593u,3666709201u,3668926801u,3669587533u,3670572517u,3672754633u,3673078513u,3674917139u,3677108161u,3677180797u,3679657997u,3680455117u,3680845579u,3681257581u,3681626467u,3682471321u,3684201751u,3685480201u,3685647701u,3685775741u,3692307161u,3692934001u,3693853801u,3695628133u,
	3697278427u,3697673959u,3697952401u,3700801861u,3704091751u,3705582073u,3705623281u,3705947857u,3707230429u,3708123301u,3708905341u,3709626961u,3710144201u,3711367621u,3711456001u,3712280041u,3712887289u,3713287801u,3713332321u,3713448769u,3715938721u,3716344201u,3717981001u,3718226401u,3721486081u,3722793481u,3723410161u,3723699373u,3725016749u,3725696141u,3727589761u,3727828501u,3728463481u,3729097633u,3732347521u,3732472261u,3733761739u,3736293461u,3741762181u,3742120801u,3745081901u,3745192001u,3746082901u,3746101189u,3746734201u,3747356581u,3748606369u,3749383681u,3750270721u,3751005457u,3751554581u,3751782737u,3753602191u,3753861707u,3754483201u,3754680403u,3756668401u,3759781369u,3760622689u,3760896133u,3762110881u,3767640601u,3767865601u,3770496473u,3772354483u,3773061337u,3774337201u,3776698801u,3778341121u,3782157841u,3782625301u,3783166381u,3783722701u,3784123501u,3784755151u,3786262241u,3787491457u,3789787501u,3791614681u,3791707327u,3791867821u,3792666241u,3793746853u,3794104987u,3795206827u,3796118087u,3796666237u,3798040471u,3798626833u,3799111681u,3800084401u,3800513761u,3801823441u,3804261733u,3805181281u,3805699501u,3806669491u,3807044251u,3807112123u,3807308269u,
	3807749821u,3809018947u,3809423801u,3813919453u,3815417629u,3815910673u,3815945869u,3817422181u,3817561777u,3817706621u,3819502651u,3820084741u,3820463101u,3821233121u,3822308461u,3824601781u,3827035237u,3831667313u,3832413097u,3832559641u,3832646221u,3832807681u,3833208961u,3834444901u,3835537861u,3835591921u,3839716441u,3840473737u,3842941741u,3843146341u,3844074781u,3846174151u,3846532801u,3846762601u,3847106803u,3847985837u,3849809041u,3850058689u,3852800033u,3853584967u,3854657521u,3856609531u,3858853681u,3859004501u,3861601129u,3862404013u,3863326897u,3865604023u,3866389033u,3867183937u,3868602661u,3870481681u,3870667321u,3871693189u,3872902051u,3874471147u,3874523017u,3875096893u,3875965417u,3876602521u,3876859351u,3880251649u,3881445751u,3883439647u,3884747581u,3886515361u,3886643801u,3887423437u,3887635753u,3888441001u,3890243701u,3890462401u,3890619097u,3891209851u,3891338101u,3891892421u,3891919417u,3892244491u,3892863301u,3893670001u,3893979941u,3894053311u,3894518881u,3896079281u,3897197641u,3897241129u,3897869201u,3898857757u,3898906129u,3900327241u,3901632313u,3901730401u,3901871161u,3902738581u,3903543281u,3903711841u,3904576201u,3905533721u,3905876501u,3906869461u,
	3907357441u,3907577521u,3907752241u,3910414201u,3911700001u,3912174421u,3914015281u,3914864773u,3914880337u,3914923211u,3915467341u,3915604421u,3915826433u,3915921241u,3916203721u,3916342789u,3917319841u,3918227437u,3922321561u,3922752121u,3923817397u,3923905321u,3924718057u,3924721729u,3925683973u,3926200321u,3926912669u,3927284131u,3928256641u,3929293061u,3929584681u,3933485501u,3934940833u,3935864017u,3936123601u,3936927457u,3939817201u,3940139641u,3942955081u,3944712521u,3945165841u,3945322601u,3947233201u,3947383201u,3949249501u,3951382753u,3951813601u,3953408801u,3953949421u,3955572001u,3955764121u,3956938921u,3957731281u,3958597301u,3958930441u,3959157217u,3959578801u,3959921521u,3960728641u,3962037061u,3962786213u,3964790509u,3966350203u,3966877883u,3967343161u,3969787267u,3971095301u,3971294713u,3972960433u,3973396141u,3973548601u,3973556837u,3975414301u,3978028421u,3979485931u,3981047941u,3982017601u,3982156993u,3986835121u,3987528793u,3987960913u,3988551763u,3989570761u,3990268261u,3991124341u,3992697997u,3993956353u,3994051321u,3996987251u,3997536427u,3998275849u,3998554561u,4004179201u,4004332417u,4005660961u,4007365741u,4008224221u,4008263401u,4011996871u,4013467081u,
	4014932857u,4014986977u,4015029061u,4015548769u,4016302681u,4017684529u,4018283501u,4019646961u,4020144133u,4020441283u,4023179551u,4023453889u,4026597361u,4026684481u,4026822577u,4027012021u,4027518961u,4028465873u,4028771849u,4030864201u,4031223841u,4033380097u,4033491991u,4033542721u,4034969401u,4034993269u,4035028861u,4035498409u,4036395581u,4037628013u,4040676121u,4042538497u,4044408817u,4044601751u,4044884689u,4047749641u,4048493983u,4051598189u,4051907041u,4053249523u,4053267217u,4054039841u,4057195309u,4057697947u,4058114581u,4058433931u,4059151489u,4059776533u,4060942381u,4061009971u,4064633821u,4065120241u,4065133501u,4065714161u,4067039461u,4067887501u,4068671881u,4071644893u,4072037887u,4074585313u,4075241633u,4075721921u,4076009857u,4076107811u,4077957961u,4079665633u,4079682361u,4083376067u,4085074909u,4085426521u,4086968981u,4087390501u,4088147617u,4088656469u,4088838913u,4092929149u,4093143601u,4093466677u,4094183413u,4096122001u,4098208297u,4098254161u,4098258707u,4099180801u,4099303297u,4100934241u,4103745689u,4105691393u,4106693701u,4108970251u,4109400127u,4109461709u,4109711581u,4110320663u,4111149169u,4113013141u,4113333001u,4113586837u,4113742057u,4115677501u,
	4115891893u,4117058221u,4117447441u,4119741001u,4121286907u,4123265041u,4126312891u,4126424287u,4126852801u,4126884301u,4127050621u,4127696731u,4128469381u,4129891501u,4129914673u,4131665461u,4132720909u,4133048921u,4133928761u,4134204361u,4134273793u,4134696677u,4135847101u,4136916001u,4137262541u,4138747921u,4138838401u,4139015987u,4142256301u,4142655217u,4144596091u,4145196433u,4146685921u,4147919821u,4150174393u,4151084497u,4153142449u,4153689541u,4153758071u,4155375349u,4157008813u,4157652619u,4160472121u,4160523361u,4162880401u,4166032873u,4167025201u,4167038161u,4169092201u,4169867689u,4172804707u,4173482881u,4173838327u,4176142891u,4176385921u,4176538241u,4181350177u,4182995521u,4183664101u,4185636781u,4186561633u,4187360341u,4189357987u,4189909501u,4191864013u,4192060699u,4193496803u,4194144361u,4195300681u,4195843037u,4196323561u,4197177629u,4199202001u,4199246161u,4199529601u,4199612257u,4199932801u,4201014949u,4201794451u,4202009461u,4202842561u,4204344601u,4205237201u,4206006229u,4206295433u,4210095667u,4210922233u,4211044201u,4211640811u,4211747581u,4212105409u,4212413569u,4212665491u,4215885697u,4216799521u,4217128021u,4217502449u,4218773491u,4218900001u,4219849297u,
	4220122321u,4223060047u,4231459597u,4231512709u,4231653481u,4231678933u,4231686061u,4232966251u,4233223501u,4234009397u,4234223701u,4234224601u,4235818861u,4235887891u,4237212061u,4239462241u,4241343151u,4241478913u,4243744201u,4244022301u,4244657077u,4244663651u,4246462657u,4246910641u,4247772913u,4247990917u,4250920459u,4251904273u,4253605201u,4255288237u,4255695013u,4255766969u,4257003353u,4257672049u,4261352869u,4261932001u,4265537221u,4265864281u,4267277291u,4268877361u,4269382741u,4271267333u,4271582809u,4275011401u,4276933201u,4277526901u,4277982241u,4278067921u,4278305651u,4279658761u,4281766711u,4282867213u,4283998993u,4284050473u,4285148981u,4286383201u,4286813749u,4288664869u,4289470021u,4289641621u,4289884201u,4289906089u,4293088801u,4293329041u,4294868509u,4294901761u
};

/* Factoring-only globals: */
int restart;
uint64 checksum1;	/* Sum (mod 2^64) of all q's tried during a predetermined interval */
uint64 checksum2;	/* Sum (mod 2^64) of all 2^p mod q's for  a predetermined interval */

#ifdef FACTOR_STANDALONE
	/* In standalone, need to locally define some Mlucas.h-declared globals
	which would normally be defined in Mlucas.c. */

	uint32 PMIN;	/* minimum #bits allowed for FFT-based mul */
	uint32 PMAX;	/* maximum #bits allowed depends on max. FFT length allowed
					  and will be determined at runtime, via call to given_N_get_maxP(). */
	char cbuf[STR_MAX_LEN];
	char in_line[STR_MAX_LEN];
	/* Declare a blank STATFILE string to ease program logic: */
	char STATFILE[] = "";
#endif

/* Adjust the # of sieving primes to reflect that modmul cost
goes up very quickly with increasing # of 64-bit words in q.

Note that the total allocated memory is roughly (16 bytes * NUM_SIEVING_PRIME).

NB: There are 203280220 odd primes < 2^32.
*/
#ifndef NUM_SIEVING_PRIME
	#if(defined(NWORD))	/* N-word P, N presumed to be > 1: */
		#if FAC_DEBUG
			#define NUM_SIEVING_PRIME	10000
		#else
			#define NUM_SIEVING_PRIME	10000000
		#endif
	#elif(defined(P4WORD))	/* 4-word P: */
		#if FAC_DEBUG
			#define NUM_SIEVING_PRIME	10000
		#else
			#define NUM_SIEVING_PRIME	5000000
		#endif
	#elif(defined(P3WORD))	/* 3-word P: */
		#if FAC_DEBUG
			#define NUM_SIEVING_PRIME	10000
		#else
			#define NUM_SIEVING_PRIME	2000000
		#endif
	#elif(defined(P2WORD))	/* 2-word P: */
		#if FAC_DEBUG
			#define NUM_SIEVING_PRIME	10000
		#else
			#define NUM_SIEVING_PRIME	1000000
		#endif
	#else	/* 1-word P limit is set by #of bits p can have so 120^2*p < 2^64: */
		#if FAC_DEBUG
			#define NUM_SIEVING_PRIME	10000
		#else
			#define NUM_SIEVING_PRIME	50000
		#endif
	#endif
#endif

/*
...Code to pretest for "small" factors q=2*k*p+1
   of Mersenne numbers M(p) = 2^p - 1.

   Uses the Left-to-Right binary method of exponentiation
   to quickly test whether [M(p)+1] mod q = 1, which is equivalent to
   testing whether M(p) mod q = 0, i.e. whether q divides M(p).

   We want the sieving code to be cache-friendly, which means minimizing
   the size of the sieve-related bit arrays in working memory. One way to
   achieve this is to break a single sequential sieving loop that tests
   all candidate factors of form q = 2*k*p + 1 satisfying some smoothness
   property (i.e. q not divsible by small primes below some predetermined
   threshold - note that it is easily seen that direct nonfactorial compositeness
   testing of each q is *not* cost-effective, since checking whether e.g.
   2^(q-1) == 1 mod q is as or more expensive than checking whether q divides
   2^p-1, i.e. whether 2^p == 1 mod q) into a number of smaller sieving
   steps, each of which checks only q's having k == 1 modulo some product
   of small primes. By eliminating k's which lie in residue classes such
   that the resulting q cannot possibly be prime we increase the density of
   candidate q's in our smaller "sievelets", and at the same time require
   smaller bit arrays to be held in working memory.

   Here, we use (p,k) mod 60 correlations to reduce the number of possible k's
   by roughly three-fourths. Specifically, a number of form q=2*k*p+1
   can only be prime if the value of k mod 60 appears in the appropriate
   p mod 60 row of the following table:

			Acceptable values of k%60:
	p%60 =  1: 00,03,08,11,15,20,23,24,35,36,39,44,48,51,56,59
	p%60 =  7: 00,05,08,09,12,17,20,24,29,32,33,44,45,48,53,57
	p%60 = 11: 00,01,04,09,13,16,21,24,25,28,33,36,40,45,48,49
	p%60 = 13: 00,03,08,11,12,15,20,23,27,32,35,36,47,48,51,56
	p%60 = 17: 00,03,04,07,12,15,19,24,27,28,39,40,43,48,52,55
	p%60 = 19: 00,05,09,12,17,20,21,24,29,32,36,41,44,45,56,57
	p%60 = 23: 00,01,12,13,16,21,25,28,33,36,37,40,45,48,52,57
	p%60 = 29: 00,04,07,12,15,16,19,24,27,31,36,39,40,51,52,55
	p%60 = 31: 00,05,08,09,20,21,24,29,33,36,41,44,45,48,53,56
	p%60 = 37: 00,03,08,12,15,20,23,24,27,32,35,39,44,47,48,59
	p%60 = 41: 00,03,04,15,16,19,24,28,31,36,39,40,43,48,51,55
	p%60 = 43: 00,05,08,12,17,20,21,32,33,36,41,45,48,53,56,57
	p%60 = 47: 00,04,09,12,13,24,25,28,33,37,40,45,48,49,52,57
	p%60 = 49: 00,11,12,15,20,24,27,32,35,36,39,44,47,51,56,59
	p%60 = 53: 00,03,07,12,15,16,27,28,31,36,40,43,48,51,52,55
	p%60 = 59: 00,01,04,09,12,16,21,24,25,36,37,40,45,49,52,57

Where did these come from?
Let pm := p%60, and km := k%60. For p prime > 5, we know p cannot be divisible by 2, 3 or 5.
Working modulo the product of small primes 2^2.3.5 = 60, we require GCD(p%60, 60) = 1, which allows
pm = 1,7,11,13,17,19,23,29,31,37,41,43,47,49,53,59. Now, since we also know that prime-exponent
Mersenne factor candidates must have form

q = 2*k*p + 1 = 2*(i*60 + km)*(j*60 + pm) + 1 == 2*km*pm + 1 (modulo 120) .

For any value of pm, the only possible value of km are those for which
GCD(2*km*pm + 1, 120) = 1, i.e. 2*km*pm is not divisible by 3 or 5.

Let's try pm = 1 as an example:

pm := p%60 = 1:

km := k%60 :            0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59
2*km*pm+1  :            1  3  5  7  9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99.01.03.05.07.09.11.13.15.17.19
GCD(2*km*pm+1, 120)   : 1  3  5  1  3  1  1 15  1  1  3  1  5  3  1  1  3  5  1  3  1  1  5  1  1  3  1  5  3  1  1  3  5  1  3  1  1  5  1  1  3  1  5  3  1  1  3  5  1  3  1  1 15  1  1  3  1  5  3  1
Acceptable? (* = yes) : *        *     *  *     *  *     *        *  *        *     *  *     *  *     *        *  *        *     *  *     *  *     *        *  *        *     *  *     *  *     *        *

We further use quadratic residues: From the form of N = 2^p - 1, we have that
2^p == 1 (mod N). Multiplying by 2, we see that 2^(p+1) == 2 (mod N). Since p is odd
(primality of p is not crucial here, just oddity), the LHS is an even power of 2,
hence a perfect square, which implies that 2 is a QR mod N, and thus also a QR mod
any factor q of N. That immediately implies that q == +-1 (mod 8), i.e. that any
factor q must be of the form 8*n +- 1. Thus our set of acceptable km's is cut in half:

km := k%60 :            0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59
2*km*pm+1 % 8         :+1 +3 -3 -1 +1 +3 -3 -1 +1 +3 -3 -1 +1 +3 -3 -1 +1 +3 -3 -1 +1 +3 -3 -1 +1 +3 -3 -1 +1 +3 -3 -1 +1 +3 -3 -1 +1 +3 -3 -1 +1 +3 -3 -1 +1 +3 -3 -1 +1 +3 -3 -1 +1 +3 -3 -1 +1 +3 -3 -1
Acceptable? (* = yes) : *        *              *        *           *              *        *  *                                *  *        *              *           *        *              *        *

Thus, the divisibility-by 3,5 test leaves 32 acceptable residue classes,
precisely half of which are eliminated by the QR criterion.
An analogous 32/16 pattern occurs for the other 15 possible values of p%60.

NOTE that since the smallest possible k value = 1, this corresponds to the zero bit of
our sieve, i.e. k%60 = 0 is aliased to k%60 = 60 - that's why the k%60 == 0 pass is
done last among the 16 k%60 passes.

                        *     *     *     *     *

   REVISION CONTROL:

   01/04/03:	First C version. Limit = 2^65. ASM mul macros only for Alpha.

   06/??/03:	Nonportable (Alpha and Itanium only) C version. Limit = 2^ 96.

   12/31/03:	Nonportable (Alpha and Itanium only) C version.
				Limit = 2^128, p up to 2^114 via -DP2WORD compile-time #define.

   06/01/05:	Nonportable (Alpha and Itanium only) C version.
				Limit = 2^192, p up to 2^128 via -DP3WORD compile-time #define.
				Can also handle case where p (actually, p*120) << 2^128 but q > 2^128
				via combination of -DP2WORD and -DQ3WORD compile-time #defines.
				This invokes a fast version of the 8-operand modular powering routine
				which assumes that only the lower 128 bits of each octet of q's differ.

   05/15/06:	***First Official Release***
   				Portable C version with ASM integer-multiply macros for a decent variety of 64-bit
 				architectures (Alpha, Itanium, AMD64, PowerPC, IBM Power64).
 				Factor limits of 2^128/192/256 via PxWORD compile-time #define with x = 2,3,4.

   01/15/06:	Arbitrary-length integer aritmetic (but optimal for "small" integer lengths,
                say on the order of ten 64-bit words) via enhancements to the mi64 library.
                Invoke by defining NWORD, e.g. via -DNWORD.

                        *     *     *     *     *

   COMPILING THE PROGRAM IN STANDALONE MODE: Below are the best compile options for various
   platforms on which the code has been run successfully. If your particular hardware/software
   is not represented, please let me know what kinds of results you get with your compiler.

   The compile sequences assume that the sourcefile is called factor.c
   and produce an executable named "factor".

  *** Alpha: ***

   NOTES: Alpha 21264 (ev6) and above should give by far the best per-cycle performance
   of all the Alphas, because it fully pipelines the MULL64 and MULH64 hardware integer
   multiply instructions, i.e. needs effectively just 2 cycles to get a full-length
   128-bit product of unsigned 64-bit integers.
   The 21164 (ev5) only partially pipelines these - it can start a new integer mul instruction
   every 8 cycles, so needs effectively 16 cycles for a 128-bit product.
   The 21064 (ev4) doesn't pipeline integer muls at all, so will need 30-40 cycles for such
   a product. Although integer muls are the rate-limiting operation on the slower machines,
   they are not on the 21264, so in practice the 21264 gives ~4-5x better per-cycle factoring
   performance than the 21164 and ~12-15x better than the 21064.

  *(1A) Digital/Compaq/HP C compiler (cc) for TruUnix V5.0+: if you're not sure what type of Alpha
   CPU you have, substitute 'host' for the architecture-specific (ev4/generic/ev6) flag below.

   21064/ev4/ev45:         cc -o factor -DFACTOR_STANDALONE -O5 -fast -arch ev4     -tune ev4     factor.c -lm
   21164/ev5/ev56/generic: cc -o factor -DFACTOR_STANDALONE -O5 -fast -arch generic -tune generic factor.c -lm
   21164/ev6/ev67/ev68:    cc -o factor -DFACTOR_STANDALONE -O5 -fast -arch ev6     -tune ev6     factor.c -lm

  *(1B) Digital/Compaq/HP C compiler (ccc) for Linux: same as for Unix, but replace 'cc' with 'ccc'.

  *(1C) Digital/Compaq/HP C compiler (cc) for VMS (Since this is integer-dominated code I'm not sure
   if all these are necessary, but some of the floating-point ones apparently are, and the others certainly won't hurt):

   *** NEED TO FIGURE OUT HOW TO INCLUDE FACTOR_STANDALONE #DEFINE UNDER VMS! ***
   cc/decc/lis/mach/nodebug/float=ieee_float/ieee_mode=fast/arch=host/assume=accuracy_sensitive/opt=(inline=speed,level=5,tune=host,pipeline,unroll=1) factor.c

  *(1D) Gnu C for Alpha/Linux: I'm not sure what the best compile options are. Based on past
   experience, I strongly suggest using either the native Digital/Compaq/HP C compiler,
   or a prebuilt binary based on it, as gcc generally gives suboptimal performance on most platforms.


  *** IA64 ***

  *(1A) Intel C (icc) for IA64: please make sure to use v8.0 or later!

   icc -o factor -static -DFACTOR_STANDALONE -O3 factor.c


  *(2B) HP C for IA64/HPUX:

   cc -o factor -DFACTOR_STANDALONE +O3 factor.c -lm

   (Note that you'll see a bazillion ignorable warnings of the form
    Warning 1001: "factor.c", line 6574 # Conversion from 'int' to
    '__fpreg' performed using intermediate conversion to __float80. )


  *** Athlon-64 (a.k.a. Opteron) ***

   gcc -o factor -DFACTOR_STANDALONE -m64 -O3 factor.c
*/

/* Various compile-time #defines: (define via -D[option], unless noted otherwise) -
   Subordinate #defines are indicated via indentation (e.g. PIPELINE_MUL192 is only
   meaningful if P3WORD is in effect) :

	FACTOR_STANDALONE - build as a standalone program, rather than a callable
						factor() subroutine.

	FAC_DEBUG - define = 1 in factor.h to enable debugging diagnostic prints
				and assertions of the form ASSERT.

	DBG_SIEVE - define = 1 to debug the sieve without actually spending time
				doing trial divides. NOTE: Requires FAC_DEBUG = 1.

	NOBRANCH - define to invoke branchless versions of key code segments.

	QUIT_WHEN_FACTOR_FOUND - Default is to finish all 16 passes to the specified depth,
	i.e. to find *all* factors below the factoring limit. To instead stop immediately
	if a factor is found, define this one.

***	USE_FLOAT - Only relevant if no PxWORD with x > 1 is defined,
	i.e. when dealing with 1-word p's (more specifically, p such that 120*p < 2^64.)
	Define this flag to use specialized floating-double-based code (cf. twopmodq80.c)
	to do the bulk of each modular powering. This limits factor candidates to < 2^78.
	If this flag is invoked, the user may not invoke the USE_65BIT or USE_95BIT flags.

	USE_FLOATING_MULH64 - currently unsupported

	USE_65BIT - Only relevant if no PxWORD with x > 1 is defined,
	i.e. when dealing with 1-word p's (more spedifically, p such that 120*p < 2^64.)
	Default is to use generic 96-bit factor routines for all q's > 64 bits.
	Define this flag to use specialized 65-bit code to handle q's in [2^64, 2^65).

***CURRENTLY UNSUPPORTED***	USE_95BIT - Only relevant if no PxWORD with x > 1 is defined,
	i.e. when dealing with 1-word p's (more specifically, p such that 120*p < 2^64.)
	Default is to use generic 96-bit factor routines for all q's > 64 bits.
	Define this flag to use specialized 95-bit code to handle q's in [2^65, 2^95).

	USE_128x96 - Only relevant if no PxWORD with x > 2 is defined, and only for q's in [2^64, 2^96].
	Invoke to replace calls to the full 128-bit modmul routines with ones to
	special 96-bit or 128/96-bit-hybrid hyroutines when the operands allow, specifically q < 2^96.
	There are 3 currently supported values:

		0 (or undef'd) - use  fully 128-bit routines for q's in [2^64, 2^96]

		1 - use strictly   96-bit routines for q's in [2^64, 2^96]

		2 - use hybrid 128_96-bit routines for q's in [2^64, 2^96]

	P1WORD - p small enough such that p*120 < 2^64, factor limit q < 2^96

	P2WORD - factor limit q < 2^128, i.e. q needs 2 full 64-bit words of storage.
	Also needed if p*120 is sufficiently close to 2^64 that the assumption of the
	96-bit modmul routines that the high 32 bits of q_j = 2*(k%60 + 60*j)*p + 1
	change only rarely with increasing j is no longer tenable.

	P3WORD - factor limit q < 2^192, i.e. q needs 3 full 64-bit words of storage.

		PIPELINE_MUL192 - when defined, uses pipelined versions of 192-bit MUL macros.

	P4WORD - factor limit q < 2^256, i.e. q needs 4 full 64-bit words of storage.

		PIPELINE_MUL256 - when defined, uses pipelined versions of 256-bit MUL macros.

	NWORD - Arbitrary-length p and q, only restriction is that (as for all other size ranges) kmax < 2^64 .
*/

/*********************************************************************************************************************************/

#ifdef FACTOR_STANDALONE
	int main(int argc, char *argv[])
	{
#else
  #if FAC_DEBUG
	#error FAC_DEBUG only permitted in standalone mode!
  #endif
	/* exponents > 64 bits require standalone-mode build: */
	int factor(char *pstring, double bmin, double bmax)
	{
#endif

#ifdef FACTOR_STANDALONE

	/*...file pointer	*/
	FILE *fp, *fq;

	char stFlag[STR_MAX_LEN];

	/* Allocate storage for any needed Globals declared in Mdata.h
	(in non-standalone mode these are instead defined in Mlucas.c): */
	int MODULUS_TYPE   = 0;
	char pstring[STR_MAX_LEN] = "";

	/*...program version with patch suffix... */
	const char VERSION[] = "3.0x";			/* <--- a suffix of x, y, or z indicates a beta code. */

	const char OFILE  [] = "results.txt";	/* ASCII logfile containing factors found and/or
											final factoring-run result ONLY for each assignment */
	/* Restart file name:
	This is set at runtime, based on either command-line -file flag argument
	or (if -file {} not used) the exponent being processed. */
	char RESTARTFILE[STR_MAX_LEN] = "";

	double bmin = 0.0, bmax = 0.0;	/* store log2 of (min|max) factoring bound */
#endif

	int PWORDS;	/* Number of 64-bit words needed to store p */

	/* Make these large enough to hold the max. p,q supported by the software (currently,
	256 bits) then use as many of the subfields as needed, depending on the values of P,QWORDS.
	*/
	uint32	true_false, findex, nbits_in_p = 0, nbits_in_q = 0, lenP = 0, lenQ = 0, bits_in_pq2 = 0;
	uint64	*factor_ptmp = 0x0, *factor_k;	/* Use this array to store the factor k's (assumed < 2^64) of any factors found. */
#if(defined(P1WORD))
	uint64	p=(uint64)0,two_p,p120,q,q2;
	uint32	ntimes_2pow64;
#else
	uint64	*p, *two_p, *p120, *q, *q2;
#endif

#if(!defined(TRYQ))
	#define TRYQ	1
#endif
#if(TRYQ < 1)
	#undef TRYQ
	#define TRYQ	1
#endif

	uint32 TRYQM1 = TRYQ-1;

#if(TRYQ > 1)
/*const	uint32 TRYQM1 = TRYQ-1; */
  #if(defined(P4WORD))
	uint256	q_to_try[TRYQ];
  #elif(defined(P3WORD))
	uint192	q_to_try[TRYQ];
  #elif(defined(P2WORD))
	uint128	q_to_try[TRYQ];
  #else
	uint64	q_to_try[TRYQ];
	uint128 q128_0,q128_1,q128_2,q128_3,q128_4,q128_5,q128_6,q128_7;
  #endif
#endif
	 int32 q_index;

	int   nargs,itmp;
	/* pdsum stores the sums needed for the base (%30 == 0) candidate of each length-30 interval;
	pdiff stores the diffs/2 of these absolute offsets, circularly shifted to the right one place,
	since to update we need diff[j] = curr_p(current) - curr_p(previous) = (pdsum[j] - pdsum[j-1])/2,
	i.e. pdiff_8[i] = (pdsum_8[i]-pdsum_8[i-1])/2, i computed using mod-8 arithmetic and pdsum_8[] using mod-30 arithmetic:
	*/
	uint32 itmp32,itmpA,itmpB,itmpC,itmpD, pdiff_8[8] = {2,1,2,1,2,3,1,3}, pdsum_8[8] = { 0, 2, 6, 8,12,18,20,26};
	uint64 itmp64;
	const uint64 two64mod3 =1,two64mod5 =1,two64mod7 =2,two64mod11=5,two64mod13=3,two64mod17=1,two64mod19=17;
	const uint64 two64mod60=16;
	uint32 pmod60,kmod60,qmod8;
	uint64 res,two64modp;
	uint32 bit,bit_hi,curr_p,sqrt_p,i,ihi,idx,incr[16],isprime,m,ncopies,regs_todo;
	uint32 twop_mod_currp,q_mod_currp,currp_mod_60,lmod60;
	uint32 l,i64,nfactor,word;
	uint32 nprime = NUM_SIEVING_PRIME;	/* Don't make this const, in case we need to reduce it to satisfy MAX_SIEVING_PRIME < (q_min = 2*p+1) */
	uint32 num_pseudo;
#if !ALLOW_PRP
	uint32 f2psp_idx = 0;	/* Index to next-expected Fermat base-2 pseudoprime in the precomputed table */
#endif
	/* LEN is the number of 64-bit words in our sieving bit template. Successive
	bits of the sieve template correpond to successive factor k-values, with bit 0
	corresponding to the smallest possible factor, k = 1 (note the unit-offset!)
	In practice, this full-sized sieve is split into 16 smaller (i.e. hopefully
	cache-sized) "sievelets", each of which contains bits corresponding to
	successive k's from one of the 16 allowable k mod 60 families for the given
	exponent p (more specifically, the given p mod 60 value.) Both full-length
	sieve and 1/16-th length sievelets share the property that each time we run
	through the bits of onesuch we run through 64*LEN worth of k's.
	*/
	const uint32 nclear=6, len=3*5*7*11*13*17, p_last_small = 17;	/* Make sure LEN = product of first NCLEAR odd primes,
									p_last_small = largest odd prime appearing in the product. */
	uint32 prime[] = {3,5,7,11,13,17};	/* Also need the first [nclear] odd primes - since 'const' is treated as a readonly flag
						on *variables*, use [] instead of [nclear] to avoid variable-length array init errors. */
	const uint32 bit_len=64*len/60; 	/* Number of bits/quadwords in each of the 16 mod-60 sievelets	*/
/*   bits cleared of multiples of 3,5,7,11,13, 17 and q mod 8 = +-1 are here:	*/
	uint64 *temp_late = 0x0;		/* Even though we know how large to make this, it's only needed
									for data inits, so we calloc it at runtime and free it later. */
/*	uint64 bitmap[len/60+1],template[len/60+1][16];	* bitmaps corresponding to 16 separate K mod 60 cases are here.*/
	uint64 *bitmap, *template = 0x0;

	uint32 pass,passmin = 0,passnow = 0,passmax = 15;
	uint64 count = 0,countmask,j,k,kmin = 0,kmax = 0,know = 0,kplus = 0,mask;

	/* If restart file found, use these to store bmin/max, kmin/max, passmin/max
	data contained therein (e.g. for comparison with command-line args and determination
	of run status). We don't init them here since if a valid restart file is found,
	all these values should be read from it - that way if we get an "uninitialized"
	warning from the compiler, we know we've done something wrong in the code logic.
	*/
	int incomplete_run = FALSE;
	int curr_line;
	double bmin_file, bmax_file;
	uint64 kmin_file, know_file, kmax_file;
	uint32 passmin_file, passnow_file, passmax_file;

	uint64 sweep,interval_lo,interval_now,interval_hi,ninterval;
	double twop_float,fqlo,fqhi;

/*   this stuff is for the small-primes sieve...	*/
	uint32 max_diff;
	uint64 dstartval;
	/*
	unsigned char pdiff[NUM_SIEVING_PRIME];	// Compact table storing the difference between adjacent odd primes.
	uint32 offset[NUM_SIEVING_PRIME], startval[NUM_SIEVING_PRIME], startval_incr[NUM_SIEVING_PRIME];
	*/
	unsigned char *pdiff;	/* Compact table storing the (difference/2) between adjacent odd primes.
							http://mathworld.wolfram.com/PrimeGaps.html shows the first >256-gap at ~387 million
							and the first >512-gap at ~300 billion, so using the half-of-even-gap trick makes
							the difference between an algo which is safe for all 32-bit primes and one with a
							limit of < 2^30. */
	uint32 *offset, *startval, *pinv, qinv;
	uint32 MAX_SIEVING_PRIME = 0;
	uint128 p128, q128, t128, x128;
	uint192 p192, q192, t192, x192;
	uint256 p256, q256, t256, x256;
	uint64 *u64_arr;	/* generic array allowing us to hook into the mi64 routines */

#if FAC_DEBUG
	/* Set q_ targ to some known factor to debug a specific missed-factor case: */
	char qstring[STR_MAX_LEN] = "60114601519934856862663724385452522156436875193957605460456227882170122661913333837801257827947749152288312376236100691429532455054133107681314269216135893067663916631";
					/*  "      295257526626031"; *(pass 11, k=          1145, log2=48.06...)*/
					/*  "    87054709261955177"; *(pass 10, k=      20269004, log2=56.27...)*/
					/*  "242557615644693265201"; *(pass 15, k=   56474845800, log2=67.71...)*/
  #if(defined(P1WORD))
	uint64	q_targ = (uint64)0;
  #else
	uint64	*q_targ = 0x0;
	uint32 lenT;
  #endif

	uint64 k_targ = 0;
	uint32 pass_targ = 0xffffffff;	/* Init to a known-invalid value; if user specifies
	 								a known test factor via qstring or q_targ, pass_targ will
	 								be set to the (legitimate) value between 0 and 15;
	 								(pass_targ < 16) can subsequently be used as a quick
	 								test for whether a known test factor has been set.
	 								This is less transparent but faster than checking
	 								qstring or q_targ (the latter is wordsize-dependent.) */
#endif

#if DBG_SIEVE
	uint32 *startval_incr;
	uint32 i64_targ, bit_targ;
#endif

	/*...time-related stuff	*/
	clock_t clock1, clock2;
	double td, tdiff, citer;

	/* printf character buffers - when using to print args in a single printf,
	need a separate buffer for each arg: */
	char char_buf0[STR_MAX_LEN], char_buf1[STR_MAX_LEN], char_buf2[STR_MAX_LEN];
	char *char_addr;

/* Set == 1 to test the trial-div stuff: */
#define	TEST_TRIALDIV	0
#if TEST_TRIALDIV
	#define MAX_ARRAY_DIM 10000
	uint32	vec_len = MAX_ARRAY_DIM;
	uint64*	xvec = (uint64 *)calloc(MAX_ARRAY_DIM, sizeof(uint64));
	uint32 tryq[8];
#endif

#ifdef macintosh
	argc = ccommand(&argv);	/* Macintosh CW */
#endif

/* Allocate factor_k array and align on 16-byte boundary: */
	factor_ptmp = ALLOC_UINT64(factor_ptmp, 24);
	factor_k = ALIGN_UINT64(factor_ptmp);	factor_ptmp = 0x0;
	ASSERT(HERE, ((uint32)factor_k & 0x3f) == 0, "factor_k not 64-byte aligned!");

/*...initialize logicals and factoring parameters...	*/
	restart=FALSE;

#ifdef FACTOR_STANDALONE
	host_init();
#endif

/* Do a quick series of self-tests: */
#if 1//FAC_DEBUG
	test_fac();
#endif

#if 0//INCLUDE_PM1
	/* Simple self-tester for GCD routines in gcd_lehmer.c: */
	fprintf(stderr, "INFO: testing GCD routines...\n");
	if(test_gcd() != 0)
	{
		sprintf(cbuf, "Factor_init : GCD test failed.\n");
		fprintf(stderr,"%s", cbuf);	ASSERT(HERE, 0,cbuf);
	}
#endif

/***********************************************************************/
/******* In standalone mode, process any command-line arguments: *******/
/***********************************************************************/
/*
********** Mfactor command line options: **********

REQUIRED:
		* One (and ONLY one) of -m|mm|f, followed by a valid numerical exponent;
		* One (and ONLY one) of -bmax|kmax, unless it's a restart, i.e. a valid checkpoint file
			for the number in question exists. Iff -bmax|kmax specified, an optional lower-bound
			argument -bmin|kmin may also be specified, which must not exceed the upper bound.
		* If neither -bmax|kmax specified, it is assumed that a valid checkpoint file
			for the number in question exists. The data in this file will indicate either
			an as-yet-uncompleted factoring run for the number in question (in which case
			the run is resumed at the point at which it left off), or a completed run. In
			the latter instance, if a -kplus argument was specified on the command line,
			the k-bounds of the previous completed run are incremented and a new run with
			k-bounds [kmax_previous, kmax_previous + kplus] is begun. If -kplus is specified
			but the restart-file data indicate an as-yet-uncompleted run, a warning is issued,
			the -kplus argument ignored, and the incomplete run is resumed.

Others are optional and in some cases mutually exclusive:

	-h          Prints this help menu and exits

	-m [int]    Trial-factor the Mersenne number M(int) = 2^int - 1, with int < 2^MAX_BITS_P.

	-mm [int]   Trial-factor the double-Mersenne number M(M(int)) = 2^(2^int) - 1, with M(int) < 2^MAX_BITS_P.

	-f [int]    Trial-factor the Fermat number F(int) = 2^(2^int) + 1, with int <= %u.\n",MAX_BITS_P.
			NOTE:
				* Fermat number Trial-factoring not currently supported (future release.)

	-bmin [float] Log2(min factor to try), in floating form (>= 0, default = 0).
	-bmax [float] Log2(max factor to try), in floating form ( < 64*PWORDS).
			NOTES:
				* If -bmin/bmax used to set lower/upper bounds for factoring, -kmin/kmax disallowed.
				* bmin/bmax form of bounds-setting only allowed for single-word-p case, since
				  multiword p may cause float approximations to p, 2*p etc to overflow.

	-kmin  [int] Lowest  factor K value to be tried in each pass ( > 0, default = 1).
	-kmax  [int] Highest factor K value to be tried in each pass ( < 2^64).
			NOTE:
				* If -kmin/kmax used to set lower/upper bounds for factoring, -bmin/bmax disallowed.

	-kplus [int] Added   factor K value to be tried in each pass ( < 2^64), for an exponent
				for which one or more previous shallower factoring runs have already been done
				(specifically, a checkpoint file for a previous run exists.)
			NOTES:
				* If -bmin/bmax or -kmin/kmax used to set bounds for factoring, -kplus disallowed (and v.v.)
				* If -kmin|kmax from a previous run of the number in question found
				 in a checkpoint file, that old kmax serves as kmin for the new run
				 and (old kmax) + (kplus) serves as kmax for the new run.

	-passmin [int]  Maximum factoring pass for the run (0-15, default =  0).
	-passmax [int]  Maximum factoring pass for the run (0-15, default = 15).
			NOTE:
				* If passmin|max from a previous run of the number in question found
				 in a checkpoint file and those pass bounds conflict with the ones
				 given via the command line, an error message is printed and the
				 run aborted. This is done as a precaution against inadvertently
				 skipping a range of trial-factoring bounds in a multipart series
				 of partial factoring runs. In this event the user shhould carefully
				 compare the checkpoint file(s) for the number in question they have
				 saved from previous runs with their current command line and modify
				 one or the other so as to remove any pass-range conflicts.

	-q [int]    A known factor for the number (only used if FAC_DEBUG = 1).
*/
#ifdef FACTOR_STANDALONE

	nargs = 1;
	if(!argv[nargs])
		goto MFACTOR_HELP;
	while(argv[nargs])
	{
		strncpy(stFlag, argv[nargs++], STR_MAX_LEN);

		if(stFlag[0] != '-')
		{
			fprintf(stderr,"*** ERROR: Illegal command-line option %s\n", stFlag);
			fprintf(stderr,"*** All command-line options must be of form -{flag} [argument]\n\n");
			goto MFACTOR_HELP;
		}

		if(STREQ(stFlag, "-h"))
		{
			goto MFACTOR_HELP;
		}
		/* Type of number to be trial-factored: */
		else if(STREQ(stFlag, "-m"))	/* Mersenne */
		{
			strncpy(pstring, argv[nargs++], STR_MAX_LEN);
			MODULUS_TYPE = MODULUS_TYPE_MERSENNE;
		}
		else if(STREQ(stFlag, "-mm"))	/* Double-Mersenne */
		{
			strncpy(pstring, argv[nargs++], STR_MAX_LEN);
			kmin = convert_base10_char_uint64(stFlag);
			ASSERT(HERE, kmin < 64, "Double-Mersenne does not yet have multiprecision-integer-exponent support!");
//==================================
			MODULUS_TYPE = MODULUS_TYPE_MERSENNE;
		}
		else if(STREQ(stFlag, "-f"))	/* Fermat */
		{
/*** TODO: implement the needed modular powering routines ***/
ASSERT(HERE, 0,"Fermat-number trial factoring not currently supported.");

			strncpy(pstring, argv[nargs++], STR_MAX_LEN);
			MODULUS_TYPE = MODULUS_TYPE_FERMAT;
		}

		else if(STREQ(stFlag, "-q"))	/* Known factor */
		{
		#if FAC_DEBUG
			strncpy(qstring, argv[nargs++], 64);
		#else
			ASSERT(HERE, 0,"-q option not supported in non-debug mode - please set FAC_DEBUG to nonzero and recompile in order to use this feature.");
		#endif
		}

		/* Factor bounds, in log2(qmin/qmax) (floating double) form: */
		else if(STREQ(stFlag, "-bmin"))
		{
		#if(defined(P1WORD))
			if(kmin || kmax || kplus)
			{
				fprintf(stderr,"*** ERROR: If -kmin/kmax or -kplus used to set bounds for factoring, -bmin/bmax disallowed.\n");
				goto MFACTOR_HELP;
			}
			strncpy(stFlag, argv[nargs++], STR_MAX_LEN);
			bmin = convert_base10_char_double(stFlag);
		  #if FAC_DEBUG
			printf("bmin = %lf\n", bmin);
		  #endif
		#else
			ASSERT(HERE, 0,"bmin/bmax form of bounds-setting only allowed for single-word-p case!");
		#endif
		}
		else if(STREQ(stFlag, "-bmax"))
		{
		#if(defined(P1WORD))
			if(kmin || kmax || kplus)
			{
				fprintf(stderr,"*** ERROR: If -kmin/kmax or -kplus used to set bounds for factoring, -bmin/bmax disallowed.\n");
				goto MFACTOR_HELP;
			}
			strncpy(stFlag, argv[nargs++], STR_MAX_LEN);
			bmax = convert_base10_char_double(stFlag);
		  #if FAC_DEBUG
			printf("bmax = %lf\n", bmax);
		  #endif
		#else
			ASSERT(HERE, 0,"bmin/bmax form of bounds-setting only allowed for single-word-p case!");
		#endif
		}

		/* Factor bounds, in kmin/kmax (uint64) form: */
		else if(STREQ(stFlag, "-kmin"))
		{
			if(bmin || bmax || kplus)
			{
				fprintf(stderr,"*** ERROR: If -bmin/bmax or -kplus used to set bounds for factoring, -kmin/kmax disallowed.\n");
				goto MFACTOR_HELP;
			}
			strncpy(stFlag, argv[nargs++], STR_MAX_LEN);
			kmin = convert_base10_char_uint64(stFlag);
		}
		else if(STREQ(stFlag, "-kmax"))
		{
			if(bmin || bmax || kplus)
			{
				fprintf(stderr,"*** ERROR: If -bmin/bmax or -kplus used to set bounds for factoring, -kmin/kmax disallowed.\n");
				goto MFACTOR_HELP;
			}
			strncpy(stFlag, argv[nargs++], STR_MAX_LEN);
			kmax = convert_base10_char_uint64(stFlag);
		}

		else if(STREQ(stFlag, "-kplus"))
		{
			if(bmin || bmax || kmin || kmax)
			{
				fprintf(stderr,"*** ERROR: If -bmin/bmax or -kmin/kmax used to set bounds for factoring, -kplus disallowed.\n");
				goto MFACTOR_HELP;
			}
			strncpy(stFlag, argv[nargs++], STR_MAX_LEN);
			kplus = convert_base10_char_uint64(stFlag);
		}

		/* Pass bounds: */
		else if(STREQ(stFlag, "-passmin"))
		{
			strncpy(stFlag, argv[nargs++], STR_MAX_LEN);
			passmin = (uint32)convert_base10_char_uint64(stFlag);
			ASSERT(HERE, passmin < FACTOR_PASS_MAX,"factor.c: passmin < FACTOR_PASS_MAX");
		}
		else if(STREQ(stFlag, "-passmax"))
		{
			strncpy(stFlag, argv[nargs++], STR_MAX_LEN);
			passmax = (uint32)convert_base10_char_uint64(stFlag);
			ASSERT(HERE, passmax < FACTOR_PASS_MAX,"factor.c: passmax < FACTOR_PASS_MAX");
			ASSERT(HERE, passmax >= passmin       ,"factor.c: passmax >= passmin");
		}

		/* Come again? */
		else
		{
			fprintf(stderr,"*** ERROR: Unrecognized command-line option %s\n", stFlag);
			fprintf(stderr,"*** All command-line options must be of form -{flag} [argument]\n\n");
			goto MFACTOR_HELP;
		}
	}

#else

	/* If non-standalone mode, make sure statfile name is non-empty: */
	ASSERT(HERE, STRNEQ(STATFILE, ""), "STATFILE string empty");
	fp = fopen(STATFILE, "a");
	if(!fp)
	{
		fprintf(stderr,"ERROR: Unable to open statfile %s for writing.\n",STATFILE);
		ASSERT(HERE, 0,"0");
	}
	else
	{
		fclose(fp); fp = 0x0;
	}

#endif	/* #ifdef FACTOR_STANDALONE */

	/* Make sure a valid exponent string has been given - if this is the only
	command-line parameter, will attempt to read the other needed run parameters
	from the corresponding checkpoint file:
	*/
	ASSERT(HERE, STRNEQ(pstring,""),"factor.c : pstring empty!");

	/* -bmin/bmax used to set bounds for factoring: */
	if(bmin || bmax)
	{
		ASSERT(HERE, (kmin==0 && kmax==0 && kplus==0),"(kmin==0 && kmax==0 && kplus==0)");

		if(bmin < 0)
		{
			fprintf(stderr,"ERROR: log2(min factor) must be >= 0. Offending entry = %lf.\n", bmin);
			ASSERT(HERE, 0,"0");
		}
		else if(bmin >= MAX_BITS_Q)
		{
			fprintf(stderr,"ERROR: log2(min factor) exceeds allowable limit of %u. Offending entry = %lf.\n", MAX_BITS_Q, bmin);
			ASSERT(HERE, 0,"0");
		}

		if(bmax <= 0)
		{
			fprintf(stderr,"ERROR: log2(max factor) must be > 0. Offending entry = %lf.\n", bmax);
			ASSERT(HERE, 0,"0");
		}
		else if(bmax > MAX_BITS_Q)
		{
			fprintf(stderr,"ERROR: log2(max factor) exceeds allowable limit of %u. Offending entry = %lf.\n", MAX_BITS_Q, bmax);
			ASSERT(HERE, 0,"0");
		}

		if(bmax < bmin)
		{
			fprintf(stderr,"ERROR: (bmax = %lf) < (bmin = %lf)!\n", bmax, bmin);
			ASSERT(HERE, 0,"0");
		}
	}

	/* -kmin/kmax used to set bounds for factoring: */
	if(kmin || kmax)
	{
		ASSERT(HERE, kmax != 0 ,"factor.c: kmax not set!");
		ASSERT(HERE, (int64)kmax > 0, "kmax must be 63 bits or less!");
		ASSERT(HERE, (bmin==0 && bmax==0 && kplus==0),"(bmin==0 && bmax==0 && kplus==0)");

		if(kmax < kmin)
		{
			fprintf(stderr,"ERROR: (kmax = %s) < (kmin = %s)!\n", &char_buf0[convert_uint64_base10_char(char_buf0, kmax)], &char_buf1[convert_uint64_base10_char(char_buf0, kmin)]);
			ASSERT(HERE, 0,"0");
		}
	}

	ASSERT(HERE, bmax > 0.0 || kmax != 0 ,"factor.c: One of bmax or kmax must be set!");

/* Temporary - needed until I finish implementing Fermat-number capability: */
ASSERT(HERE, (MODULUS_TYPE == MODULUS_TYPE_MERSENNE),"(MODULUS_TYPE == MODULUS_TYPE_MERSENNE)");/* || (MODULUS_TYPE == MODULUS_TYPE_FERMAT));*/

	/* Convert power-of-2 exponent to unsigned int form: */
	if(MODULUS_TYPE == MODULUS_TYPE_FERMAT)
	{
		findex = convert_base10_char_uint64(pstring);
		/* For purposes of the bits-in-p limit, treat 2^findex as having
		(findex) rather than (findex+1) bits: */
		nbits_in_p = findex;
	#if(defined(P4WORD))
		LSHIFT256(ONE256, findex, p);
	#elif(defined(P3WORD))
		LSHIFT192(ONE192, findex, p);
	#elif(defined(P2WORD))
		LSHIFT128(ONE128, findex, p);
	#else
		p = (uint64)1 << findex;
	#endif
	}
	else
	{
	#if(defined(P1WORD))
		ASSERT(HERE, strlen(pstring) < 19, "factor.c: pstring too large for single-word factoring!");
		p = convert_base10_char_uint64(pstring);
		lenP = 1;
		u64_arr = (uint64 *)calloc(lenP+1, sizeof(uint64));
		nbits_in_p =  64 - leadz64 (p);
		if(kmax)
		{
			itmp64 = 2*kmax;
		#ifdef MUL_LOHI64_SUBROUTINE
			itmp64 = __MULH64(p,itmp64);
		#else
			MULH64(p,itmp64,itmp64);
		#endif
			lenQ = lenP + (itmp64 != 0);
		}
		else
		{
			lenQ = 1 + (( nbits_in_p + (uint32)(ceil(bmax)) ) >> 6);
		}
	#else
		/* Convert stringified exponent to mi64 form and check the length of p and of the max. factor: */
		p = convert_base10_char_mi64(pstring, &lenP);
		ASSERT(HERE, lenP > 0, "factor.c: Error converting pstring!");
		nbits_in_p = (lenP<<6) - mi64_leadz(p, lenP);
		u64_arr = (uint64 *)calloc(lenP+1, sizeof(uint64));
		if(kmax)
		{
			u64_arr[lenP] = mi64_mul_scalar( p, 2*kmax, u64_arr, lenP);
			lenQ = lenP + (u64_arr[lenP] != 0);
		}
		else
		{
			lenQ = ( nbits_in_p + (uint32)(ceil(bmax)) ) >> 6;
		}
		two_p = (uint64 *)calloc(lenQ, sizeof(uint64));
		p120  = (uint64 *)calloc(lenQ, sizeof(uint64));
		q     = (uint64 *)calloc(lenQ, sizeof(uint64));
		q2    = (uint64 *)calloc(lenQ, sizeof(uint64));
	#endif
	}

#if(defined(P1WORD))
	if((p    & 1) == 0)
#else
	if((p[0] & 1) == 0)
#endif
     {
		 fprintf(stderr,"p must be odd! Offending p = %s\n", pstring); ASSERT(HERE, 0,"0");
	 }

	if(nbits_in_p > MAX_BITS_P)
	{
		fprintf(stderr,"p too large - limit is %u bits. Offending p = %s\n", MAX_BITS_P, pstring);
		ASSERT(HERE, 0,"0");
	}

#if(defined(P1WORD))

	if(p <= 2) { fprintf(stderr,"p must be > 2! Offending p = %s\n", pstring); ASSERT(HERE, 0,"0"); }
	if((p & 1) == 0)     { fprintf(stderr,"p must be odd! Offending p = %s\n", pstring); ASSERT(HERE, 0,"0"); }

	/* Do a quick base-2 Fermat PRP test: */
	if((true_false = twopmodq64(p-1, p)) != 1) { fprintf(stderr,"p is not prime! Offending p = %s\n", pstring); ASSERT(HERE, 0,"0"); }

	/* 2*p: */
	two_p = p + p;
	/* Find FP approximation to 2*p - can't use this for multiword case, because double approximation tp 2*p may overflow: */
	twop_float = (double)two_p;
	/* Now that have twop_float, compute kmax if not already set: */
	if(!kmax)
	{
		fqlo = pow(2.0, bmax);
		kmax = (uint64)(fqlo/twop_float);
	}
	/* 120*p: */
	p120 = (uint64)120*p;
	ASSERT(HERE, p120/120 == p, "120*p overflows 64-bit word!");

  #if FAC_DEBUG
	printf("two_p    = %s\n", &char_buf0[convert_uint64_base10_char(char_buf0, two_p)]);
	printf("120*p    = %s\n", &char_buf0[convert_uint64_base10_char(char_buf0, p120 )]);
  #endif

	/* p mod 60: */
	pmod60 = p%60;

#else

	/* Do a quick base-2 Fermat PRP test: */
	mi64_sub_scalar(p, 1ull, q, lenP);	/* q = p-1 */
	true_false = mi64_twopmodq(q, lenP, p, lenP, 0x0);
	if(!true_false)
	{
		fprintf(stderr,"p is not prime! Offending p = %s\n", pstring);
		ASSERT(HERE, 0,"0");
	}

	/* 2*p: Don't need to worry about overflow here since we've allocate tow_p, p120, q, etc to be of lenQ, not lenP: */
	two_p[lenP] = mi64_add(p, p, two_p, lenP);

	/* 120*p: */
	p120[lenP] = mi64_mul_scalar(p, 120ull, p120, lenP);

  #if FAC_DEBUG
	printf("two_p    = %s\n", &char_buf0[convert_mi64_base10_char(char_buf0, two_p, lenP)]);
	printf("120*p    = %s\n", &char_buf0[convert_mi64_base10_char(char_buf0, p120 , lenP)]);
  #endif

	/* p mod 60: */
	pmod60 = mi64_div_y32(p, 60, 0x0, lenP);

#endif	/* endif(P3WORD) */

	ASSERT(HERE, kmax, "kmax not set!");

#if(defined(P1WORD))

	itmp64 = 2*kmax;
  #ifdef MUL_LOHI64_SUBROUTINE
	itmp64 = __MULH64(p,itmp64);
  #else
	MULH64(p,itmp64,itmp64);
	u64_arr[0] = (p*kmax)<<1;
	u64_arr[1] = itmp64;
  #endif

#else

	u64_arr[lenP] = mi64_mul_scalar( p, 2*kmax, u64_arr, lenP);
	ASSERT(HERE, lenQ == lenP+(u64_arr[lenP] != 0), "");

#endif

	nbits_in_q = (lenQ<<6) - mi64_leadz(u64_arr, lenQ);

	if(nbits_in_q > MAX_BITS_Q)
	{
		fprintf(stderr,"qmax too large - limit is %u bits. Offending p, kmax = %s, %s\n", MAX_BITS_Q, pstring, &char_buf0[convert_uint64_base10_char(char_buf0, kmax)]);
		ASSERT(HERE, 0,"0");
	}

	/* log2[nearest power of 2 to (nbits_in_p)*lenQ^2)] */
	bits_in_pq2 = nbits_in_p*lenQ*lenQ;
	bits_in_pq2 = 32 - leadz32(bits_in_pq2);
	countmask = (1ull << (30-bits_in_pq2)) - 1;

/*****************************************************/
/****************** RESTART STUFF: *******************/
/*****************************************************/

	/* Restart file for a given exponent is named 't{exponent}'.
	Since Fermat-number exponents are so much smaller than Mersenne-number ones,
	we assume there is no overlap, i.e. if pstring <= MAX_BITS_P, it's a
	Fermat-number factoring run, pstring > MAX_BITS_P is a Mersenne-number run.
	*/
	RESTARTFILE[0] = 't'; RESTARTFILE[1] = '\0'; strcat(RESTARTFILE, pstring);

	/* TF restart files are in HRF, not binary: */
	fp = fopen(RESTARTFILE, "r");
	if(!fp)
	{
									fprintf(stderr,"INFO: No factoring savefile %s found ... starting from scratch.\n",RESTARTFILE);
	#ifndef FACTOR_STANDALONE
		fq = fopen(STATFILE,"a");	fprintf(	fq,"INFO: No factoring savefile %s found ... starting from scratch.\n",RESTARTFILE);	fclose(fq); fq = 0x0;
	#endif
	}
	else
	{
									fprintf(stderr,"Factoring savefile %s found ... reading ...\n",RESTARTFILE);
	#ifndef FACTOR_STANDALONE
		fq = fopen(STATFILE,"a");	fprintf(	fq,"Factoring savefile %s found ... reading ...\n",RESTARTFILE);	fclose(fq); fq = 0x0;
	#endif
		/* The factoring checkpoint file is assumed to have the format:
			Line 1:		{string containing the current exponent stored in pstring}

			Line 2:		{Log2(minimum factor to try), in floating double form}
						If > 10^9 its whole-number part is taken as the KMin value instead.
			Line 3:		{Log2(maximum factor to try), in floating double form}
						If > 10^9 its whole-number part is taken as the KMax value instead.

			Line 4:		KMin = {smallest factor K value to be tried in each pass}
			Line 5:		KNow = { largest factor K value tried so far during current pass}
			Line 6:		KMax = { largest factor K value to be tried in each pass}

			Line 7:		PassMin = {maximum pass for the run (typically 15, but perhaps not, e.g. for a factoring assignment split over multiple CPUs.}
			Line 8:		PassNow = {current factoring pass}
			Line 9:		PassMax = {maximum pass for the run (typically 15, but perhaps not, e.g. for a factoring assignment split over multiple CPUs.}

			Line 10:	Number of q's tried so far during the run
			Line 11:	64-bit (sum of trial q)%2^64 checksum

			Line 12+:	Any diagnostic info not needed for restarting from interrupt
						(mainly, in standalone mode can use this in place of STATFILE.)
		*/
		curr_line = 0;

		/* pstring*/
		++curr_line;
		if(!fgets(in_line, STR_MAX_LEN, fp))
		{
			fprintf(stderr,"ERROR: unable to read Line %d (current exponent) of factoring restart file %s!\n", curr_line, RESTARTFILE);
			ASSERT(HERE, 0,"0");
		}
		/* Strip the expected newline char from in_line: */
		char_addr = strstr(in_line, "\n");
		if(char_addr)
			*char_addr = '\0';
		/* Make sure restart-file and current-run pstring match: */
		if(STRNEQ(in_line, pstring))
		{
			fprintf(stderr,"ERROR: current exponent %s != Line %d of factoring restart file %s!\n",pstring, curr_line, RESTARTFILE);
			ASSERT(HERE, 0,"0");
		}

		/* bmin */
		++curr_line;
		fgets(cbuf, STR_MAX_LEN, fp);
		itmp = sscanf(cbuf, "%lf", &bmin_file);
		if(itmp != 1)
		{
			fprintf(stderr,"ERROR: unable to parse Line %d (bmin) of factoring restart file %s. Offending input = %s\n", curr_line, RESTARTFILE, cbuf);
			ASSERT(HERE, 0,"0");
		}

		/* bmax */
		++curr_line;
		fgets(cbuf, STR_MAX_LEN, fp);
		itmp = sscanf(cbuf, "%lf", &bmax_file);
		if(itmp != 1)
		{
			fprintf(stderr,"ERROR: unable to parse Line %d (bmin) of factoring restart file %s. Offending input = %s\n", curr_line, RESTARTFILE, cbuf);
			ASSERT(HERE, 0,"0");
		}

	/************************************
	LINE PAIRS 5/6 AND 7/8 ARE USED TO DETERMINE WHETHER A PREVIOUS
	FACTORING RUN OF THE SAME EXPONENT COMPLETED OR NOT: If know >= kmax
	and passnow = passmax then the previous run completed, in which case
	we allow a new run to a deeper bound, i.e. reset passnow = passmin
	and run passes passmin through passmax from bounds kmin to kmax.
	*************************************/
		/* KMin */
		++curr_line;
GET_LINE4:
	/**** redo this ****/
		if(!fgets(in_line, STR_MAX_LEN, fp))
		{
			fprintf(stderr,"ERROR: 'KMin' not found in Line %d of factoring restart file %s!\n", curr_line, RESTARTFILE);
			ASSERT(HERE, 0,"0");
		}
		char_addr = strstr(in_line, "KMin");
		/* Since the preceding fscanf call may leave us at the end of curr_line-1
		(rather than the beginning of curr_line), allow for a possible 2nd needed
		fgets call here: */
		if(!char_addr)
		{
			goto GET_LINE4;
		}
		else
		{
			char_addr = strstr(in_line, "=");
			if(!char_addr)
			{
				fprintf(stderr,"ERROR: Line %d of factoring restart file %s lacks the required = sign!\n", curr_line, RESTARTFILE);
				ASSERT(HERE, 0,"0");
			}
			char_addr++;
			kmin_file = convert_base10_char_uint64(char_addr);
		}

		/* KNow */
		++curr_line;
		if(!fgets(in_line, STR_MAX_LEN, fp))
		{
			fprintf(stderr,"ERROR: unable to read Line %d (KNow) of factoring restart file %s!\n", curr_line, RESTARTFILE);
			ASSERT(HERE, 0,"0");
		}
		char_addr = strstr(in_line, "KNow");
		if(!char_addr)
		{
			fprintf(stderr,"ERROR: 'KNow' not found in Line %d of factoring restart file %s!\n", curr_line, RESTARTFILE);
			ASSERT(HERE, 0,"0");
		}
		else
		{
			char_addr = strstr(in_line, "=");
			if(!char_addr)
			{
				fprintf(stderr,"ERROR: Line %d of factoring restart file %s lacks the required = sign!\n", curr_line, RESTARTFILE);
				ASSERT(HERE, 0,"0");
			}
			char_addr++;
			know_file = convert_base10_char_uint64(char_addr);
		}

		/* KMax */
		++curr_line;
		if(!fgets(in_line, STR_MAX_LEN, fp))
		{
			fprintf(stderr,"ERROR: unable to read Line %d (KMax) of factoring restart file %s!\n", curr_line, RESTARTFILE);
			ASSERT(HERE, 0,"0");
		}
		char_addr = strstr(in_line, "KMax");
		if(!char_addr)
		{
			fprintf(stderr,"ERROR: 'KMax' not found in Line %d of factoring restart file %s!\n", curr_line, RESTARTFILE);
			ASSERT(HERE, 0,"0");
		}
		else
		{
			char_addr = strstr(in_line, "=");
			if(!char_addr)
			{
				fprintf(stderr,"ERROR: Line %d of factoring restart file %s lacks the required = sign!\n", curr_line, RESTARTFILE);
				ASSERT(HERE, 0,"0");
			}
			char_addr++;
			kmax_file = convert_base10_char_uint64(char_addr);
		}

		/* PassMin */
		++curr_line;
		if(!fgets(in_line, STR_MAX_LEN, fp))
		{
			fprintf(stderr,"ERROR: unable to read Line %d (PassMin) of factoring restart file %s!\n", curr_line, RESTARTFILE);
			ASSERT(HERE, 0,"0");
		}
		char_addr = strstr(in_line, "PassMin");
		if(!char_addr)
		{
			fprintf(stderr,"ERROR: 'PassMin' not found in Line %d of factoring restart file %s!\n", curr_line, RESTARTFILE);
			ASSERT(HERE, 0,"0");
		}
		else
		{
			char_addr = strstr(in_line, "=");
			if(!char_addr)
			{
				fprintf(stderr,"ERROR: Line %d of factoring restart file %s lacks the required = sign!\n", curr_line, RESTARTFILE);
				ASSERT(HERE, 0,"0");
			}
			char_addr++;
			passmin_file = (uint32)convert_base10_char_uint64(char_addr);
			ASSERT(HERE, passmin_file < FACTOR_PASS_MAX,"factor.c: passmin < FACTOR_PASS_MAX");
		}

		/* PassNow */
		++curr_line;
		if(!fgets(in_line, STR_MAX_LEN, fp))
		{
			fprintf(stderr,"ERROR: unable to read Line %d (PassNow) of factoring restart file %s!\n", curr_line, RESTARTFILE);
			ASSERT(HERE, 0,"0");
		}
		char_addr = strstr(in_line, "PassNow");
		if(!char_addr)
		{
			fprintf(stderr,"ERROR: 'PassNow' not found in Line %d of factoring restart file %s!\n", curr_line, RESTARTFILE);
			ASSERT(HERE, 0,"0");
		}
		else
		{
			char_addr = strstr(in_line, "=");
			if(!char_addr)
			{
				fprintf(stderr,"ERROR: Line %d of factoring restart file %s lacks the required = sign!\n", curr_line, RESTARTFILE);
				ASSERT(HERE, 0,"0");
			}
			char_addr++;
			passnow_file = (uint32)convert_base10_char_uint64(char_addr);
			ASSERT(HERE, passnow_file < FACTOR_PASS_MAX,"factor.c: passnow < FACTOR_PASS_MAX");
			ASSERT(HERE, passnow_file >= passmin_file  ,"factor.c: passnow_file >= passmin_file");
		}

		/* PassMax */
		++curr_line;
		if(!fgets(in_line, STR_MAX_LEN, fp))
		{
			fprintf(stderr,"ERROR: unable to read Line %d (PassMax) of factoring restart file %s!\n", curr_line, RESTARTFILE);
			ASSERT(HERE, 0,"0");
		}
		char_addr = strstr(in_line, "PassMax");
		if(!char_addr)
		{
			fprintf(stderr,"ERROR: 'PassMax' not found in Line %d of factoring restart file %s!\n", curr_line, RESTARTFILE);
			ASSERT(HERE, 0,"0");
		}
		else
		{
			char_addr = strstr(in_line, "=");
			if(!char_addr)
			{
				fprintf(stderr,"ERROR: Line %d of factoring restart file %s lacks the required = sign!\n", curr_line, RESTARTFILE);
				ASSERT(HERE, 0,"0");
			}
			char_addr++;
			passmax_file = (uint32)convert_base10_char_uint64(char_addr);
			ASSERT(HERE, passmax_file < FACTOR_PASS_MAX,"factor.c: passmax_file < FACTOR_PASS_MAX");
			ASSERT(HERE, passmax_file >= passnow_file  ,"factor.c: passmax_file >= passnow_file");
		}

		/* Number of q's tried: */
		++curr_line;
		if(!fgets(in_line, STR_MAX_LEN, fp))
		{
			fprintf(stderr,"ERROR: unable to read Line %d (#Q tried) of factoring restart file %s!\n", curr_line, RESTARTFILE);
			ASSERT(HERE, 0,"0");
		}
		char_addr = strstr(in_line, "#Q tried");
		if(!char_addr)
		{
			fprintf(stderr,"ERROR: '#Q tried' not found in Line %d of factoring restart file %s!\n", curr_line, RESTARTFILE);
			ASSERT(HERE, 0,"0");
		}
		else
		{
			char_addr = strstr(in_line, "=");
			if(!char_addr)
			{
				fprintf(stderr,"ERROR: Line %d of factoring restart file %s lacks the required = sign!\n", curr_line, RESTARTFILE);
				ASSERT(HERE, 0,"0");
			}
			char_addr++;
			count = convert_base10_char_uint64(char_addr);
		}

		/* 64-bit (sum of trial q)%2^64 checksum: */
		++curr_line;
		if(!fgets(in_line, STR_MAX_LEN, fp))
		{
			fprintf(stderr,"ERROR: unable to read Line %d (Checksum1) of factoring restart file %s!\n", curr_line, RESTARTFILE);
			ASSERT(HERE, 0,"0");
		}
		char_addr = strstr(in_line, "Checksum1");
		if(!char_addr)
		{
			fprintf(stderr,"ERROR: 'Checksum1' not found in Line %d of factoring restart file %s!\n", curr_line, RESTARTFILE);
			ASSERT(HERE, 0,"0");
		}
		else
		{
			char_addr = strstr(in_line, "=");
			if(!char_addr)
			{
				fprintf(stderr,"ERROR: Line %d of factoring restart file %s lacks the required = sign!\n", curr_line, RESTARTFILE);
				ASSERT(HERE, 0,"0");
			}
			char_addr++;
			itmp = sscanf(char_addr, "%16llX", &checksum1);
			if(itmp != 1)
			{
				fprintf(stderr,"ERROR: unable to parse hex entry of Line %d (Checksum1) of factoring restart file %s. Offending input = %s\n", curr_line, RESTARTFILE, in_line);
				ASSERT(HERE, 0,"0");
			}
		}

		/* 64-bit (sum of 2^p % q)%2^64 checksum: */
		++curr_line;
		if(!fgets(in_line, STR_MAX_LEN, fp))
		{
			fprintf(stderr,"ERROR: unable to read Line %d (Checksum2) of factoring restart file %s!\n", curr_line, RESTARTFILE);
			ASSERT(HERE, 0,"0");
		}
		char_addr = strstr(in_line, "Checksum2");
		if(!char_addr)
		{
			fprintf(stderr,"ERROR: 'Checksum2' not found in Line %d of factoring restart file %s!\n", curr_line, RESTARTFILE);
			ASSERT(HERE, 0,"0");
		}
		else
		{
			char_addr = strstr(in_line, "=");
			if(!char_addr)
			{
				fprintf(stderr,"ERROR: Line %d of factoring restart file %s lacks the required = sign!\n", curr_line, RESTARTFILE);
				ASSERT(HERE, 0,"0");
			}
			char_addr++;
			itmp = sscanf(char_addr, "%16llX", &checksum2);
			if(itmp != 1)
			{
				fprintf(stderr,"ERROR: unable to parse hex entry of Line %d (Checksum2) of factoring restart file %s. Offending input = %s\n", curr_line, RESTARTFILE, in_line);
				ASSERT(HERE, 0,"0");
			}
		}

		fclose(fp); fp = 0x0;

		/**** process restart-file and any command-line params: ****/

		/* If previous run is not yet complete, ignore any increased factor-bound-related
		command-line parameters and instead proceed to complete the previous run first:
		*/
		if((know_file < kmax_file) || (passnow_file < passmax_file))
		{
			incomplete_run = TRUE;

			fprintf(stderr,"INFO: Previous run to kmax = %s not yet complete.\n"  , &char_buf0[convert_uint64_base10_char(char_buf0, kmax_file)]);
			fprintf(stderr,"Ignoring any increased factor-bound-related command-line parameters and proceeding to complete previous run.\n");

			bmin = bmin_file;
			bmax = bmax_file;

			passmin = passmin_file;
			passnow = passnow_file;
			passmax = passmax_file;

			kmin = kmin_file;
			know = know_file;
			kmax = kmax_file;

			kplus = 0;
		}
		else
		{
			/**** Previous run was completed - check that current params satisfy one (and only one)
			of the following sets of conditions:

				1) -bmin/bmax used to set bounds for factoring:
					In this case we expect any command-line bmin will be >= that in the restart file
					(in fact we expect bmin >= bmax_file, i.e. that the runs are nonoverlapping -
					if not we warn and set bmin = bmax_file), and that bmax > bmax_file.
			****/
			if(bmin || bmax)
			{
			#if(!defined(P1WORD))
				ASSERT(HERE, 0,"bmin/bmax form of bounds-setting only allowed for single-word-p case!");
			#endif
				ASSERT(HERE, (kmin==0 && kmax==0 && kplus==0),"(kmin==0 && kmax==0 && kplus==0) - please delete any restart files for this p and retry debug run.");

				if(bmin)
				{
					ASSERT(HERE, bmin >= bmin_file - 0.0000000001,"bmin >= bmin_file");
					if(bmin < bmax_file)
					{
						fprintf(stderr,"WARNING: Specified bmin (%lf) smaller than previous-run bmax = %lf. Setting equal to avoid overlapping runs.\n", bmin, bmax_file);
					}
				}
				bmin = bmax_file;

				/* We expect any command-line bmax will be > that in the restart file: */
				if(bmax)
				{
					ASSERT(HERE, bmax > bmax_file - 0.0000000001,"bmax >= bmax_file");
				}
			}

			/****
				2) -kmin/kmax used to set bounds for factoring:
					In this case we expect any command-line kmin will be >= that in the restart file
					(in fact we expect kmin >= kmax_file, i.e. that the runs are nonoverlapping -
					if not we warn and set kmin = kmax_file), and that kmax > kmax_file.
			****/
			if(kmin || kmax)
			{
				ASSERT(HERE, (bmin==0 && bmax==0 && kplus==0),"(bmin==0 && bmax==0 && kplus==0)");

				if(kmin)
				{
					ASSERT(HERE, kmin >= kmin_file,"kmin >= kmin_file");
					if(kmin < kmax_file)
					{
						fprintf(stderr,"WARNING: Specified kmin (%s) smaller than previous-run kmax = %s. Setting equal to avoid overlapping runs.\n", &char_buf0[convert_uint64_base10_char(char_buf0, kmax)], &char_buf1[convert_uint64_base10_char(char_buf0, kmax_file)]);
					}
				}
				kmin = kmax_file;

				/* We expect any command-line kmax will be > that in the restart file: */
				if(kmax)
				{
					ASSERT(HERE, kmax > kmax_file,"kmax >= kmax_file");
				}
			}

			/****
				3) -kplus used to increment an upper bound from a previous factoring run:
			****/
			if(kplus)
			{
				ASSERT(HERE, (bmin==0 && bmax==0 && kmin==0 && kmax==0),"(bmin==0 && bmax==0 && kmin==0 && kmax==0)");

				kmin = kmax_file;
				/* Ensure incremented value kmax fits into a 64-bit unsigned int: */
				ASSERT(HERE, (kmin + kplus) > kplus, "kmax_file + kplus exceeds 2^64!");
				kmax = kmin + kplus;
				kplus = 0;	/* If kplus != 0 detected further on, that indicates that no valid restart
							file was found for factoring-bounds incrementing. */
			}

		}

		/* Successfully processed restart file: */
		restart=TRUE;
	}

/************************ END(RESTART STUFF) *******************/

	/* If it's not a restart of an as-yet-uncompleted run, synchronize the factoring-bound params: */
	if(!incomplete_run)
	{
		/* Double-check factoring pass bounds: */
		if(passmin > (FACTOR_PASS_MAX-1) )
		{
			fprintf(stderr,"ERROR: passmin must be <= %u. Offending entry = %u.\n", FACTOR_PASS_MAX-1, passmin);
			ASSERT(HERE, 0,"0");
		}

		if(passmax < passmin)
		{
			fprintf(stderr,"ERROR: (passmax = %u) < (passmin = %u)!\n", passmax, passmin);
			ASSERT(HERE, 0,"0");
		}
		if(passmax > (FACTOR_PASS_MAX-1) )
		{
			fprintf(stderr,"ERROR: passmax must be <= %u. Offending entry = %u.\n", FACTOR_PASS_MAX-1, passmax);
			ASSERT(HERE, 0,"0");
		}

		/**** Process factor candidate bounds: ****/

		/* If any of bmin|kmin, bmax|kmax nonzero, calculate its counterpart: */
	#if(defined(P1WORD))
		if(kmin || bmin)
		{
			if(kmin == 0)	/* Lower Bound given in log2rithmic form */
			{
				ASSERT(HERE, bmin <= bmax, "bmin >= bmax!");
				fqlo = pow(2.0, bmin);
				kmin = (uint64)(fqlo/twop_float);
			}
			else
			{
				ASSERT(HERE, kmin <= kmax, "kmin >= kmax!");
				fqlo = kmin*twop_float + 1.0;
				bmin = log(fqlo)/log(2.0);
			}
		}
		else
		{
			fqlo = 1.0;
		}

		if(kmax || bmax)
		{
			if(kmax == 0)	/* Upper Bound given in log2rithmic form */
			{
				fqhi = pow(2.0, bmax);
				kmax = (uint64)(fqhi/twop_float);
			}
			else
			{
				fqhi = kmax*twop_float + 1.0;
				bmax = log(fqhi)/log(2.0);
			}
		}
		else
		{
			ASSERT(HERE, 0 ,"factor.c : One of bmax, kmax must be nonzero!");
		}
	#endif

		/**** At this point the paired elements bmin|kmin, bmax|kmax are in synchrony. ****/

		/* If kplus given on command line, a valid restart file should have been found
		and kmax incremented at this point, i.e. kplus should have been reset to zero:
		*/
		ASSERT(HERE, kplus == 0, "kplus must be zero here!");

		know = kmin;
		passnow = passmin;

	}	/* endif(!incomplete_run) */

/*****************************************************/
/****************** SIEVE STUFF: *********************/
/*****************************************************/

	ASSERT(HERE, NUM_SIEVING_PRIME > 0, "factor.c : NUM_SIEVING_PRIME > 0");

/*   allocate the arrays and initialize the array of sieving primes	*/
	temp_late = (uint64 *)calloc(len, sizeof(uint64));

	bitmap = (uint64 *)calloc(len/60+1, sizeof(uint64));
	if (bitmap == NULL) {
		fprintf(stderr,"Memory allocation failure for BITMAP array");
		ASSERT(HERE, 0,"0");
	}

	template = (uint64 *)calloc((len/60+1)*16, sizeof(uint64));
	if (template == NULL) {
		fprintf(stderr,"Memory allocation failure for TEMPLATE array");
		ASSERT(HERE, 0,"0");
	}

	pdiff = (unsigned char *)calloc(NUM_SIEVING_PRIME, sizeof(unsigned char));
	if (pdiff == NULL) {
		fprintf(stderr,"Memory allocation failure for pdiff array");
		ASSERT(HERE, 0,"0");
	}

	offset = (uint32 *)calloc(NUM_SIEVING_PRIME, sizeof(uint32));
	if (offset == NULL) {
		fprintf(stderr,"Memory allocation failure for OFFSET array");
		ASSERT(HERE, 0,"0");
	}

	startval = (uint32 *)calloc(NUM_SIEVING_PRIME, sizeof(uint32));
	if (startval == NULL) {
		fprintf(stderr,"Memory allocation failure for STARTVAL array");
		ASSERT(HERE, 0,"0");
	}

	pinv = (uint32 *)calloc(NUM_SIEVING_PRIME, sizeof(uint32));
	if (pinv == NULL) {
		fprintf(stderr,"Memory allocation failure for PINV array");
		ASSERT(HERE, 0,"0");
	}

#if DBG_SIEVE
	startval_incr = (uint32 *)calloc(NUM_SIEVING_PRIME, sizeof(uint32));
	if (startval_incr == NULL) {
		fprintf(stderr,"Memory allocation failure for STARTVAL_INCR array");
		ASSERT(HERE, 0,"0");
	}
#endif

	/*
	switch(MAX_SIEVING_PRIME){
		case 0:
			nprime=10; break;
		case 10000:
			nprime=1228; break;
		case 20000:
			nprime=1228+1033; break;
		case 30000:
			nprime=1228+1033+983; break;
		case 40000:
			nprime=1228+1033+983+958; break;
		case 50000:
			nprime=1228+1033+983+958+930; break;
		case 60000:
			nprime=1228+1033+983+958+930+924; break;
		case 70000:
			nprime=1228+1033+983+958+930+924+485; break;
		default:
			fprintf(stderr,"ERROR: MAX_SIEVING_PRIME must be a multiple of 10000, max = 70000.\n");
			ASSERT(HERE, 0,"0");
	}
	offset = (uint32 *)calloc(nprime, sizeof(uint32));
	*/

	/*
	nprime = NUM_SIEVING_PRIME;
	for(i = 0; i < NUM_SIEVING_PRIME[PWORDS-1]; i++)
	{
		pdiff[i] = 0;
	}
	*/

	#if 1
		/* Check integrity (at least in the sense of monotonicity) for the precomputed pseudoprime table: */
		for(i = 1; i < 9366; ++i)
		{
			ASSERT(HERE, f2psp[i] > f2psp[i-1],"Misplaced pseudoprime!");
		}

		/* Test some near-2^32 known-prime cases: */
		curr_p = (uint32)-5;
		itmp32 = twopmodq32(curr_p-1, curr_p);
		ASSERT(HERE, itmp32 == 1,"twopmodq32: 2^32 - 5 test fails!");
		curr_p = (uint32)-17;
		itmp32 = twopmodq32(curr_p-1, curr_p);
		ASSERT(HERE, itmp32 == 1,"twopmodq32: 2^32 -17 test fails!");
		curr_p = (uint32)-35;	/* Start of the last length-30 curr_p%30 == 11 interval < 2^32; the 6th candidate in that interval, 2^32-17, is prime */
		itmp32 = twopmodq32_x8(curr_p, curr_p+ 2, curr_p+ 6, curr_p+ 8, curr_p+12, curr_p+18, curr_p+20, curr_p+26);
		ASSERT(HERE, itmp32 ==32,"twopmodq32_x8: 2^32 -35 test fails!");

		fprintf(stderr,"Generating difference table of first %u small primes\n", nprime);
	#if ALLOW_PRP
		fprintf(stderr,"Base-2 Fermat pseudoprimes = \n");
	#endif

		curr_p = 3;	/* Current prime stored in l. */
		max_diff = 0;

	#if ALLOW_PRP
		num_pseudo = 0;
	#else
		f2psp_idx = 0;	/* Index to next-expected Fermat base-2 pseudoprime in the precomputed table */
	#endif

	#if ALLOW_PRP
		/* pdiff[0] = 0 represents the diff between 2 and 3, so start loop at i=1: */
		ihi = curr_p = 3;
		for(i = 1; i < nprime; ++i)
		{
			curr_p += 2;
			++pdiff[i];
	#else
		/* Init first few diffs between 3/5, 5/7, 7/11, so can start loop with curr_p = 11 == 1 (mod 10), as required by twopmodq32_x8(): */
		pdiff[1] = 1;
		pdiff[2] = 1;
		ihi = curr_p = 11;
		/* Process chunks of length 30, starting with curr_p == 11 (mod 30). Applying the obvious divide-by3,5 mini-sieve,
		we have 8 candidates in each interval: curr_p + [ 0, 2, 6, 8,12,18,20,26].
		For example: curr_p = 11 gives the 8 candidates: 11,13,17,19,23,29,31,37.
		*/
		for(i = 3; i < nprime; curr_p += 30)
		{
	#endif
			/* Make sure (curr_p + 29) < 2^32: */
			if(curr_p > 0xffffffe3)
			{
				fprintf(stderr,"curr_p overflows 32 bits!");
				nprime = i;
				break;
			}

			/* Max sieving prime must be < smallest candidate factor of M(p) */
		#if(defined(P1WORD))
			if((curr_p+29) > two_p)
			{
				nprime = i;
				break;
			}
		#endif

		#if !ALLOW_PRP

			/* Do a quick Fermat base-2 compositeness test before invoking the more expensive mod operations: */
			itmp32 = twopmodq32_x8(curr_p, curr_p+ 2, curr_p+ 6, curr_p+ 8, curr_p+12, curr_p+18, curr_p+20, curr_p+26);
			for(j = 0; j < 8; ++j)
			{
				if((itmp32 >> j)&0x1)	/* It's a PRP, so check against the table of known pseudoprimes and (if it's not a PSP) init for the next gap */
				{
					ASSERT(HERE, curr_p <= f2psp[f2psp_idx],"Error in pseudoprime sieve");
					if((curr_p + pdsum_8[j]) == f2psp[f2psp_idx])	/* It's a base-2 pseudoprime */
					{
						++f2psp_idx;
						pdiff[i] += pdiff_8[j];
						continue;
					}
					else	/* It's prime - add final increment to current pdiff[i] and then increment i: */
					{
						ihi = (curr_p + pdsum_8[j]);
						pdiff[i] += pdiff_8[j];
						if(pdiff[i] > max_diff)
						{
							max_diff = pdiff[i];
						#if DBG_SIEVE
							printf("pdiff = %d at curr_p = %u\n", 2*max_diff,ihi);
						#endif
						}
						if(++i == nprime)
						{
							break;
						}
					}
				}
				else
				{
					pdiff[i] += pdiff_8[j];
				}
			}
			continue;

		#elif ALLOW_PRP

			if(twopmodq32(curr_p-1, curr_p) == 0)
			{
				--i;
				continue;
			}

			if(curr_p < 341)
			{
				if(pdiff[i] > max_diff)
					max_diff = pdiff[i];
				continue;
			}

		  #if 0
			/* Modding w.r.to the small primes up to 43 eliminates roughly half the pseudoprimes: */
			if(curr_p%3 == 0 || curr_p%5 == 0 || curr_p%7 == 0 || curr_p%11== 0 || curr_p%13== 0 || curr_p%17== 0 || curr_p%19== 0 || curr_p%23== 0 || curr_p%29== 0 || curr_p%31== 0 || curr_p%37== 0 || curr_p%41== 0 || curr_p%43== 0)
			{
				++num_pseudo;
				fprintf(stderr,"%u[<47]...",curr_p);
				--i;
				continue;
			}
			l = 47;
			idx = 13;
		  #elif 1
			/* To speed the small-prime sieve init, test divisibility by smaller primes via 64-bit gcd rather than serial modulo.
				Use that a uint64 can store the product of odd primes 3 through 53 = 16294579238595022365.
			*/
			itmp64 = 16294579238595022365ull;
			j = (uint32)gcd64((uint64)curr_p, itmp64);
			if(j > 1)
			{
				++num_pseudo;
	//	fprintf(stderr,"%u...",curr_p);
				--i;
				continue;
			}
			l = 59;
			idx = 15;
		  #else
			l = 3;
			idx = 0;
		  #endif

			/* Trial-divide the next-prime candidate by all odds <= sqrt(curr_p).
			If none divide it, curr_p is prime - increment outer-loop parameters.
			If curr_p not prime, move on to next odd number; repeat until we find next odd prime. */
			sqrt_p = (uint32)(sqrt(1.0*curr_p) + 0.5);	/* Add a small fudge factor to the result of the sqrt to make sure RO errors don't
								cause the sqrt to be one smaller than it should be once we truncate to integer. */
			isprime = TRUE;

			while(l <= sqrt_p)
			{
				/* It's composite - go to next-larger odd number */
				if(curr_p%l == 0)
				{
					++num_pseudo;
		//	fprintf(stderr,"%u...",curr_p);
					isprime = FALSE;
					break;
				}
				l += (pdiff[++idx] << 1);
			}
			if(!isprime)
			{
				--i;
			}
			else
			{
				ihi = curr_p;
				if(pdiff[i] > max_diff)
				{
					max_diff = pdiff[i];
				#if 0
					printf("\npdiff = %d at curr_p = %u\n", 2*max_diff,ihi);
				#endif
				}
			}

		#elif 0

			ASSERT(HERE, curr_p <= f2psp[f2psp_idx],"Error in pseudoprime sieve");
			if(curr_p == f2psp[f2psp_idx])
			{
				++f2psp_idx;
				--i;
				continue;
			}
			else
			{
				ihi = curr_p;
				if(pdiff[i] > max_diff)
					max_diff = pdiff[i];
			}

		#endif

		}
		MAX_SIEVING_PRIME = ihi;

	#if 1//FAC_DEBUG
		printf("Using first %u odd primes; max gap = %u\n",nprime,2*max_diff);
		printf("max sieving prime = %u\n",MAX_SIEVING_PRIME);
	  #if ALLOW_PRP
		printf("number of base-2 Fermat pseudoprimes found = %u\n", num_pseudo);
	  #endif
	#endif

#if FERMAT_PSP2
	/**************************************************************************************************************/
	/********************** BASE-2 FERMAT PSEUDOPRIMES in [A, B] CODE *********************************************/
	/**************************************************************************************************************/

		/* Init modular inverse array: */
		curr_p = 3;
		for(m=0; m<nprime; m++)
		{
			curr_p += (pdiff[m] << 1);
			qinv = (curr_p+curr_p+curr_p) ^ (uint32)2;
			for(i = 0; i < 3; i++)
			{
				qinv = qinv*((uint32)2 - curr_p*qinv);
			}
			pinv[m] = qinv;
		}

		printf("Enter kmin>");
		scanf("%llu", &kmin);
		printf("Enter kmax>");
		scanf("%llu", &kmax);
		ASSERT(HERE, kmax > kmin,"kmax must be > kmin!");

		kmin|= 0x0000000000000001ull;	// kmin must be odd
		fprintf(stderr,"Searching for base-2 Fermat pseudoprimes in interval [%s, %s)...\n",&char_buf0[convert_uint64_base10_char(char_buf0, kmin)],&char_buf1[convert_uint64_base10_char(char_buf1, kmax)]);
		num_pseudo = 0;
		nfactor = 0;	/* Number of candidates in factor_k[] queue */
			  itmp64 = kmin;
		while(itmp64 < kmax)
		{
		#if 0
			if(twopmodq63(itmp64-1, itmp64) == 1)
			{
				/* To speed the small-prime sieve init, test divisibility by smaller primes via 64-bit gcd rather than serial modulo.
					Use that a uint64 can store the product of odd primes 3 through 53 = 16294579238595022365.
				*/
				res = gcd64(itmp64, 16294579238595022365ull);
				if(res > 1ull)
				{
					++num_pseudo;
					fprintf(stderr,"%s...",&char_buf0[convert_uint64_base10_char(char_buf0, itmp64)]);
					itmp64 += 2;
					continue;
				}
				l = 59;
				idx = 15;
				/* Trial-divide the next-prime candidate by all odds <= sqrt(curr_p).
				If none divide it, curr_p is prime - increment outer-loop parameters.
				If curr_p not prime, move on to next odd number; repeat until we find next odd prime. */
				sqrt_p = (uint32)(sqrt(1.0*itmp64) + 0.5);	/* Add a small fudge factor to the result of the sqrt to make sure RO errors don't
									cause the sqrt to be one smaller than it should be once we truncate to integer. */
				while(l <= sqrt_p)
				{
					/* It's composite - go to next-larger odd number */
					if(itmp64%l == 0)
					{
						++num_pseudo;
						fprintf(stderr,"%s...",&char_buf0[convert_uint64_base10_char(char_buf0, itmp64)]);
						break;
					}
					l += (pdiff[++idx] << 1);
				}
			}
			itmp64 += 2;
		#else
			itmp32 = (uint32)twopmodq63_x8(itmp64, itmp64+ 2, itmp64+ 4, itmp64+ 6, itmp64+ 8, itmp64+10, itmp64+12, itmp64+14);
			for(i = 0; i < 8; ++i, itmp64 += 2)
			{
				if((itmp32 >> i)&0x1)	/* It's a PRP */
				{
					DBG_ASSERT(HERE, twopmodq63(itmp64-1, itmp64) == 1, "!");
					/* To speed the small-prime sieve init, test divisibility by smaller primes via 64-bit gcd rather than serial modulo.
						Use that a uint64 can store the product of odd primes 3 through 53 = 16294579238595022365.
					*/
					res = gcd64(itmp64, 16294579238595022365ull);
					if(res > 1ull)
					{
						++num_pseudo;
						fprintf(stderr,"%s...",&char_buf0[convert_uint64_base10_char(char_buf0, itmp64)]);
						continue;
					}
				#if 1	/************/
					factor_k[nfactor++] = itmp64;
				#else
					l = 59;
					idx = 15;
					/* Trial-divide the next-prime candidate by all odds <= sqrt(curr_p).
					If none divide it, curr_p is prime - increment outer-loop parameters.
					If curr_p not prime, move on to next odd number; repeat until we find next odd prime. */
					sqrt_p = (uint32)(sqrt(1.0*itmp64) + 0.5);	/* Add a small fudge factor to the result of the sqrt to make sure RO errors don't
										cause the sqrt to be one smaller than it should be once we truncate to integer. */
					while(l <= sqrt_p)
					{
						/* It's composite - go to next-larger odd number */
					#if 0
						if(itmp64%l == 0)
					#else
						qinv = pinv[idx];
						m = mi64_is_div_by_scalar32p(&itmp64, l, qinv, 1u);
						if(m)
					#endif
						{
							++num_pseudo;
							fprintf(stderr,"%s...",&char_buf0[convert_uint64_base10_char(char_buf0, itmp64)]);
							break;
						}
						l += (pdiff[++idx] << 1);
					}
				#endif	/*************/
				}
			}
			if(nfactor >= 8)	/* if >= in queue, trial-divide the first 8 */
			{
				l = 59;
				idx = 15;
				itmp32 = 0;
				sqrt_p = (uint32)(sqrt(1.0*factor_k[7]) + 0.5);
				while(l <= sqrt_p)
				{
					qinv = pinv[idx];
			#ifdef USE_SSE2
				#if 0
				//	itmpA = mi64_is_div_by_scalar32p_x8     (factor_k,factor_k+1,factor_k+2,factor_k+3,factor_k+4,factor_k+5,factor_k+6,factor_k+7, l, qinv, 1u, &itmpC);
					itmpB = mi64_is_div_by_scalar32p_x8_SSE2(factor_k,factor_k+1,factor_k+2,factor_k+3,factor_k+4,factor_k+5,factor_k+6,factor_k+7, l, qinv, 1u, &itmpD);
				//	ASSERT(HERE, itmpA == itmpB, "mi64_is_div_by_scalar32p_x8_SSE2: incorrect result!");
				//	ASSERT(HERE, itmpC == itmpD, "mi64_is_div_by_scalar32p_x8_SSE2: incorrect checksum!");
				#else
					MI64_IS_DIV_BY_SCALAR32P_X8_SSE2(factor_k, l, qinv, itmpB);		/* Inline macro about 25% faster than above function-call version */
				#endif
					itmp32 |= itmpB;
			#else
					itmp32 |= mi64_is_div_by_scalar32p_x8(factor_k,factor_k+1,factor_k+2,factor_k+3,factor_k+4,factor_k+5,factor_k+6,factor_k+7, l, qinv, 1u, &itmpA);
			#endif
					l += (pdiff[++idx] << 1);
				}
				for(i = 0; i < 8; ++i)
				{
					if((itmp32 >> i)&0x1)	/* It's a PRP */
					{
						++num_pseudo;
						fprintf(stderr,"%s...",&char_buf0[convert_uint64_base10_char(char_buf0, factor_k[i])]);
					}
				}
				/* Move any remaining ones to head of queue: */
				nfactor -= 8;
				for(i = 0; i < nfactor; ++i)
				{
					factor_k[i] = factor_k[i+8];
				}
			}	/* nfactor >= 8 */
		#endif
		}
		/* Process any remaining in queue: */
		for(i = 0; i < nfactor; ++i)
		{
			itmp64 = factor_k[i];
			l = 59;
			idx = 15;
			/* Trial-divide the next-prime candidate by all odds <= sqrt(curr_p).
			If none divide it, curr_p is prime - increment outer-loop parameters.
			If curr_p not prime, move on to next odd number; repeat until we find next odd prime. */
			sqrt_p = (uint32)(sqrt(1.0*itmp64) + 0.5);	/* Add a small fudge factor to the result of the sqrt to make sure RO errors don't
								cause the sqrt to be one smaller than it should be once we truncate to integer. */
			while(l <= sqrt_p)
			{
				/* It's composite - go to next-larger odd number */
			#if 0
				if(itmp64%l == 0)
			#else
				qinv = pinv[idx];
				m = mi64_is_div_by_scalar32p(&itmp64, l, qinv, 1u);
				if(m)
			#endif
				{
					++num_pseudo;
					fprintf(stderr,"%s...",&char_buf0[convert_uint64_base10_char(char_buf0, itmp64)]);
					break;
				}
				l += (pdiff[++idx] << 1);
			}
		}
		nfactor = 0;
		printf("number of base-2 Fermat pseudoprimes in interval = %u\n", num_pseudo);
		exit(0);
	#endif
	/*****************************************************************************************************/
#endif

/* Time the vector trialdiv stuff: */
#if TEST_TRIALDIV
	for(i = 0; i < vec_len; i++)
	{
		xvec[i]  = rng_isaac_rand();
	}

	clock1 = clock();
	curr_p = 3;
	for(m=0; m<nprime; m++)
	{
		curr_p += (pdiff[m] << 1);
		if(mi64_is_div_by_scalar32(xvec, curr_p, vec_len) == TRUE)
			printf("mi64_is_div_by_scalar32 test: %10u is a divisor\n", curr_p);
	}

	clock2 = clock();	/* Assume sieve setup time < 2^32 cycles - even if that is violated it's no big deal at this point. */
	tdiff = (double)(clock2 - clock1)/CLOCKS_PER_SEC;	/* NB: CLOCKS_PER_SEC may be a phony value used to scale clock() ranges */
	citer = tdiff*2000000000.0;
	citer /= (double)vec_len*nprime;
	printf	("Elapsed Time =%2d%1d:%1d%1d:%1d%1d.%1d%1d%1d; cycles/iter = %10.2f\n"
		,(int)tdiff/36000,((int)tdiff%36000)/3600
		,((int)tdiff%3600)/600,((int)tdiff%600)/60
		,((int)tdiff%60)/10,(int)tdiff%10
		,(int)(10*(tdiff-(int)tdiff)),(int)(100*(tdiff-(int)tdiff))%10,(int)(1000*(tdiff-(int)tdiff))%10
		,citer
	);

	clock1 = clock();
	curr_p = 3;
	for(m=0; m<nprime; m+=4)
	{
		curr_p += (pdiff[m  ] << 1); tryq[0] = curr_p;
		curr_p += (pdiff[m+1] << 1); tryq[1] = curr_p;
		curr_p += (pdiff[m+2] << 1); tryq[2] = curr_p;
		curr_p += (pdiff[m+3] << 1); tryq[3] = curr_p;
		j = mi64_is_div_by_scalar32_x4(xvec, tryq[0], tryq[1], tryq[2], tryq[3], vec_len);
		if(j != 0)
		{
			for(i=0;i<4;++i)
			{
				if((j >> i)&1)
					printf("mi64_is_div_by_scalar32_x4 test: %10u is a divisor\n", tryq[i]);
			}
		}
	}

	clock2 = clock();	/* Assume sieve setup time < 2^32 cycles - even if that is violated it's no big deal at this point. */
	tdiff = (double)(clock2 - clock1)/CLOCKS_PER_SEC;	/* NB: CLOCKS_PER_SEC may be a phony value used to scale clock() ranges */
	citer = tdiff*2000000000.0;
	citer /= (double)vec_len*nprime;
	printf	("Elapsed Time =%2d%1d:%1d%1d:%1d%1d.%1d%1d%1d; cycles/iter = %10.2f\n"
		,(int)tdiff/36000,((int)tdiff%36000)/3600
		,((int)tdiff%3600)/600,((int)tdiff%600)/60
		,((int)tdiff%60)/10,(int)tdiff%10
		,(int)(10*(tdiff-(int)tdiff)),(int)(100*(tdiff-(int)tdiff))%10,(int)(1000*(tdiff-(int)tdiff))%10
		,citer
	);

	clock1 = clock();
	curr_p = 3;
	for(m=0; m<nprime; m+=8)
	{
		curr_p += (pdiff[m  ] << 1); tryq[0] = curr_p;
		curr_p += (pdiff[m+1] << 1); tryq[1] = curr_p;
		curr_p += (pdiff[m+2] << 1); tryq[2] = curr_p;
		curr_p += (pdiff[m+3] << 1); tryq[3] = curr_p;
		curr_p += (pdiff[m+4] << 1); tryq[4] = curr_p;
		curr_p += (pdiff[m+5] << 1); tryq[5] = curr_p;
		curr_p += (pdiff[m+6] << 1); tryq[6] = curr_p;
		curr_p += (pdiff[m+7] << 1); tryq[7] = curr_p;
		j = mi64_is_div_by_scalar32_x8(xvec, tryq[0], tryq[1], tryq[2], tryq[3], tryq[4], tryq[5], tryq[6], tryq[7], vec_len);
		if(j != 0)
		{
			for(i=0;i<8;++i)
			{
				if((j >> i)&1)
					printf("mi64_is_div_by_scalar32_x8 test: %10u is a divisor\n", tryq[i]);
			}
		}
	}

	clock2 = clock();	/* Assume sieve setup time < 2^32 cycles - even if that is violated it's no big deal at this point. */
	tdiff = (double)(clock2 - clock1)/CLOCKS_PER_SEC;	/* NB: CLOCKS_PER_SEC may be a phony value used to scale clock() ranges */
	citer = tdiff*2000000000.0;
	citer /= (double)vec_len*nprime;
	printf	("Elapsed Time =%2d%1d:%1d%1d:%1d%1d.%1d%1d%1d; cycles/iter = %10.2f\n"
		,(int)tdiff/36000,((int)tdiff%36000)/3600
		,((int)tdiff%3600)/600,((int)tdiff%600)/60
		,((int)tdiff%60)/10,(int)tdiff%10
		,(int)(10*(tdiff-(int)tdiff)),(int)(100*(tdiff-(int)tdiff))%10,(int)(1000*(tdiff-(int)tdiff))%10
		,citer
	);

	clock1 = clock();
	curr_p = 3;
	for(m=0; m<nprime; m++)
	{
		curr_p += (pdiff[m] << 1);
		if(mi64_is_div_by_scalar64(xvec, (uint64)curr_p, vec_len) == TRUE)
			printf("mi64_is_div_by_scalar64 test: %10u is a divisor\n", curr_p);
	}
	clock2 = clock();	/* Assume sieve setup time < 2^32 cycles - even if that is violated it's no big deal at this point. */
	tdiff = (double)(clock2 - clock1)/CLOCKS_PER_SEC;	/* NB: CLOCKS_PER_SEC may be a phony value used to scale clock() ranges */
	citer = tdiff*2000000000.0;
	citer /= (double)vec_len*nprime;
	printf	("Elapsed Time =%2d%1d:%1d%1d:%1d%1d.%1d%1d%1d; cycles/iter = %10.2f\n"
		,(int)tdiff/36000,((int)tdiff%36000)/3600
		,((int)tdiff%3600)/600,((int)tdiff%600)/60
		,((int)tdiff%60)/10,(int)tdiff%10
		,(int)(10*(tdiff-(int)tdiff)),(int)(100*(tdiff-(int)tdiff))%10,(int)(1000*(tdiff-(int)tdiff))%10
		,citer
	);

	free((void*)xvec);
#endif

/*   for p < max prime in precomputed table, need to truncate the range of primes...	*/
	/*********** WHY WAS THIS HERE??
	curr_p = MAX_SIEVING_PRIME;
	for(;;)
	{
		if(p > curr_p) break;
		curr_p -= (pdiff[nprime--] << 1);
	#if FAC_DEBUG
		ASSERT(HERE, curr_p == prime[nprime], "factor.c : curr_p == prime[nprime]");
	#endif
	}
	MAX_SIEVING_PRIME = curr_p;
	***********/

	/****************** KNOWN-TEST-FACTOR STUFF: *******************/
#if FAC_DEBUG
	/* If target-q string not empty, do the following:

		1) convert target q to numeric base-2^64 form,
		2) verify that q == 1 (mod 2*p);
		3) calculate k_targ;
		4) calculate k_targ%60 for the target-pass calculation.

	(1-3) need wordsize-dependent arithmetic; (4) is wordsize-independent.
	*/
	/* From here on out, we can quickly check if there's a reference factor or not
	by testing if k_targ > 0:
	*/
	if(STRNEQ(qstring, ""))
	{
	#if(defined(P1WORD))
		q_targ = convert_base10_char_uint64(qstring);
		itmp64 = q_targ%two_p;
		if(itmp64 != 1ull)
		{
			fprintf(stderr,"factor.c: ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",&char_buf0[convert_uint64_base10_char(char_buf0, p)], &char_buf1[convert_uint64_base10_char(char_buf1, q_targ)], &char_buf2[convert_uint64_base10_char(char_buf2, itmp64)]);
			ASSERT(HERE, 0,"0");
		}
		k_targ = (q_targ - itmp64)/two_p;
	#else
		q_targ = convert_base10_char_mi64(qstring, &lenT);
		ASSERT(HERE, lenT > 0, "factor.c: Error converting qstring!");
		ASSERT(HERE, lenT <= lenQ, "factor.c: lenT > lenQ!");
		mi64_clear(u64_arr, lenT);
		mi64_div(q_targ,two_p,q2,u64_arr,lenT);
		ASSERT(HERE, mi64_getlen(q2, lenT) == 1 , "k_targ must be 64-bit!");
		k_targ = q2[0];
		if(!mi64_cmpeq_scalar(u64_arr, 1ull, lenT))
		{
			fprintf(fp    ,"ERROR : (p, q_targ) = ( %s, %s ) : q_tarq mod (2p) = %s != 1!\n",&char_buf0[convert_mi64_base10_char(char_buf0,p,lenP)], &char_buf1[convert_mi64_base10_char(char_buf1, q_targ, lenT)], &char_buf2[convert_mi64_base10_char(char_buf2, u64_arr, lenT)]);	fclose(fp); fp = 0x0;
			fprintf(stderr,"ERROR : (p, q_targ) = ( %s, %s ) : q_targ mod (2p) = %s != 1!\n",&char_buf0[convert_mi64_base10_char(char_buf0,p,lenP)], &char_buf1[convert_mi64_base10_char(char_buf1, q_targ, lenT)], &char_buf2[convert_mi64_base10_char(char_buf2, u64_arr, lenT)]);
			ASSERT(HERE, 0,"0");
		}

		true_false = mi64_twopmodq(p, lenP, q_targ, lenT, 0x0);
		if(!true_false)
		{
			fprintf(stderr,"q_targ is not prime!");
		//	ASSERT(HERE, 0,"");
		}
	#endif
		kmod60 = k_targ%60;

		printf("p mod 60 = %d\n", pmod60);
		printf("k mod 60 = %d\n", kmod60);

		/* ...and get the pass number on which the factor should be found.
		(Remember that the pass number returned by CHECK_PKMOD60 is unit-offset).
		If a known factor given, only process the given k/log2 range for that pass:
		*/
		pass_targ = CHECK_PKMOD60(pmod60, kmod60) - 1;
		ASSERT(HERE, k_targ > 0,"k_targ > 0");
	}
	else
	{
		ASSERT(HERE, k_targ ==0,"k_targ ==0");
	}
#endif	/* end #if(FAC_DEBUG) (q_targ processing) */

	i = 0;
	switch(pmod60){
/*   The 16 relevant p mod 60 cases. It's times like
     these that I really long for f90-style vector array initializations...	*/
		case  1:incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 4;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]=11;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 4;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1; break;
		case  7:incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 4;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]=11;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 4;incr[i++]= 3; break;
		case 11:incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 4;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 4;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]=11; break;
		case 13:incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 4;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]=11;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 4; break;
		case 17:incr[i++]= 3;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 4;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]=11;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 4;incr[i++]= 3;incr[i++]= 5; break;
		case 19:incr[i++]= 5;incr[i++]= 4;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 4;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]=11;incr[i++]= 1;incr[i++]= 3; break;
		case 23:incr[i++]= 1;incr[i++]=11;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 4;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 4;incr[i++]= 5;incr[i++]= 3; break;
		case 29:incr[i++]= 4;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 4;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]=11;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5; break;
		case 31:incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]=11;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 4;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 4; break;
		case 37:incr[i++]= 3;incr[i++]= 5;incr[i++]= 4;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 4;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]=11;incr[i++]= 1; break;
		case 41:incr[i++]= 3;incr[i++]= 1;incr[i++]=11;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 4;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 4;incr[i++]= 5; break;
		case 43:incr[i++]= 5;incr[i++]= 3;incr[i++]= 4;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]=11;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 4;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]= 3; break;
		case 47:incr[i++]= 4;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]=11;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 4;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3; break;
		case 49:incr[i++]=11;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 4;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 4;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1; break;
		case 53:incr[i++]= 3;incr[i++]= 4;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]=11;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 4;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5; break;
		case 59:incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3;incr[i++]= 4;incr[i++]= 5;incr[i++]= 3;incr[i++]= 1;incr[i++]=11;incr[i++]= 1;incr[i++]= 3;incr[i++]= 5;incr[i++]= 4;incr[i++]= 3;incr[i++]= 5;incr[i++]= 3; break;
		default:
			fprintf(stderr,"%u not an acceptable value for P mod 60. P likely nonprime.\n", pmod60); ASSERT(HERE, 0,"0");
	}


	/* If it's a restart, interval_lo for the initial pass will be based
	on (know), rather than (kmin) - handle that just inside the pass-loop: */
	interval_lo = (kmin>>6)/(uint64)len;
	interval_now= (know>>6)/(uint64)len;
	interval_hi = (uint64)ceil((double)(kmax>>6)/len);

	/* Make sure we always do at least one full pass through the sieve
	(e.g. if kmin = kmax = 1, ceil(kmax>>6) gives 0, same as (kmin>>6): */
	if(interval_hi == interval_lo)
		interval_hi += 1;

	ninterval = interval_hi - interval_lo;

	/* The actual kmin/kmax values used in the run are exact multiples
	of len*64 - we always do at least one full pass through the sieve,
	i.e. we run through at least (len*64) worth of k's */
	kmin = interval_lo *(len<<6);
	know = interval_now*(len<<6);
	kmax = interval_hi *(len<<6);

	/* And now that we have the actual kmin/kmax, recalculate these: */
  #if(defined(P1WORD))
	fqlo = kmin*twop_float + 1.0;
	fqhi = kmax*twop_float + 1.0;
  #endif

	/* 11/14/05: Since we don't actually use bmin/bmax for anything other
	than setting sieving bounds (which then get modified via the above
	k-is-exact-multiple-of-sieve-length anyway), preserve any user-set
	values, since these are typically whole numbers, and look nicer
	in diagnostic and savefile printing:
	*/
	/*	bmin = log(fqlo)/log(2.0);*/
	/*	bmax = log(fqhi)/log(2.0);*/

#if FAC_DEBUG
	/* Make sure the range of k's for the run contains any target factor: */
	if(STRNEQ(qstring, ""))
		ASSERT(HERE, (kmin <= k_targ) && (kmax >= k_targ),"k_targ not in [kmin, kmax]");
#endif

	ASSERT(HERE, fp == 0x0,"0");
#ifdef FACTOR_STANDALONE
	fp = stderr;
#else
	fp = fopen(STATFILE,"a");
#endif
	fq = fopen(OFILE,"a");

#ifdef P1WORD
	sprintf(char_buf0, "searching in the interval k=[%s, %s], i.e. q=[%e, %e]\n", &char_buf1[convert_uint64_base10_char(char_buf1, kmin )], &char_buf2[convert_uint64_base10_char(char_buf2, kmax )],fqlo,fqhi);
#else
	sprintf(char_buf0, "searching in the interval k=[%s, %s]\n", &char_buf1[convert_uint64_base10_char(char_buf1, kmin )], &char_buf2[convert_uint64_base10_char(char_buf2, kmax )]);
#endif
	fprintf(fp, char_buf0);	fprintf(fq, char_buf0);

	sprintf(char_buf0, "each of %2u (p mod 60) passes will consist of %s intervals of length %u\n", passmax-passmin+1, &char_buf1[convert_uint64_base10_char(char_buf1, ninterval)], bit_len);
	fprintf(fp, char_buf0);	fprintf(fq, char_buf0);

	if(passnow != passmin || know != kmin)
	{
		sprintf(char_buf0, "Resuming execution with pass %u and k = %s\n", passnow, &char_buf1[convert_uint64_base10_char(char_buf1, know )]);
		fprintf(fp, char_buf0);	fprintf(fq, char_buf0);
		sprintf(char_buf0, "#Q tried = %s\n", &char_buf1[convert_uint64_base10_char (char_buf1, count)] );
		fprintf(fp, char_buf0);	fprintf(fq, char_buf0);
		sprintf(char_buf0, "Checksum1 = %s, Checksum2 = %s\n", &char_buf1[convert_uint64_base16_char (char_buf1, checksum1)], &char_buf2[convert_uint64_base16_char (char_buf2, checksum2)]);
		fprintf(fp, char_buf0);	fprintf(fq, char_buf0);
	}

#ifndef FACTOR_STANDALONE
	fclose(fp);
#endif
	fp = 0x0;
	fclose(fq); fq = 0x0;

/*...init clocks, etc....*/
	clock1 = clock();
	tdiff = 0.0;

/* quick way to set all the bits = 1	*/
	for(i = 0; i < len; i++)
	{
		temp_late[i] = ~(uint64)0;
	}

/*...now generate q = 2kp+1 for as many k as desired; trial divide only if q passes
     a small-primes sieve and if q mod 8 = +1 or -1...	*/

	/*  q mod 8 = +-1 sieve is simplest, so do it first. Note q mod 8 = +-1 is guaranteed
	!   for p mod 60 sieve via choice of acceptable values of increment (incr), but doing
	!   q%8 = +-1 here is trivial and speeds search for multiples of small primes below.
	*/
	qmod8 = 1;
	for(i = 0; i < 4; i++)
	{
		/* Remember that k = 1 is in the zeroth bit here, i.e. we cycle through
		bits 0-3 which correspond to q = 2kp+1, 4kp+1, 6kp+1, 8kp+1, respectively:
		*/
		/* We don't need to worry about overflow-on-add of (two_p + qmod8),
		since an overflow won't affect the result, modulo 8.
		*/
	#ifdef P1WORD
		qmod8=(two_p    + qmod8) & 7;
	#else
		qmod8=(two_p[0] + qmod8) & 7;
	#endif
		if(qmod8==3 || qmod8==5)
		{
			for(l=i; l < 64; l+=4)
			{
				temp_late[0] &= ~((uint64)1 << l); /* clear every fourth such bit from the first quadword...	*/
			}
		}
	}
/* ...Since the small-primes sieve needs only three (q mod 8 = +-1)-sieved registers to begin with, make 2 copies of the result...	*/
	temp_late[1]=temp_late[0];
	temp_late[2]=temp_late[0];

/*...next, find multiples of small primes.	*/

	regs_todo=1;

	curr_p = 3;
	for(m=0; m<nclear; m++)
	{
		curr_p += (pdiff[m] << 1);

		two64modp = 0x8000000000000000ull%curr_p;
		two64modp = (two64modp + two64modp)%curr_p;

		regs_todo=regs_todo*curr_p;

	#ifdef P1WORD
		q = 1ull;
	#else
		mi64_set_eq_scalar(q, 1ull, lenQ);
	#endif

		for(k=0; k<regs_todo; k++)	/* number of registers to run through while seaching for first multiple of (m)th prime...	*/
		{
			for(i=0; i<64; i++)			/* ...and run through the 64 bits of each register. */
			{
			#ifdef P1WORD
				q=q+two_p;
				res = q%curr_p;
			#else
				mi64_add(q,two_p,q,lenQ);
				res = mi64_div_y32(q,curr_p,0x0,lenQ);
			#endif

				if(res==0)
				{
				#if DBG_SIEVE
					if(curr_p < 100)
						printf("0: Found a multiple of %u in bit %u of register %u\n", curr_p, i, (uint32)k);
				#endif
					for(l = (uint32)(k<<6)+i; l < (regs_todo<<6); l += curr_p)
					{
						i64=(l>>6);	/* l/64	*/
						bit=l&63;	/* l%64	*/
						temp_late[i64] &= ~((uint64)1 << bit);
					}
					goto KLOOP;
				}
			}
		}
		/* Should never reach this regular-loop-exit point: */
		fprintf(stderr,"ERROR: failed to find a multiple of prime %u\n", curr_p);
		ASSERT(HERE, 0,"0");

	KLOOP:
		/*...Now propagate copies of length (regs_todo) bit-cleared portion of sieve
		to remaining parts of sieve.
		*/
		if(m<(nclear-1))
		{
			ncopies=prime[m+1];
			l=regs_todo;
			for(i=2; i<=ncopies; i++)
			{
				for(j=0; j<regs_todo; j++)
				{
					temp_late[l+j]=temp_late[j];
				}
				l=l+regs_todo;
			}
		}
	}	/* endfor(m=0; m<nclear; m++) */

	/*
	on_bits = 0;
	for(m=0; m<len; m++)
	{
		for(i=0; i<64; i++)
		{
			on_bits += (temp_late[m]>>i) & 1;
		}
	}
	printf("%u ones bits of %u in sieve.\n", on_bits, len<<6);
	*/

	/*...calculate offsets, needed for primes larger than prime(nclear). */
	curr_p = p_last_small;
	for(m=nclear; m<nprime; m++)
	{
		curr_p += (pdiff[m] << 1);

		two64modp = 0x8000000000000000ull%curr_p;
		/*two64modp = (two64modp + two64modp) - curr_p;  Replace this with the following, which eschews the expensive library mod call: */
		two64modp = (two64modp + two64modp) - curr_p;
		two64modp += (-(two64modp >> 63)) & curr_p;

		/*q=1;*/

		/* If NUM_SIEVING_PRIME is such that the largest sieveprime >= Mersenne exponent p,
		without special handling here the sieve-clearing routine winds up sending a zero argument
		to the extended GCD routine used to calculate sieve bit offsets, causing an error.
		The fix is simple - in such cases we assign offset[m] the special value of 0xffffffff,
		and trap for that in the sieve-clearing routine - if this value is encountered for an
		offset[] element, the sieve-clearing routine skips over the prime in question (which
		must necessarily equal the exponent being tested) as it processes the sieving primes -
		this is of course OK, since p can never divide a factor candidate q = 2*k*p+1 anyway.
		*/
	#ifdef P1WORD
		twop_mod_currp = two_p%curr_p;
		if(twop_mod_currp == 0)
		{
			ASSERT(HERE, p == curr_p ,"2*p == 0 mod curr_p but p != curr_p");
			offset[m] = 0xffffffff;
			continue;
		}
	#else
		twop_mod_currp = mi64_div_y32(two_p, curr_p, 0x0, lenP);
		if(twop_mod_currp == 0)
		{
//	t256 = NIL256;	t256.d0 = curr_p;
			ASSERT(HERE, mi64_cmpeq_scalar(p, curr_p, lenP),"2*p == 0 mod curr_p but p != curr_p");
			offset[m] = 0xffffffff;
			continue;
		}
	#endif

	#if 0	/* Change this to 1 if you prefer to do things really slowly */
		q_mod_currp = 1;

		for(k=0; k<len; k++)
		{
			for(i=0; i<64; i++)
			{
			/*
				q += two_p;
				q_mod_currp = q%curr_p;	// This system mod call is *really* slow, so replace it with a better sequence:
			*/
				q_mod_currp  =  q_mod_currp + twop_mod_currp - curr_p;	// Subtract off curr_p...
				q_mod_currp += (-(q_mod_currp >> 31)) & curr_p;		// ...and restore it if result was < 0.

				if(q_mod_currp == 0)
				{
				#if FAC_DEBUG
					/* Print diagnostic info for selected prime subranges: */
					if(curr_p < 300)
						printf("A: Found a multiple of %8u in bit %6u; modinv = %8u\n", curr_p, (k<<6)+i+1, -modinv32((uint32)twop_mod_currp, curr_p)-1);

					if((k<<6)+i != -modinv32((uint32)twop_mod_currp, curr_p)-1)
					{
						fprintf(stderr,"MISMATCH: %u != %u\n", (k<<6)+i, -modinv32((uint32)twop_mod_currp, curr_p)-1);
						ASSERT(HERE, 0,"0");
					}
				#endif

					/*...later, will move startvalue into upper 2 bytes of prime(m).	*/
					offset[m] = (k<<6)+i;
					goto OUTER;
				}
				/* If find a k such that 2*k*p == +1 (rather than -1) mod curr_p, i.e. q == 2 mod curr_p,
				then this is the mirror image (w.r.to the sieve) of the bit we want:
				*/
				else if(q_mod_currp == 2)
				{
				#if FAC_DEBUG
					/* Print diagnostic info for the smaller primes: */
					if(curr_p < 300)
						printf("B: Found a multiple of %8u in bit %6u; modinv = %8u\n", curr_p, (k<<6)+i+1, +modinv32((uint32)twop_mod_currp, curr_p)-1);

					if((k<<6)+i != +modinv32((uint32)twop_mod_currp, curr_p)-1)
					{
						fprintf(stderr,"MISMATCH: %u != %u\n", (k<<6)+i, +modinv32((uint32)twop_mod_currp, curr_p)-1);
						ASSERT(HERE, 0,"0");
					}
				#endif

					/* Since bit 0 of sieve corresponds to factor index k = 1, do the mirror-image
					index subtraction in unit-offset mode, i.e. if mirror image is in (unit-offset)
					bit B', then B = curr_p - B' = curr_p - [(k<<6)+i+1].
					Subtract one from this to get B in zero-offset form:
					*/
					offset[m] = curr_p - ((k<<6)+i+2);
					goto OUTER;
				}
			}
		}
		fprintf(stderr,"ERROR: failed to find a multiple of prime %u\n", curr_p);
		ASSERT(HERE, 0,"0");

		OUTER: continue;

	#else
		/*
		Q: can we find these sieve bit offsets in an a priori fashion, rather than via
		expensive trial and error?
		A: Indeed we can. For example, consider p = 2^89 + 89 = 618970019642690137449562201.
		A snippet of output from the trial-and-error small-prime disivor code:

		...
		Found a multiple of 224699 in bit  6 of register  254	<== k = (64*254 + 7) = 16263
		Found a multiple of 224711 in bit 51 of register 3156
		Found a multiple of 224717 in bit 51 of register 1454
		Found a multiple of 224729 in bit 10 of register 2536
		Found a multiple of 224737 in bit 33 of register 2270
		Found a multiple of 224743 in bit 26 of register 1669
		...

		Each bit of the initial sieve (let's number them from 0 to n-1) represents an
		increment of 2*p. Need to find a bit k such that q(k) := 2*p*k + 1 == 0 mod curr_p.
		If we precompute m = 2*p mod curr_p, then q(k) mod curr_p = (m*k + 1) mod curr_p.
		In our example, the prime curr_p = 224699 has 2*p == 198862 mod curr_p. We need to
		find the smallest integer k such that k*198862 == -1 mod 224699. This gives k=16263.
		So what we need is basically a fast way to find the mod-inverse of the
		2*p (mod curr_p), and then simply negate that - We can use the eGCD for this.

		Example PARI code to find inverse of 198862 mod 224699
		(negate result to get the desired sign, +16263):

		x = 224699; y = 198862;

		a = 1; b = 0; g = x; u = 0; v = 1; w = y; w

		q = (g-g%w)/w;
		d = a - q*u;
		e = b - q*v;
		f = g - q*w;
		a = u;
		b = v;
		g = w;
		u=d;u
		v=e;v
		w=f;w

		(repeat above 10-step sequence until w=0).

		The sequence of w's is 198862, 25837, 18003, 7834, 2335, 829, 677, 152, 69, 14, 13, 1, 0.
		Inverse (value of b on exit from the above loop) is -16263.

		Note that being able to quit as soon as we find either k or k' halves the time
		needed to set up the sieve.
		More importantly, it reveals one subtlety in the eGCD approach: If the inverse
		of (2*p) mod curr_p is negative, then the inverse = -k and we simply negate it
		to get k. If on the other hand the inverse is positive, inverse == k' (mod curr_p),
		and we get k = curr_p - k'.

		Lastly, in the actual implementation we add one to k to get the location of the
		sieve bit, since the zero bit of our sieve corresponds to k = 1, not k = 0.
		*/
		if((int)twop_mod_currp < 0)
		{
			fprintf(stderr,"twop_mod_currp = %u for curr_p = %u out of range!\n",twop_mod_currp, curr_p);
			ASSERT(HERE, 0,"0");
		}

		i = modinv32((uint32)twop_mod_currp, curr_p);
		ASSERT(HERE, i, "factor.c : i");

		/* i < 0 corresponds to the (q_mod_currp == 0) case in the above (#ifdef'ed out) section.
		   i > 0 corresponds to the (q_mod_currp == 2) case.
		*/
		if((int)i < 0)
		{
		#if DBG_SIEVE
			/* Print diagnostic info for selected prime subranges: */
			if(curr_p > 116965000 && curr_p < 116966000)
				printf("C: Found a multiple of %8u in bit %6u\n", curr_p, -i-1);
		#endif
			offset[m] =        - (i+1);
		}
		else
		{
		#if DBG_SIEVE
			/* Print diagnostic info for selected prime subranges: */
			if(curr_p > 116965000 && curr_p < 116966000)
				printf("D: Found a multiple of %8u in bit %6u\n", curr_p, curr_p-i-1);
		#endif

			offset[m] = curr_p - (i+1);
		}

	#endif	/* end(#if 0) */
	}	/* endfor(m=nclear; m<nprime; m++) */

#ifdef FACTOR_STANDALONE
	 printf(   "TRYQ = %u, max sieving prime = %u\n",TRYQ,MAX_SIEVING_PRIME);
#else
	ASSERT(HERE, fp == 0x0,"0");
	fp = fopen(STATFILE,"a");
	fprintf(fp,"TRYQ = %u, max sieving prime = %u\n",TRYQ,MAX_SIEVING_PRIME);
	fclose(fp); fp = 0x0;
#endif

	/*...create template for each of the sixteen K mod 60 cases...	*/

	for(i=0; i<=len/60; i++)
	{
		for(j=0; j<16; j++)
		{
			/*template[i][j]=0;*/
			*(template+(i<<4)+j)=0;	/* calloc! */

		}
	}

	i=incr[0]-1;
	j=0;
	k=0;
	for(;;) /* K loops over 64-bit registers...	*/
	{
		l=0;
L3:		if(k==len)break;
		for(;;) /* I loops over bits...	*/
		{
			word=(uint32)(j>>6);
			bit =(uint32)(j&63);
/*
if(l == 10 && word==1024 && bit == 24)
{
if(!((temp_late[k]>>i) & 1))printf("critical bit = 0! Loc in temp_late: word %d, bit %3u\n", k, i);
}
*/
			if((temp_late[k]>>i) & 1)
			{
				/*template[word][l] |= ((uint64)1 << bit);*/
				*(template+(word<<4)+l) |= ((uint64)1 << bit);
			}
			l++;
			if(l>>4)
			{
				l &= 15;
				j++;
			}
			i=i+incr[l];
			if(i>>6)
			{
				i &= 63;
				k++;
				goto L3;
			}
		} /* end of I loop	*/
	}	/* end of K loop	*/

/*...deallocate full-sized template.	*/
	free((void *)temp_late); temp_late = 0x0;

/*...At this point, replace the relative with the absolute increments:	*/
	for(i=1; i<16; i++)	/* Skip pass 0 here */
	{
		incr[i] = incr[i-1] + incr[i];
	}

	i = 0;
	switch(pmod60)
	{
/*   p mod 12 = 1:	*/
		case  1:ASSERT(HERE, incr[i++]== 3&&incr[i++]== 8&&incr[i++]==11&&incr[i++]==15&&incr[i++]==20&&incr[i++]==23&&incr[i++]==24&&incr[i++]==35&&incr[i++]==36&&incr[i++]==39&&incr[i++]==44&&incr[i++]==48&&incr[i++]==51&&incr[i++]==56&&incr[i++]==59&&incr[i++]==60, "factor.c : case  1"); break;	/* k mod 5 .ne. 2	*/
		case 37:ASSERT(HERE, incr[i++]== 3&&incr[i++]== 8&&incr[i++]==12&&incr[i++]==15&&incr[i++]==20&&incr[i++]==23&&incr[i++]==24&&incr[i++]==27&&incr[i++]==32&&incr[i++]==35&&incr[i++]==39&&incr[i++]==44&&incr[i++]==47&&incr[i++]==48&&incr[i++]==59&&incr[i++]==60, "factor.c : case 37"); break;	/* k mod 5 .ne. 1	*/
		case 13:ASSERT(HERE, incr[i++]== 3&&incr[i++]== 8&&incr[i++]==11&&incr[i++]==12&&incr[i++]==15&&incr[i++]==20&&incr[i++]==23&&incr[i++]==27&&incr[i++]==32&&incr[i++]==35&&incr[i++]==36&&incr[i++]==47&&incr[i++]==48&&incr[i++]==51&&incr[i++]==56&&incr[i++]==60, "factor.c : case 13"); break;	/* k mod 5 .ne. 4	*/
		case 49:ASSERT(HERE, incr[i++]==11&&incr[i++]==12&&incr[i++]==15&&incr[i++]==20&&incr[i++]==24&&incr[i++]==27&&incr[i++]==32&&incr[i++]==35&&incr[i++]==36&&incr[i++]==39&&incr[i++]==44&&incr[i++]==47&&incr[i++]==51&&incr[i++]==56&&incr[i++]==59&&incr[i++]==60, "factor.c : case 49"); break;	/* k mod 5 .ne. 3	*/
/*   p mod 12 == 7:	*/
		case 31:ASSERT(HERE, incr[i++]== 5&&incr[i++]== 8&&incr[i++]== 9&&incr[i++]==20&&incr[i++]==21&&incr[i++]==24&&incr[i++]==29&&incr[i++]==33&&incr[i++]==36&&incr[i++]==41&&incr[i++]==44&&incr[i++]==45&&incr[i++]==48&&incr[i++]==53&&incr[i++]==56&&incr[i++]==60, "factor.c : case 31"); break;	/* k mod 5 .ne. 2	*/
		case  7:ASSERT(HERE, incr[i++]== 5&&incr[i++]== 8&&incr[i++]== 9&&incr[i++]==12&&incr[i++]==17&&incr[i++]==20&&incr[i++]==24&&incr[i++]==29&&incr[i++]==32&&incr[i++]==33&&incr[i++]==44&&incr[i++]==45&&incr[i++]==48&&incr[i++]==53&&incr[i++]==57&&incr[i++]==60, "factor.c : case  7"); break;	/* k mod 5 .ne. 1	*/
		case 43:ASSERT(HERE, incr[i++]== 5&&incr[i++]== 8&&incr[i++]==12&&incr[i++]==17&&incr[i++]==20&&incr[i++]==21&&incr[i++]==32&&incr[i++]==33&&incr[i++]==36&&incr[i++]==41&&incr[i++]==45&&incr[i++]==48&&incr[i++]==53&&incr[i++]==56&&incr[i++]==57&&incr[i++]==60, "factor.c : case 43"); break;	/* k mod 5 .ne. 4	*/
		case 19:ASSERT(HERE, incr[i++]== 5&&incr[i++]== 9&&incr[i++]==12&&incr[i++]==17&&incr[i++]==20&&incr[i++]==21&&incr[i++]==24&&incr[i++]==29&&incr[i++]==32&&incr[i++]==36&&incr[i++]==41&&incr[i++]==44&&incr[i++]==45&&incr[i++]==56&&incr[i++]==57&&incr[i++]==60, "factor.c : case 19"); break;	/* k mod 5 .ne. 3	*/
/*   p mod 12 == 5:	*/
		case 41:ASSERT(HERE, incr[i++]== 3&&incr[i++]== 4&&incr[i++]==15&&incr[i++]==16&&incr[i++]==19&&incr[i++]==24&&incr[i++]==28&&incr[i++]==31&&incr[i++]==36&&incr[i++]==39&&incr[i++]==40&&incr[i++]==43&&incr[i++]==48&&incr[i++]==51&&incr[i++]==55&&incr[i++]==60, "factor.c : case 41"); break;	/* k mod 5 .ne. 2	*/
		case 17:ASSERT(HERE, incr[i++]== 3&&incr[i++]== 4&&incr[i++]== 7&&incr[i++]==12&&incr[i++]==15&&incr[i++]==19&&incr[i++]==24&&incr[i++]==27&&incr[i++]==28&&incr[i++]==39&&incr[i++]==40&&incr[i++]==43&&incr[i++]==48&&incr[i++]==52&&incr[i++]==55&&incr[i++]==60, "factor.c : case 17"); break;	/* k mod 5 .ne. 1	*/
		case 53:ASSERT(HERE, incr[i++]== 3&&incr[i++]== 7&&incr[i++]==12&&incr[i++]==15&&incr[i++]==16&&incr[i++]==27&&incr[i++]==28&&incr[i++]==31&&incr[i++]==36&&incr[i++]==40&&incr[i++]==43&&incr[i++]==48&&incr[i++]==51&&incr[i++]==52&&incr[i++]==55&&incr[i++]==60, "factor.c : case 53"); break;	/* k mod 5 .ne. 4	*/
		case 29:ASSERT(HERE, incr[i++]== 4&&incr[i++]== 7&&incr[i++]==12&&incr[i++]==15&&incr[i++]==16&&incr[i++]==19&&incr[i++]==24&&incr[i++]==27&&incr[i++]==31&&incr[i++]==36&&incr[i++]==39&&incr[i++]==40&&incr[i++]==51&&incr[i++]==52&&incr[i++]==55&&incr[i++]==60, "factor.c : case 29"); break;	/* k mod 5 .ne. 3	*/
/*   p mod 12 == 11:	*/
		case 11:ASSERT(HERE, incr[i++]== 1&&incr[i++]== 4&&incr[i++]== 9&&incr[i++]==13&&incr[i++]==16&&incr[i++]==21&&incr[i++]==24&&incr[i++]==25&&incr[i++]==28&&incr[i++]==33&&incr[i++]==36&&incr[i++]==40&&incr[i++]==45&&incr[i++]==48&&incr[i++]==49&&incr[i++]==60, "factor.c : case 11"); break;	/* k mod 5 .ne. 2	*/
		case 47:ASSERT(HERE, incr[i++]== 4&&incr[i++]== 9&&incr[i++]==12&&incr[i++]==13&&incr[i++]==24&&incr[i++]==25&&incr[i++]==28&&incr[i++]==33&&incr[i++]==37&&incr[i++]==40&&incr[i++]==45&&incr[i++]==48&&incr[i++]==49&&incr[i++]==52&&incr[i++]==57&&incr[i++]==60, "factor.c : case 47"); break;	/* k mod 5 .ne. 1	*/
		case 23:ASSERT(HERE, incr[i++]== 1&&incr[i++]==12&&incr[i++]==13&&incr[i++]==16&&incr[i++]==21&&incr[i++]==25&&incr[i++]==28&&incr[i++]==33&&incr[i++]==36&&incr[i++]==37&&incr[i++]==40&&incr[i++]==45&&incr[i++]==48&&incr[i++]==52&&incr[i++]==57&&incr[i++]==60, "factor.c : case 23"); break;	/* k mod 5 .ne. 4	*/
		case 59:ASSERT(HERE, incr[i++]== 1&&incr[i++]== 4&&incr[i++]== 9&&incr[i++]==12&&incr[i++]==16&&incr[i++]==21&&incr[i++]==24&&incr[i++]==25&&incr[i++]==36&&incr[i++]==37&&incr[i++]==40&&incr[i++]==45&&incr[i++]==49&&incr[i++]==52&&incr[i++]==57&&incr[i++]==60, "factor.c : case 59"); break;	/* k mod 5 .ne. 3	*/
		default:
			fprintf(stderr,"%u not an acceptable value for P mod 60. P likely nonprime.\n",pmod60); ASSERT(HERE, 0,"0");
	}

	clock2 = clock();	/* Assume sieve setup time < 2^32 cycles - even if that
							that is violated it's no big deal at this point. */
	/* Use td here, as tdiff is reserved for the total runtime from factoring start: */
	td = (double)(clock2 - clock1)/CLOCKS_PER_SEC;
	clock1 = clock2;

#ifdef FACTOR_STANDALONE
	if(!restart)
		printf	("Time to set up sieve =%2d%1d:%1d%1d:%1d%1d.%1d%1d%1d\n"
		,(int)td/36000,((int)td%36000)/3600
		,((int)td%3600)/600,((int)td%600)/60
		,((int)td%60)/10,(int)td%10
		,(int)(10*(td-(int)td)),(int)(100*(td-(int)td))%10,(int)(1000*(td-(int)td))%10
		);
#endif
	td = 0;	/* Use td to accumulate time spent on each individual factoring pass */

/* Run through each of the 16 "sievelets" as many times as necessary, each time copying
the appropriate q mod 8 and small-prime bit-cleared template into memory, clearing bits
corresponding to multiples of the larger tabulated primes, and trial-factoring any
candidate factors that survive sieving.	*/

#if(TRYQ > 0)
	q_index = -1;	/* Make this < 0 if factor queue is empty. */
#endif

	nfactor = 0;

#if FAC_DEBUG
	/* If a known factor given, only process the given k/log2 range for that pass: */
	if(pass_targ < 16)
		passmin = passnow = passmax = pass_targ;
#endif

	/* Init #Q-tried-so-far counter: */
	if(!count)
		count = 0;	/* This one may have a valid nonzero value as read from restartfile */

	/* Init global checksums: */
	if(!checksum1)
		checksum1 = 0;	/* May have a valid nonzero value as read from restartfile */

	if(!checksum2)
		checksum2 = 0;

	for(pass = passnow; pass <= passmax; pass++)
	{
	#ifdef FACTOR_STANDALONE
		if(!restart)
		{
			printf("pass = %d",pass);
			fflush(stdout);
		}
	#else
		ASSERT(HERE, fp == 0x0,"0");
		fp = fopen(STATFILE,"a");
		fprintf(fp,"Starting Trial-factoring Pass %2u...\n",pass);
		fclose(fp); fp = 0x0;
	#endif

		/* Starting no.-of-times-through-sieve = kmin/(64*len) : */
		if(pass == passnow && (know > kmin))
		{
			interval_lo = (know>>6)/(uint64)len;
			ASSERT(HERE, know == interval_lo *(len<<6),"know == interval_lo *(len<<6)");
		}
		else
		{
			interval_lo = (kmin>>6)/(uint64)len;
			ASSERT(HERE, kmin == interval_lo *(len<<6),"kmin == interval_lo *(len<<6)");
		}

		/* Set initial q for this pass: */
		/* Adjust initial k to default value (= incr[pass]) + interval_lo*(64*len),
		assume this could be as large as 64 bits: */
		ASSERT(HERE, (double)interval_lo*(len<<6) < TWO64FLOAT, "(double)interval_lo*len < TWO64FLOAT");

		k = (uint64)incr[pass] + interval_lo*(len<<6);

	#ifdef P1WORD
		/* k*(120*p): */
		q128=ONE128;
	  #ifdef MUL_LOHI64_SUBROUTINE
		MUL_LOHI64(two_p, k,&t128.d0,&t128.d1);
	  #else
		MUL_LOHI64(two_p, k, t128.d0, t128.d1);
	  #endif
		ADD128(q128, t128, q128);
		ASSERT(HERE, (q128.d1 >> 32) == 0,"(q128.d1 >> 32) == 0");	/* Make sure high part of product < 2^32... */
		ntimes_2pow64 = (uint32)q128.d1;	/* ...then store in 32-bit ntimes_2pow64 . */
		q = q2 = q128.d0;

	  #if FAC_DEBUG
		printf(" Initial q for this pass = %s.\n", &char_buf0[convert_uint128_base10_char(char_buf0, q128)]);
	  #endif

	#else
		/* k*(120*p): */
		ASSERT(HERE, 0 == mi64_mul_scalar(two_p,k,q,lenQ), "k*(120*p4word) overflows!");
		mi64_add_scalar(q,1ull,q,lenQ);	/* q = 2*p+1 */
	  #if FAC_DEBUG
		printf(" Initial q for this pass = %s.\n", &char_buf0[convert_mi64_base10_char(char_buf0, q, lenQ)]);
	  #endif

	#endif

		/* startbit k (occurrence of first multiple of prime curr_p in first pass
		through the relevant sievelet) is defined by

			(offset[curr_ p] + k*prime) (mod 60) = incr(pass)-1, k=0,59 .
		*/
		curr_p = p_last_small;
		for(m=nclear; m<nprime; m++)
		{
			curr_p += (pdiff[m] << 1);
			currp_mod_60 = curr_p%60;
	/********** TO DO: COULD DO A SEPARATE FIND-MULTIPLE OF nTH PRIME STEP FOR EACH PASS HERE, OBVIATING NEED FOR OFFSET[] ARRAY*****/
			l=offset[m];

			/* Special-handling code for p == curr_p case: */
			if(l == 0xffffffff)
			{
				startval[m] = 0xffffffff;
				continue;
			}

			lmod60 = l%60;

			for(i=0; i<=60; i++)
			{
				/*lmod60 = l%60;	// This system mod call is *really* slow, so replace it with the better sequence below: */

				if(lmod60 == incr[pass]-1)
				{
					l=l/60;
					goto SET_START;
				}
				l += curr_p;

				lmod60 += currp_mod_60 - 60;		/* Subtract off 60... */
				lmod60 += (-(lmod60 >> 31)) & 60;	/* ...and restore it if result was < 0. */
			}
			fprintf(stderr,"ERROR: failed to find a multiple of prime %u\n", curr_p);
			ASSERT(HERE, 0,"0");

		#if FAC_DEBUG
			if(l >= len)
				fprintf(stderr,"WARNING: first multiple of prime %u lies in bit %u, outside sievelet length %u\n", curr_p, l, len);
		#endif

		SET_START: startval[m] = l;

			/*
			Calculate and store increment of offset for each sieving prime < bit_len,
			used to quickly find what offset will be after another pass through sievelet.
			For each sieving prime curr_p, we hop through the bit_len bits of the
			sievelet in strides of curr_p, starting at bit = startval[curr_p].
			Letting k := ceil(bit_len/curr_p) (i.e. how many times we hit curr_p
			on a single pass through the sieve, rounded up), the change in offset
			due to a single pass through the sieve is

				d(startval) = k*curr_p - bit_len , which we note can also be written as
							= curr_p - (bitlen % curr_p).

			Example: bit_len = 100 (unrealistic number, but that's not important here)
					 curr_p = 17

			Then:	k = ceil(bit_len/curr_p) = ceil(5.88...) = 6,
			and
				d(startval) = k*curr_p - bit_len		 = 6*17 - 100 = 102 - 100 = 2 , or
							= curr_p - (bitlen % curr_p) = 17 - (100%17) = 17- 15 = 2 .

			(For primes > bitlen, (bitlen % curr_p) = bitlen, so the mod is superfluous.)

			Thus the offset at the beginning of the next pass through the sieve is

				startval' = (startval + d(startval))%curr_p .

			If we want to accomodate arbitrarily large kmin values for the start
			of our sieving runs, we need to calculate how many passes through the
			sieve the given kmin value corresponds to - that is stored in the
			interval_lo:

				interval_lo = floor(kmin/64.0/len) ,

			and thus the offset at the beginning of the initial pass through the sieve is

				startval' = (startval + interval_lo*d(startval)))%curr_p ,

			where we'll probably want to do a mod-curr_p of interval_lo prior to
			the multiply by (k*curr_p - bit_len) to keep intermediates < (curr_p)^2,
			which means < 2^64 is we allow curr_p as large as 32 bits.
			*/

			/* bit_len is a uint32, so use i (also a 32-bit) in place of k (64-bit) here: */
			i = ceil(1.0*bit_len/curr_p);
			ASSERT(HERE, i*curr_p - bit_len == curr_p - (bit_len % curr_p), "i*curr_p - bit_len == curr_p - (bit_len % curr_p)");

			/* Now calculate dstartval for the actual current-pass kmin value,
			according to the number of times we'd need to run through the sieve
			(starting with k = 0) to get to kmin: */
			dstartval = (uint64)(i*curr_p - bit_len);
			dstartval = (interval_lo*dstartval)%curr_p;
			dstartval += startval[m];
			if(dstartval >= curr_p)
				startval[m] = dstartval - curr_p;
			else
				startval[m] = dstartval;

		#if FAC_DEBUG
			ASSERT(HERE, startval     [m] < curr_p, "factor.c : startval     [m] < curr_p");
		  #if DBG_SIEVE
			startval_incr[m] = i*curr_p - bit_len;
			ASSERT(HERE, startval_incr[m] < curr_p, "factor.c : startval_incr[m] < curr_p");
		  #endif
		#endif

		}	/* endfor(m=nclear; m<nprime; m++) */

		for(sweep = interval_lo; sweep < interval_hi; ++sweep)
		{
			/*printf("sweep = %8d  qstart = %s, q_targ = %s\n", sweep, q, q_targ);*/
			if((sweep & 127) == 0)
			{
				/* Accumulate the cycle count every so often to avoid problems
				with integer overflow of the clock() result, if clock_t happens
				to be a 32-bit int type on the host platform: */
				clock2 = clock();
				td += (double)(clock2 - clock1);
				clock1 = clock2;

			#ifdef FACTOR_STANDALONE
				if(!restart)
				{
					printf(".");
					fflush(stdout);
				}
			#endif
			}

		/*********************************************/
		#if DBG_SIEVE
			if(k_targ)
			{
				/* Make sure we have a reference factor with which to debug the sieve: */
				ASSERT(HERE, STRNEQ(qstring, ""), "qstring empty!");

				/* See if k_targ falls in the range of k's for the current sieve interval: */
				k = (uint64)incr[pass] + sweep*(len<<6);	/* Starting k for the current interval: */

				/* If so, calculate the location of the critical bit
				and allow execution to proceed as normal to bit-clearing step:
				*/
				if((k <= k_targ) && (k_targ < (k+(len<<6))))
				{
					itmp64 = k_targ - k;
					ASSERT(HERE, itmp64%60 == 0,"(k_targ - k)%60 == 0");
					itmp64 /= 60;
					i64_targ = itmp64 >> 6;
					bit_targ = itmp64 & 63;
				}
				/* If debugging sieve & known factor will not occur in the current sieve interval,
				skip all of that bit-clearing nonsense and just increment the offset for each
				sieving prime to what it will be after another full pass through the sievelet:
				*/
				else
				{
					curr_p = p_last_small;
					for(m=nclear; m<nprime; m++)
					{
						curr_p += (pdiff[m] << 1);

						/* Special-handling code for p == curr_p case: */
						if(startval[m] == 0xffffffff)
						{
							continue;
						}

						/* Need to account for the fact that primes greater than the # of bits in the sieve
						may not hit *any* sieve bit on the current pass through the sieve:
						*/
						if(startval[m] >= bit_len)
						{
							startval[m] -= bit_len;
						}
						else
						{
							/* Compute new startvalue: */
							startval[m] += startval_incr[m] - curr_p;		/* Subtract off curr_p... */
							startval[m] += (-(startval_incr[m] >> 31)) & curr_p;	/* ...and restore it if result was < 0. */
						}
					}

					/* Increment q by bit_len*p120: */
				#ifdef P1WORD
					q128.d0 = q; q128.d1 = ntimes_2pow64;
					/* bit_len*p120 may be > 64 bits in length: */
				  #ifdef MUL_LOHI64_SUBROUTINE
					MUL_LOHI64(p120, (uint64)bit_len,&t128.d0,&t128.d1);
				  #else
					MUL_LOHI64(p120, (uint64)bit_len, t128.d0, t128.d1);
				  #endif
					ADD128(q128, t128, q128);
					q = q128.d0; ntimes_2pow64 = q128.d1;
				#else
					mi64_setlen(u64_arr, lenP, lenQ);
					u64_arr[lenP] = mi64_mul_scalar(p120, (uint64)bit_len, u64_arr, lenP);
					ASSERT(HERE, mi64_add(q, u64_arr, q, lenQ) == 0, "q + bit_len*p120 overflows!");
				#endif

					/* If reference factor not in current k-range, skip the TFing... */
					goto QUIT;
				}
			}
		#endif
		/*********************************************/

			/*   load the sievelet...	*/
			for(i=0; i<=len/60; i++)
			{
				/*bitmap[i] = template[i][pass];	// Use memcpy here? */
				bitmap[i] = *(template+(i<<4)+pass);	/* Use memcpy here? */
			}

		#if DBG_SIEVE
			/* If debugging sieve, make sure critical bit hasn't been cleared: */
			if( k_targ && (((bitmap[i64_targ] >> bit_targ) & 1) == 0) )
			{
				fprintf(stderr,"Critical bit cleared in original bitmap!\n");
				ASSERT(HERE, 0,"0");
			}
		#endif
			/*   ...and clear the bits corresponding to the small primes.	*/
			curr_p = p_last_small;
			for(m=nclear; m<nprime; m++)
			{
				curr_p += (pdiff[m] << 1);
				/*
				if(current_prime == 107) printf("   prime %8d has offset = %8d\n", curr_p, startval[m]);
		`		*/

				l = startval[m];

				/* Special-handling code for p == curr_p case: */
				if(l == 0xffffffff)
				{
					continue;
				}

				/* Need to account for the fact that primes greater than the # of bits in the sieve
				may not hit *any* sieve bit on the current pass through the sieve:
				*/
				if(l >= bit_len)
				{
					startval[m] -= bit_len;
				}
				else
				{
					while(l < bit_len)
					{
						i64=l >> 6;	/* l/64	*/
						bit=l & 63;	/* l%64	*/
					#if DBG_SIEVE
						if(k_targ && (i64 == i64_targ && bit == bit_targ))
						{
							fprintf(stderr,"Critical bit being cleared by prime %u, with offset %u\n", curr_p, startval[m]);
							ASSERT(HERE, 0,"0");
						}
					#endif
						mask = ~((uint64)1 << bit);
						bitmap[i64] &= mask;

						l += curr_p;
					}
					/*...save new startvalue:	*/
				#if DBG_SIEVE
					ASSERT(HERE, (startval[m] + startval_incr[m]) < (curr_p + curr_p), "factor.c : (startval[m] + startval_incr[m]) < (curr_p + curr_p)");
					ASSERT(HERE, l-bit_len == (startval[m] + startval_incr[m])%curr_p, "factor.c : l-bit_len == (startval[m] + startval_incr[m])%curr_p");
				#endif
					startval[m] = l-bit_len;
				}
			}

			/*...now run through the bits of the current copy of the sieve,
			trial dividing if a bit = 1.
			*/
			ihi = ((bit_len+63)>>6);
			bit_hi = 64;
			for(i=0; i < ihi; i++)	/* K loops over 64-bit registers. Don't assume bit_len a multiple of 64.	*/
			{
				/* Special casing for last template word, which may be only partly full */
				if((bit_len - (i<<6)) < 64)
					bit_hi = (bit_len - (i<<6));

				for(bit=0; bit < bit_hi; bit++)		/* BIT loops over bits in each template word...	*/
				{
				#if(FAC_DEBUG)
					/* If a known factor is specified, here it is in the bitmap: */
				  #ifdef P1WORD
					if(i == 0 && bit==0)
					{
						q2 = 1 + two_p*(incr[pass] + 60*((uint64)sweep*bit_len + (i<<6) + bit));
						if(q != q2)
						{
							fprintf(stderr,"Sweep %u : mismatch: q1 = %s, q2 = %s, (q2-q1)/(120*p) = %s\n", sweep, &char_buf0[convert_uint64_base10_char(char_buf0, q)], &char_buf1[convert_uint64_base10_char(char_buf1, q2)], &char_buf2[convert_uint64_base10_char(char_buf2, (q2-q)/p120)]);
							ASSERT(HERE, 0,"0");
						}
					}

					ASSERT(HERE, ntimes_2pow64 == 0, "q > 2^64");
					if(q == q_targ)
				  #else
					if(mi64_cmpeq(q, q_targ, lenQ))
				  #endif
					{
						printf("here it is: sweep = %s, bitmap word = %u, bit = %3u\n", &char_buf0[convert_uint64_base10_char(char_buf0, sweep)], i, bit);

						if((bitmap[i] >> bit) & 1)
							printf("Trying q_targ = %s...\n", qstring);
						else
							ASSERT(HERE, 0,"0");
					}
				#endif

				/*...If current sieve bit=1, add q to trial-division queue: */

					if((bitmap[i] >> bit) & 1)
					{
					#if 0	/* Set nonzero to print each factor candidate tried */
						printf("Trying q = %s...\n", q);
					#endif

					/* Increment q-based checksum: */
					#if(defined(P1WORD))
						checksum1 += q;
					#else
						checksum1 += q[0];
					#endif

						q_index = count++ & TRYQM1;	/* Post-increment count, so this will work. */

						/* Every so often (every [2^32 / (nearest power of 2 to lenP*lenQ^2)] q's seems a good interval)
						do some factor-candidate sanity checks.

						***NOTE: *** The (count & ...) here must be with a constant = 2^n-1, n >= 3,
						so that the if() is TRUE only if count is a MULTIPLE OF 8
						(i.e. of the largest permissible value of TRYQ). This is so that
						checksum2, which is updated every 8 q's, will be the same
						irrespective whether TRYQ = 1,2,4 or 8.
						*/
						if((count & countmask) == 0)
						{
							fp = fopen(OFILE,"a");

						#if(FAC_DEBUG)
							#if(defined(P1WORD))
								 q128.d0 = q; q128.d1 = ntimes_2pow64;	/* 128-bit version of q */
								 sprintf(cbuf, " Count = %s: Current q = %s, checksum1 = %s\n", &char_buf0[convert_uint64_base10_char (char_buf0, count)], &char_buf1[convert_uint128_base10_char(char_buf1, q128)], &char_buf2[convert_uint64_base16_char (char_buf2, checksum1)]);
							#else
								 sprintf(cbuf, " Count = %s: Current q = %s, checksum1 = %s\n", &char_buf0[convert_uint64_base10_char (char_buf0, count)], &char_buf1[convert_mi64_base10_char(char_buf1, q, lenQ)], &char_buf2[convert_uint64_base16_char (char_buf2, checksum1)]);
							#endif

							if(!restart)
							{
								fprintf(stderr, "%s", cbuf);
							}
							fprintf(fp, "%s", cbuf);
						#endif

							/* Do some sanity checks on the occasional factor candidate to ensure
							that the sieve is functioning properly and no overflows have occurred.
							*/
							/* Make sure that q == 1 (mod 2p) and that q is a base-2 PRP: */
						#if(defined(P1WORD))

							q128.d0 = q; q128.d1 = ntimes_2pow64;	/* 128-bit version of q */
							t128.d0 = p; t128.d1 = 0;	/* 128-bit version of p */
							ADD128(t128, t128, t128);	/* (2*p) */
							x128 = xmody128(q128, t128);
							if(!CMPEQ128(x128, ONE128))
							{
								t128.d0 = p; t128.d1 = 0;	/* 128-bit version of p */
								fprintf(fp    ,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",&char_buf0[convert_uint128_base10_char(char_buf0, t128)], &char_buf1[convert_uint128_base10_char(char_buf1, q128)], &char_buf2[convert_uint128_base10_char(char_buf2, x128)]);	fclose(fp); fp = 0x0;
								fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",&char_buf0[convert_uint128_base10_char(char_buf0, t128)], &char_buf1[convert_uint128_base10_char(char_buf1, q128)], &char_buf2[convert_uint128_base10_char(char_buf2, x128)]);
								ASSERT(HERE, 0,"0");
							}

							SUB128(q128, ONE128, t128);	/* q-1 */
							t128 = twopmodq128x2((uint64 *)&t128, q128);
							if(!CMPEQ128(ONE128, t128))
						#else

							mi64_clear(u64_arr, lenQ);
							mi64_div(q,two_p,q2,u64_arr,lenQ);
							ASSERT(HERE, mi64_getlen(q2, lenQ) == 1 , "k must be 64-bit!");
							if(!mi64_cmpeq_scalar(u64_arr, 1ull, lenQ))
							{
								fprintf(fp    ,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",&char_buf0[convert_mi64_base10_char(char_buf0,p,lenP)], &char_buf1[convert_mi64_base10_char(char_buf1, q, lenQ)], &char_buf2[convert_mi64_base10_char(char_buf2, u64_arr, lenQ)]);	fclose(fp); fp = 0x0;
								fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",&char_buf0[convert_mi64_base10_char(char_buf0,p,lenP)], &char_buf1[convert_mi64_base10_char(char_buf1, q, lenQ)], &char_buf2[convert_mi64_base10_char(char_buf2, u64_arr, lenQ)]);
//								ASSERT(HERE, 0,"0");
							}

							if(mi64_twopmodq(q2, lenQ, q, lenQ, 0x0) != 1)
						#endif

							/* If q is composite [only check this in debug mode since it costs just as much as checking
							divisibility of 2^p-1 by q], make sure its smallest divisor
							is larger than the max sieving prime being used for the run: */
							{
							#if(FAC_DEBUG)
								if(!restart)
								{
								 printf(   " INFO: This q is composite\n");
							 	}
								fprintf(fp," INFO: This q is composite\n");
							#endif

								l = 3;
								idx = 0;
								for(m=0; m < nprime; m++)
								{
									/* Is q%(current small sieving prime) == 0? */
								#if(defined(P1WORD))
									if(x128_mod_y32(q128, l) == 0)
								#else
									if(mi64_div_y32(q, l, 0x0, lenQ) == 0)
								#endif
									{
										fprintf(stderr,"ERROR: current q has a small divisor: %u\n", l);
										fprintf(fp    ,"ERROR: current q has a small divisor: %u\n", l);
									#if(defined(P1WORD))
										fprintf(stderr," q = %s\n", &char_buf0[convert_uint128_base10_char (char_buf0, q128)]);
										fprintf(fp    ," q = %s\n", &char_buf0[convert_uint128_base10_char (char_buf0, q128)]);
									#else
										fprintf(stderr," q = %s\n", &char_buf0[convert_mi64_base10_char(char_buf0, q, lenQ)]);
										fprintf(fp    ," q = %s\n", &char_buf0[convert_mi64_base10_char(char_buf0, q, lenQ)]);
									#endif
										fclose(fp); fp = 0x0;
									//	ASSERT(HERE, 0,"0");
									}
									l += (pdiff[++idx] << 1);
								}
							}
							fclose(fp); fp = 0x0;

							/* Reset q-based checksum: */
							checksum1 = 0;
							checksum2 = 0;

						}	/* endif((count & countmask) == 0) */

					#if(TRYQ == 0)	/* If testing speed of sieve alone, skip to incrementing of q. */

					#else

					#ifndef NWORD
						q_to_try[q_index] = q;
					#endif

						if(q_index == TRYQM1)
						{
							q_index = -1;	/* q_index = -1 indicates factor queue empty.
											(more precisely, it will be, after we test the
											current batch of candidate q's. */

						#if(TRYQ == 1)	/* try 1 factor candidate at a time */

						  #if(defined(NWORD))

							res = (mi64_twopmodq(p, lenP, q, lenQ, u64_arr) == 1);
							checksum2 += u64_arr[0];

						  #elif(defined(P4WORD))

							t256 = twopmodq256(p,q_to_try[0]);
							res = CMPEQ256(t256, ONE256);

						  #elif(defined(P3WORD))

							t192 = twopmodq192(p,q_to_try[0]);
							res = CMPEQ192(t192, ONE192);

						  #elif(defined(P2WORD))

						   #if(  defined(USE_128x96) && USE_128x96 == 1)
							/* Use strictly  96-bit routines: */
							if(p.d1 == 0 && (q.d1 >> 32) == 0)
								t128 = twopmodq96	(p, q);
							else
						   #elif(defined(USE_128x96) && USE_128x96 == 2)
							/* Use hybrid 128_96-bit routines: */
							if(p.d1 == 0 && (q.d1 >> 32) == 0)
								t128 = twopmodq128_96(p, q);
							else
						   #endif
							/* Use fully 128-bit routines: */
								t128 = twopmodq128x2(p, q);

							res = CMPEQ128(t128, ONE128);

						  #else

							#ifdef USE_FMADD
								/* Use 50x50-bit FMADD-based modmul routines, if def'd: */
								q128.d0 = q;	q128.d1 = ntimes_2pow64;
								res = twopmodq100_2WORD_DOUBLE(p, q128);
							#elif(defined(USE_FLOAT))
								/* Otherwise use 78-bit floating-double-based modmul: */
								q128.d0 = q;	q128.d1 = ntimes_2pow64;
								res = twopmodq78_3WORD_DOUBLE(p,q128);
							#else
								/* Otherwise use pure-integer-based modmul: */
								if(ntimes_2pow64 == 0)
								{
									if(( int64)q > 0)
										res = twopmodq63(p,q);
									else
										res = twopmodq64(p,q);
								}
							  #if(defined(USE_65BIT))
								else if(ntimes_2pow64 == 1)
								{
									res = twopmodq65(p,q);
								}
							  #endif
								else
								{
									q128.d0 = q;	q128.d1 = ntimes_2pow64;
								  #if(  defined(USE_128x96) && USE_128x96 == 1)
									/* Use strictly  96-bit routines: */
									t128 = twopmodq96	(p, q128);
								  #elif(defined(USE_128x96) && USE_128x96 == 2)
									/* Use hybrid 128_96-bit routines: */
									t128 = twopmodq128_96(p, q128);
								  #else
									/* Use fully 128-bit routines: */
									t128 = twopmodq128	(p, q128);
								  #endif
								}
							#endif	/* #ifdef USE_FMADD */
						  #endif	/* #if(defined(P3WORD)) */

						#elif(TRYQ == 2)	/* try 2 factor candidates at a time */

							#ifdef USE_FMADD
								/* Use 50x50-bit FMADD-based modmul routines, if def'd: */
								q128_0.d1 = ntimes_2pow64;	q128_0.d0 = q_to_try[0];
								q128_1.d1 = ntimes_2pow64;	q128_1.d0 = q_to_try[1];
								res = twopmodq100_2WORD_DOUBLE_q2(p,q128_0,q128_1);
							#elif(defined(USE_FLOAT))
								/* Otherwise use 78-bit floating-double-based modmul: */
								q128_0.d1 = ntimes_2pow64;	q128_0.d0 = q_to_try[0];
								q128_1.d1 = ntimes_2pow64;	q128_1.d0 = q_to_try[1];
								res = twopmodq78_3WORD_DOUBLE_q2(p,q128_0,q128_1);
							#else
								#error	TRYQ = 2 only allowed if USE_FLOAT or USE_FMADD is defined!
							#endif	/* #ifdef USE_FMADD */

						#elif(TRYQ == 4)	/* try 4 factor candidates at a time */

						  #if(defined(P3WORD))

							res = twopmodq192_q4(p,q_to_try[0],q_to_try[1],q_to_try[2],q_to_try[3]);

						  #elif(defined(P2WORD))

							/* Itanium seems to perform poorly with 96-bit variant: */
						   #if(  defined(USE_128x96) && USE_128x96 == 1)
							/* Use strictly  96-bit routines: */
							if(p.d1 == 0 && (q.d1 >> 32) == 0)
								res = twopmodq96_q4     (p.d0,q_to_try[0],q_to_try[1],q_to_try[2],q_to_try[3]);
							else
						   #elif(defined(USE_128x96) && USE_128x96 == 2)
							/* Use hybrid 128_96-bit routines: */
							if(p.d1 == 0 && (q.d1 >> 32) == 0)
								res = twopmodq128_96_q4 (p.d0,q_to_try[0],q_to_try[1],q_to_try[2],q_to_try[3]);
							else
						   #endif
							/* Use fully 128-bit routines: */
								res = twopmodq128_q4    (p   ,q_to_try[0],q_to_try[1],q_to_try[2],q_to_try[3]);

						  #else

							#ifdef USE_FMADD
								/* Use 50x50-bit FMADD-based modmul routines, if def'd: */
								q128_0.d1 = ntimes_2pow64;	q128_0.d0 = q_to_try[0];
								q128_1.d1 = ntimes_2pow64;	q128_1.d0 = q_to_try[1];
								q128_2.d1 = ntimes_2pow64;	q128_2.d0 = q_to_try[2];
								q128_3.d1 = ntimes_2pow64;	q128_3.d0 = q_to_try[3];
								res = twopmodq100_2WORD_DOUBLE_q4(p,q128_0,q128_1,q128_2,q128_3);
							#elif(defined(USE_FLOAT))
								/* Otherwise use 78-bit floating-double-based modmul: */
								q128_0.d1 = ntimes_2pow64;	q128_0.d0 = q_to_try[0];
								q128_1.d1 = ntimes_2pow64;	q128_1.d0 = q_to_try[1];
								q128_2.d1 = ntimes_2pow64;	q128_2.d0 = q_to_try[2];
								q128_3.d1 = ntimes_2pow64;	q128_3.d0 = q_to_try[3];
								res = twopmodq78_3WORD_DOUBLE_q4(p,q128_0,q128_1,q128_2,q128_3);
							#else
								/* ntimes_2pow64 is calculated for largest q of current
								set, so if that > 2^64, use 96-bit routines for all q's. */
								if(ntimes_2pow64 == 0)
								{
									if(( int64)q > 0)
										res = twopmodq63_q4(p,q_to_try[0],q_to_try[1],q_to_try[2],q_to_try[3]);
									else
										res = twopmodq64_q4(p,q_to_try[0],q_to_try[1],q_to_try[2],q_to_try[3]);
								}
							  #if(defined(USE_65BIT))
								else if(ntimes_2pow64 == 1)
								{
									res = twopmodq65_q4(p,q_to_try[0],q_to_try[1],q_to_try[2],q_to_try[3]);
								}
							  #endif
								else
								{
									q128_0.d1 = ntimes_2pow64;	q128_0.d0 = q_to_try[0];
									q128_1.d1 = ntimes_2pow64;	q128_1.d0 = q_to_try[1];
									q128_2.d1 = ntimes_2pow64;	q128_2.d0 = q_to_try[2];
									q128_3.d1 = ntimes_2pow64;	q128_3.d0 = q_to_try[3];
								#if(defined(USE_128x96) && USE_128x96 == 1)
									/* Use strictly  96-bit routines: */
									res = twopmodq96_q4		(   p,q128_0,q128_1,q128_2,q128_3);
								#elif(!defined(USE_128x96) || USE_128x96 == 2)
									/* Use hybrid 128_96-bit routines: */
									res = twopmodq128_96_q4	(   p,q128_0,q128_1,q128_2,q128_3);
								#else
									/* Use fully 128-bit routines: */
									p128.d0 = p; p128.d1 = 0;
									res = twopmodq128_q4	(p128,q128_0,q128_1,q128_2,q128_3);
								#endif
								}
							#endif	/* #ifdef USE_FLOAT */
						  #endif	/* #if(defined(P3WORD)) */

						#elif(TRYQ == 8)	/* try 8 factor candidates at a time */

						  #if(defined(P3WORD))
						/*
							if((q.d2 >> 32) == 0)
								res = twopmodq160_q8(p,q_to_try[0],q_to_try[1],q_to_try[2],q_to_try[3],q_to_try[4],q_to_try[5],q_to_try[6],q_to_try[7]);
							else
						*/
								res = twopmodq192_q8(p,q_to_try[0],q_to_try[1],q_to_try[2],q_to_try[3],q_to_try[4],q_to_try[5],q_to_try[6],q_to_try[7]);

						  #elif(defined(P2WORD))

							/* Itanium seems to perform poorly with 96-bit variant: */
						   #if(  defined(USE_128x96) && USE_128x96 == 1)
							/* Use strictly  96-bit routines: */
							if(p.d1 == 0 && (q.d1 >> 32) == 0)
								res = twopmodq96_q8     (p.d0,q_to_try[0],q_to_try[1],q_to_try[2],q_to_try[3],q_to_try[4],q_to_try[5],q_to_try[6],q_to_try[7]);
							else
						   #elif(defined(USE_128x96) && USE_128x96 == 2)
							/* Use hybrid 128_96-bit routines: */
							if(p.d1 == 0 && (q.d1 >> 32) == 0)
								res = twopmodq128_96_q8 (p.d0,q_to_try[0],q_to_try[1],q_to_try[2],q_to_try[3],q_to_try[4],q_to_try[5],q_to_try[6],q_to_try[7]);
							else
						   #endif
							/* Use fully 128-bit routines: */
								res = twopmodq128_q8    (p   ,q_to_try[0],q_to_try[1],q_to_try[2],q_to_try[3],q_to_try[4],q_to_try[5],q_to_try[6],q_to_try[7]);

						  #else

							/* ntimes_2pow64 is calculated for largest q of current
							set, so if that > 2^64, use 96-bit routines for all q's. */
							if(ntimes_2pow64 == 0)
							{
								if(( int64)q > 0)
									res = twopmodq63_q8(p,q_to_try[0],q_to_try[1],q_to_try[2],q_to_try[3],q_to_try[4],q_to_try[5],q_to_try[6],q_to_try[7]);
								else
									res = twopmodq64_q8(p,q_to_try[0],q_to_try[1],q_to_try[2],q_to_try[3],q_to_try[4],q_to_try[5],q_to_try[6],q_to_try[7]);
							}
						   #if(defined(USE_65BIT))
							else if(ntimes_2pow64 == 1)
							{
								res = twopmodq65_q8(p,q_to_try[0],q_to_try[1],q_to_try[2],q_to_try[3],q_to_try[4],q_to_try[5],q_to_try[6],q_to_try[7]);
							}
						   #endif
							else
							{
								q128_0.d1 = ntimes_2pow64;	q128_0.d0 = q_to_try[0];
								q128_1.d1 = ntimes_2pow64;	q128_1.d0 = q_to_try[1];
								q128_2.d1 = ntimes_2pow64;	q128_2.d0 = q_to_try[2];
								q128_3.d1 = ntimes_2pow64;	q128_3.d0 = q_to_try[3];
								q128_4.d1 = ntimes_2pow64;	q128_4.d0 = q_to_try[4];
								q128_5.d1 = ntimes_2pow64;	q128_5.d0 = q_to_try[5];
								q128_6.d1 = ntimes_2pow64;	q128_6.d0 = q_to_try[6];
								q128_7.d1 = ntimes_2pow64;	q128_7.d0 = q_to_try[7];
							#if(defined(USE_128x96) && USE_128x96 == 1)
								/* Use strictly  96-bit routines: */
								res = twopmodq96_q8		(   p,q128_0,q128_1,q128_2,q128_3,q128_4,q128_5,q128_6,q128_7);
							#elif(!defined(USE_128x96) || USE_128x96 == 2)
								/* Use hybrid 128_96-bit routines: */
								res = twopmodq128_96_q8	(   p,q128_0,q128_1,q128_2,q128_3,q128_4,q128_5,q128_6,q128_7);
							#else
								/* Use fully 128-bit routines: */
								p128.d0 = p; p128.d1 = 0;
								res = twopmodq128_q8	(p128,q128_0,q128_1,q128_2,q128_3,q128_4,q128_5,q128_6,q128_7);
							#endif
							}

						  #endif	/* #if(defined(P3WORD)) */

						#endif	/* endif(TRYQ == 1,4,8) */

							/* Print any factors that were found in the current batch: */

							for(l = 0; l < TRYQ; l++)
							{
								if((res >> l) & 1)	/* If Lth bit = 1, Lth candidate of the inputs is a factor */
								{
								#ifdef P1WORD
									q2 = q_to_try[l];
								#elif(defined(NWORD))
									mi64_set_eq(u64_arr, q, lenQ);
								#else	/* 2-4 word q's: */
									q2 = q_to_try[l];
									mi64_set_eq(u64_arr, &q2, lenQ);
								#endif

									/* Do a quick base-3 compositeness check (base-2 would be much faster due to
									our fast Montgomery arithmetic-based powering for that, but it's useless for
									weeding out composite Mersenne factors since those are all base-2 Fermat pseudoprimes).
									If it's composite we skip it, since we expect to recover the individual prime subfactors
									on subsequent passes (although this should only ever happen for small p and q > (2p+1)^2 :
									*/
								#ifdef P1WORD

									p128.d1 = 0; p128.d0 = p;
									q128.d1 = (uint64)ntimes_2pow64;	q128.d0 = q2;

									if(mi64_pprimeF((uint64 *)&q128, 3ull, 2))
									{
										/* Recover the factor k - use t128 for quotient and x128 for remainder, which we expect == 1: */
										u64_arr[0] = two_p;	u64_arr[1] = 0ull;
										mi64_div((uint64 *)&q128,u64_arr,(uint64 *)&t128,(uint64 *)&x128,lenQ);
										ASSERT(HERE, mi64_cmpeq_scalar((uint64 *)&x128, 1ull, lenQ), "q != 1 mod p");
										ASSERT(HERE, mi64_getlen      ((uint64 *)&t128, lenQ) == 1 , "k must be 64-bit!");
										factor_k[nfactor] = t128.d0;

								#else	/* Use 128-bit modmul routines for factors < 96 bits: */

									if(mi64_pprimeF(u64_arr, 3ull, lenQ))
									{
										/* Recover the factor k - use q2 for quotient and u64_arr for remainder, which we expect == 1: */
									#if(defined(NWORD))
										mi64_div(q,two_p,q2,u64_arr,lenQ);
									#else	/* 2-4 word q's: */
										mi64_div(&(q_to_try[l]),two_p,q2,u64_arr,lenQ);
									#endif
										ASSERT(HERE, mi64_cmpeq_scalar(u64_arr, 1ull, lenQ), "q != 1 mod p");
										ASSERT(HERE, mi64_getlen(q2, lenQ) == 1 , "k must be 64-bit!");
										factor_k[nfactor] = q2[0];

								#endif	/* endif(PxWORD) */

										sprintf(char_buf0,"\n\tFactor with k = %s. Program: E%s\n", &char_buf1[convert_uint64_base10_char(char_buf1, factor_k[nfactor++])], VERSION);
									#ifdef FACTOR_STANDALONE
									  if(!restart)
										fprintf(stderr,"%s", char_buf0);
									#else
										ASSERT(HERE, fp == 0x0,"0");
										fp = fopen(STATFILE,"a");
										fprintf(fp,"%s", char_buf0);
										fclose(fp); fp = 0x0;
									#endif

										fp = fopen(   OFILE,"a");
										fprintf(fp,"%s", char_buf0);
										fclose(fp); fp = 0x0;

									#if FAC_DEBUG
										if(TRYQM1 > 1)
											printf("factor was number %u of 0-%u in current batch.\n", l, TRYQM1);
									#endif

									#ifdef QUIT_WHEN_FACTOR_FOUND
										return 0;
									#endif
									}	/* endif(factor a probable prime?) */
								}	/* endif((res >> l) & 1)		*/
							}	/* endfor(l = 0; l < TRYQ; l++)	*/
						}	/* endif(q_index == TRYQM1)		*/

					#endif	/* endif(TRYQ == 0) */

					}	/* endif((bitmap[i] >> bit) & 1)	*/

				/* Increment q by p120. The MAX_BITS_Q limits are set so that this
				can only overflow out of the high word of q in the 64-bit case,
				in which case the overflow is handled by incrementing ntimes_2pow64:
				*/
				#ifdef P1WORD

					q = q + p120;
					ntimes_2pow64 += (q < p120);

				#else

					mi64_add(q, p120, q, lenQ);

				#endif	/* endif(P3WORD) */

				} /* end of BIT loop	*/
			}	/* end of K loop	*/

			/* Clean up any remaining in queue */
		#if(TRYQ > 1)
			if(q_index >= 0)
			{
				for(l = 0; l <= (uint32)q_index; l++)
				{
					q2 = q_to_try[l];

				#if(defined(P4WORD))

					t256 = twopmodq256(p,q2);
					res = CMPEQ256(ONE256, t256);
					/*printf("A: Trying q = %s\n", &char_buf0[convert_uint256_base10_char(char_buf0, q2)]);*/

				#elif(defined(P3WORD))

					t192 = twopmodq192(p,q2);
					res = CMPEQ192(ONE192, t192);
					/*printf("A: Trying q = %s\n", &char_buf0[convert_uint192_base10_char(char_buf0, q2)]);*/

				#elif(defined(P2WORD))

					t128 = twopmodq128x2(p,q2);
					res = CMPEQ128(ONE128, t128);
					/*printf("A: Trying q = %s\n", &char_buf0[convert_uint128_base10_char(char_buf0, q2)]);*/

				#else

					/*printf("A: Trying q = %s\n", &char_buf0[convert_uint64_base10_char(char_buf0, q2)]);*/
					if(ntimes_2pow64 == 0)
					{
						if(( int64)q2 > 0)
							res = twopmodq63(p,q2);
						else
							res = twopmodq64(p,q2);
					}
					else
					{
						q128.d0 = q2;	q128.d1 = ntimes_2pow64;
						t128 = twopmodq128_96(p,q128);
						res = CMPEQ128(ONE128, t128);
					}

				#endif	/* endif(P3WORD) */

					if(res == 1)	/* If Lth bit = 1, Lth candidate of the inputs is a factor */
					{
						/* Check if it's a composite factor - if so, skip: */
					#if(defined(P4WORD))

						p256 = p;
						q256 = q2;
						if(mi64_pprimeF(&q256, 3ull, 4))
						{
							sprintf(char_buf0,"Factor with k = %s. Program: E%s\n", &char_buf1[convert_uint256_base10_char(char_buf1, p256)], &char_buf2[convert_uint256_base10_char(char_buf2, q256)], VERSION);
						#ifdef FACTOR_STANDALONE
						  if(!restart)
							fprintf(std_err,"%s", char_buf0);
						#else
							ASSERT(HERE, fp == 0x0,"0");
							fp = fopen(STATFILE,"a");
							fprintf(fp,,"%s", char_buf0);
							fclose(fp); fp = 0x0;
						#endif

							fp = fopen(   OFILE,"a");
							fprintf(fp,,"%s", char_buf0);
							fclose(fp); fp = 0x0;

						#if FAC_DEBUG
							printf("factor was number %u of 0-%u in current batch.\n", l, TRYQM1);
						#endif

							/* Recover the factor k - use t256 for quotient and x256 for remainder, which we expect == 1: */
							mi64_div(&q256,&two_p,&t256,&x256,4);
							ASSERT(HERE, mi64_cmpeq_scalar(&x256, 1ull, 4), "q != 1 mod p";
							ASSERT(HERE, mi64_getlen      (&t256, 4) == 1 , "k must be 64-bit!");
							factor_k[nfactor++] = t256.d0;

						#ifdef QUIT_WHEN_FACTOR_FOUND
							return 0;
						#endif
						}
						else	/* Add an 'else' here by way of a convenient place to set a debugger breakpoint */
						{
							printf("");
						}
						/* endif(factor a probable prime?) */

					#elif(defined(P3WORD))

						p192 = p;
						q192 = q2;
						if(mi64_pprimeF(&q192, 3ull, 3))
						{
							sprintf(char_buf0,"Factor with k = %s. Program: E%s\n", &char_buf1[convert_uint192_base10_char(char_buf1, p192)], &char_buf2[convert_uint192_base10_char(char_buf2, q192)], VERSION);
						#ifdef FACTOR_STANDALONE
						  if(!restart)
							fprintf(std_err,"%s", char_buf0);
						#else
							ASSERT(HERE, fp == 0x0,"0");
							fp = fopen(STATFILE,"a");
							fprintf(fp,,"%s", char_buf0);
							fclose(fp); fp = 0x0;
						#endif

							fp = fopen(   OFILE,"a");
							fprintf(fp,,"%s", char_buf0);
							fclose(fp); fp = 0x0;

						#if FAC_DEBUG
							printf("factor was number %u of 0-%u in current batch.\n", l, TRYQM1);
						#endif

							/* Recover the factor k - use t192 for quotient and x192 for remainder, which we expect == 1: */
							mi64_div(&q192,&two_p,&t192,&x192,3);
							ASSERT(HERE, mi64_cmpeq_scalar(&x192, 1ull, 3), "q != 1 mod p";
							ASSERT(HERE, mi64_getlen      (&t192, 3) == 1 , "k must be 64-bit!");
							factor_k[nfactor++] = t192.d0;

						#ifdef QUIT_WHEN_FACTOR_FOUND
							return 0;
						#endif
						}
						else	/* Add an 'else' here by way of a convenient place to set a debugger breakpoint */
						{
							printf("");
						}
						/* endif(factor a probable prime?) */

					#else	/* Use 128-bit modmul routines for both 96 and 128-bit here */

					  #if(defined(P2WORD))
						p128 = p;
						q128 = q2;
					  #else
						p128.d1 = 0; p128.d0 = p;
						q128.d1 = (uint64)ntimes_2pow64;	q128.d0 = q2;
					  #endif

						if(mi64_pprimeF((uint64 *)&q128, 3ull, 2))
						{
							sprintf(char_buf0,"M%s has a factor : %s. Program: E%s\n", &char_buf1[convert_uint128_base10_char(char_buf1, p128)], &char_buf2[convert_uint128_base10_char(char_buf2, q128)], VERSION);
						#ifdef FACTOR_STANDALONE
						  if(!restart)
							fprintf(stderr,"%s", char_buf0);
						#else
							ASSERT(HERE, fp == 0x0,"0");
							fp = fopen(STATFILE,"a");
							fprintf(fp,"%s", char_buf0);
							fclose(fp); fp = 0x0;
						#endif

							fp = fopen(   OFILE,"a");
							fprintf(fp,"%s", char_buf0);
							fclose(fp); fp = 0x0;

						#if FAC_DEBUG
							printf("factor was number %u of 0-%u in current batch.\n", l, TRYQM1);
						#endif

							/* Recover the factor k - use t128 for quotient and x128 for remainder, which we expect == 1: */
							mi64_div((uint64 *)&q128,&two_p,(uint64 *)&t128,(uint64 *)&x128,2);
							ASSERT(HERE, mi64_cmpeq_scalar((uint64 *)&x128, 1ull, 2), "q != 1 mod p");
							ASSERT(HERE, mi64_getlen      ((uint64 *)&t128, 2) == 1 , "k must be 64-bit!");
							factor_k[nfactor++] = t128.d0;

						#ifdef QUIT_WHEN_FACTOR_FOUND
							return 0;
						#endif
						}
						else	/* Add an 'else' here by way of a convenient place to set a debugger breakpoint */
						{
							printf("");
						}
						/* endif(factor a probable prime?) */

					#endif	/* endif(PxWORD) */

					}	/* endif(res == 1) */

				}	/* endfor(l = 0; l <= (uint32)q_index; l++) */
			}	/* endif(q_index >= 0) */
		#endif	/* end #if(TRYQ > 1) */

		#if(!FAC_DEBUG)
			/*
			Every 1024th pass, write the checkpoint file, with format as described previously.
			*/
			if(((sweep + 1) %(1024/lenQ + 1)) == 0 || ((sweep + 1) == interval_hi))
			{
				/* TF restart files are in HRF, not binary: */
				fp = fopen(RESTARTFILE, "w");
				if(!fp)
				{
												fprintf(stderr,"INFO: Unable to open factoring savefile %s for writing...quitting.\n",RESTARTFILE);
				#ifndef FACTOR_STANDALONE
					fp = fopen(STATFILE,"a");	fprintf(	fp,"INFO: Unable to open factoring savefile %s for writing...quitting.\n",RESTARTFILE);	fclose(fp); fp = 0x0;
				#endif
					ASSERT(HERE, 0,"0");
				}
				else
				{
					curr_line = 0;

					/* pstring: */
					++curr_line;
					itmp = fprintf(fp,"%s\n",pstring);
					if(itmp <= 0)
					{
						fprintf(stderr,"ERROR: unable to write Line %d (current exponent) of factoring restart file %s!\n", curr_line, RESTARTFILE);
						ASSERT(HERE, 0,"0");
					}

					/* bmin: */
					++curr_line;
					itmp = fprintf(fp, "%lf\n", bmin);
					if(itmp <= 0)
					{
						fprintf(stderr,"ERROR: unable to write Line %d (bmin) of factoring restart file %s!\n", curr_line, RESTARTFILE);
						ASSERT(HERE, 0,"0");
					}

					/* bmax: */
					++curr_line;
					itmp = fprintf(fp, "%lf\n", bmax);
					if(itmp <= 0)
					{
						fprintf(stderr,"ERROR: unable to write Line %d (bmax) of factoring restart file %s!\n", curr_line, RESTARTFILE);
						ASSERT(HERE, 0,"0");
					}

					/* KMin: */
					++curr_line;
					itmp = fprintf(fp,"KMin = %s\n", &char_buf0[convert_uint64_base10_char (char_buf0, kmin)]);
					if(itmp <= 0)
					{
						fprintf(stderr,"ERROR: unable to write Line %d (KMin) of factoring restart file %s!\n", curr_line, RESTARTFILE);
						ASSERT(HERE, 0,"0");
					}

					/* KNow: */
					++curr_line;
					/* Calculate the current k-value... */
					k = (uint64)incr[pass] + (sweep+1)*(len<<6);
					itmp = fprintf(fp,"KNow = %s\n", &char_buf0[convert_uint64_base10_char (char_buf0, k)]);
					if(itmp <= 0)
					{
						fprintf(stderr,"ERROR: unable to write Line %d (KNow) of factoring restart file %s!\n", curr_line, RESTARTFILE);
						ASSERT(HERE, 0,"0");
					}

					/* KMax: */
					++curr_line;
					itmp = fprintf(fp,"KMax = %s\n", &char_buf0[convert_uint64_base10_char (char_buf0, kmax)]);
					if(itmp <= 0)
					{
						fprintf(stderr,"ERROR: unable to write Line %d (KMax) of factoring restart file %s!\n", curr_line, RESTARTFILE);
						ASSERT(HERE, 0,"0");
					}

					/* PassMin: */
					++curr_line;
					itmp = fprintf(fp,"PassMin = %u\n", passmin);
					if(itmp <= 0)
					{
						fprintf(stderr,"ERROR: unable to write Line %d (PassMin) of factoring restart file %s!\n", curr_line, RESTARTFILE);
						ASSERT(HERE, 0,"0");
					}

					/* PassNow: */
					++curr_line;
					itmp = fprintf(fp,"PassNow = %u\n", pass   );
					if(itmp <= 0)
					{
						fprintf(stderr,"ERROR: unable to write Line %d (PassNow) of factoring restart file %s!\n", curr_line, RESTARTFILE);
						ASSERT(HERE, 0,"0");
					}

					/* PassMax: */
					++curr_line;
					itmp = fprintf(fp,"PassMax = %u\n", passmax);
					if(itmp <= 0)
					{
						fprintf(stderr,"ERROR: unable to write Line %d (PassMax) of factoring restart file %s!\n", curr_line, RESTARTFILE);
						ASSERT(HERE, 0,"0");
					}

					/* Number of q's tried: */
					++curr_line;
					itmp = fprintf(fp,"#Q tried = %s\n", &char_buf0[convert_uint64_base10_char (char_buf0, count)]);
					if(itmp <= 0)
					{
						fprintf(stderr,"ERROR: unable to write Line %d (#Q tried) of factoring restart file %s!\n", curr_line, RESTARTFILE);
						ASSERT(HERE, 0,"0");
					}

					/* 64-bit (sum of trial q)%2^64 checksum: */
					++curr_line;
					itmp = fprintf(fp,"Checksum1 = %s\n", &char_buf0[convert_uint64_base16_char (char_buf0, checksum1)]);
					if(itmp <= 0)
					{
						fprintf(stderr,"ERROR: unable to write Line %d (Checksum1) of factoring restart file %s!\n", curr_line, RESTARTFILE);
						ASSERT(HERE, 0,"0");
					}

					/* 64-bit (sum of 2^p % q)%2^64 checksum: */
					++curr_line;
					itmp = fprintf(fp,"Checksum2 = %s\n", &char_buf0[convert_uint64_base16_char (char_buf0, checksum2)]);
					if(itmp <= 0)
					{
						fprintf(stderr,"ERROR: unable to write Line %d (Checksum2) of factoring restart file %s!\n", curr_line, RESTARTFILE);
						ASSERT(HERE, 0,"0");
					}

					fclose(fp); fp = 0x0;
				}
			}	/* Successfully wrote restart file. */
		#endif /* #if !FAC_DEBUG */

		QUIT:
			continue;

		} /* end of sweep loop	*/

		clock2 = clock();
		td += (double)(clock2 - clock1);
		clock1 = clock2;
		tdiff += td;	/* Update total-time accumulator (tdiff)
						prior to dividing per-pass accumulator (td) */
	#ifdef FACTOR_STANDALONE
		if(!restart)
			printf("\n");
	#else
		td /= CLOCKS_PER_SEC;

		fp = fopen(STATFILE,"a");
		fprintf(fp,"Trial-factoring Pass %2u: time =%2d%1d:%1d%1d:%1d%1d.%1d%1d%1d\n", pass
			,(int)td/36000,((int)td%36000)/3600
			,((int)td%3600)/600,((int)td%600)/60
			,((int)td%60)/10,(int)td%10
			,(int)(10*(td-(int)td)),(int)(100*(td-(int)td))%10,(int)(1000*(td-(int)td))%10
			);
		fclose(fp); fp = 0x0;
	#endif
		td = 0;

	/***********/
	#ifdef ONEPASS
		return 0;
	#endif
	/***********/
	}	/* end of pass loop	*/

/*...all done.	*/
#ifdef FACTOR_STANDALONE
	if(!restart)
	{
  #if(defined(P1WORD))
	 printf(   "M%s has %u factors in [%e, %e], passes %u-%u\n", &char_buf0[convert_uint64_base10_char (char_buf0, p)], nfactor, fqlo, fqhi, passmin, passmax);
  #else
	 printf(   "M%s has %u factors in [%e, %e], passes %u-%u\n", &char_buf0[convert_mi64_base10_char(char_buf0, p, lenP)], nfactor, fqlo, fqhi, passmin, passmax);
  #endif
	 printf(   "Performed %s trial divides\n", &char_buf0[convert_uint64_base10_char(char_buf0, count)]);
	 printf(   "Checksum1 = %s\n", &char_buf0[convert_uint64_base16_char (char_buf0, checksum1)]);
	 printf(   "Checksum2 = %s\n", &char_buf0[convert_uint64_base16_char (char_buf0, checksum2)]);

	/* Since we're done accumulating cycle count, divide to get total time in seconds: */
	tdiff /= CLOCKS_PER_SEC;
	 printf(   "Clocks =%2d%1d:%1d%1d:%1d%1d.%1d%1d%1d\n"
		,(int)tdiff/36000,((int)tdiff%36000)/3600
		,((int)tdiff%3600)/600,((int)tdiff%600)/60
		,((int)tdiff%60)/10,(int)tdiff%10
		,(int)(10*(tdiff-(int)tdiff)),(int)(100*(tdiff-(int)tdiff))%10,(int)(1000*(tdiff-(int)tdiff))%10
		);
	}
#else
	ASSERT(HERE, fp == 0x0,"0");
	fp = fopen(STATFILE,"a");
	fprintf(fp,"Performed %s trial divides\n", &char_buf0[convert_uint64_base10_char(char_buf0, count)]);
	fprintf(fp,"Checksum1 = %s\n", &char_buf0[convert_uint64_base16_char (char_buf0, checksum1)]);
	fprintf(fp,"Checksum2 = %s\n", &char_buf0[convert_uint64_base16_char (char_buf0, checksum2)]);

	/* Since we're done accumulating cycle count, divide to get total time in seconds: */
	tdiff /= CLOCKS_PER_SEC;
	fprintf(fp,"Clocks =%2d%1d:%1d%1d:%1d%1d.%1d%1d%1d\n"
		,(int)tdiff/36000,((int)tdiff%36000)/3600
		,((int)tdiff%3600)/600,((int)tdiff%600)/60
		,((int)tdiff%60)/10,(int)tdiff%10
		,(int)(10*(tdiff-(int)tdiff)),(int)(100*(tdiff-(int)tdiff))%10,(int)(1000*(tdiff-(int)tdiff))%10
		);
	fclose(fp); fp = 0x0;
#endif

	fp = fopen(   OFILE,"a");
  #if(defined(P1WORD))
	fprintf(fp,"M%s has %u factors in [%e, %e], passes %u-%u\n", &char_buf0[convert_uint64_base10_char (char_buf0, p)], nfactor, fqlo, fqhi, passmin, passmax);
  #else
	fprintf(fp,"M%s has %u factors in [%e, %e], passes %u-%u\n", &char_buf0[convert_mi64_base10_char(char_buf0, p, lenP)], nfactor, fqlo, fqhi, passmin, passmax);
  #endif
	fclose(fp); fp = 0x0;

#if FAC_DEBUG
	/* If a test factor was given, make sure we found at least one factor: */
	if(STRNEQ(qstring, ""))
	{
		ASSERT(HERE, nfactor > 0,"qstring != 0 but failed to find at least one factor");
	}
#endif

	return(0);

	/* Only reachable from argc/argv section: */
#ifdef FACTOR_STANDALONE
MFACTOR_HELP:
	printf(" Mfactor command line options ...\n");
	printf(" <CR>        Default mode: prompts for manual keyboard entry\n");
	printf("\n");
	printf(" -h          Prints this help file and exits\n");
	printf("\n");
	printf(" -m {num}    Trial-factor the Mersenne number M(num) = 2^num - 1.\n");
	printf("\n");
	printf(" -mm {num}   Trial-factor the double-Mersenne number M(M(num)) = 2^(2^num) - 1.\n");
	printf("\n");
	printf(" -f {num}    Trial-factor the Fermat number F(num) = 2^(2^num) + 1.\n");
	printf("\n");
	printf(" -file {string}    Name of checkpoint file (needed for restart-from-interrupt)\n");
	printf("\n");
  #if(defined(P1WORD))
	printf(" -bmin {num} Log2(minimum factor to try), in floating double form.\n");
	printf(" If > 10^9 its whole-number part is taken as the kmin value instead.\n");
	printf("\n");
	printf(" -bmax {num} Log2(maximum factor to try), in floating double form.\n");
	printf(" If > 10^9 its whole-number part is taken as the kmax value instead.\n");
	printf("\n");
  #endif
	printf(" -kmin {num}  Lowest factor K value to be tried in each pass ( > 0).\n");
	printf("\n");
	printf(" -kmax {num} Highest factor K value to be tried in each pass ( < 2^64).\n");
	printf("\n");
	printf(" -passmin {num}  Current factoring pass (0-15).\n");
	printf("\n");
	printf(" -passmax {num}  Maximum pass for the run (0-15).\n");
	/* If we reached here other than via explicit invocation of the help menu, assert: */
	if(!STREQ(stFlag, "-h"))
		ASSERT(HERE, 0,"Mfactor: Unrecognized command-line option!");
	return(0);
#endif
}

/****************************/
/****END OF MAIN PROGRAM*****/
/****************************/

/******************/
/*
Various small factor self-tests.
*/
int test_fac()
{
	/* Testcases for factors up to 65 bits are in the form {exponent, factor} pairs where, for 65-bit factors, the q-entry
	of the struct is the lowest 64 bits of the true factor (i.e. if it's a 65-bit factor, we infer the leading ones bit.)

	Testcases for factors up to 96 bits store all bits of the factor in a uint96.
	*/
	struct testFac{
		uint32 p;
		uint64 q;
	};

	struct testFac96{
		uint32 p;
		uint32 d1;
		uint64 d0;
	};

	struct testFac128{
		uint32 p;
		uint64 d1;
		uint64 d0;
	};

	struct testFac128x2{
		uint64 phi;
		uint64 plo;
		uint64 d1;
		uint64 d0;
	};

	struct testFac160{
		uint32 p;
		uint64 d2;
		uint64 d1;
		uint64 d0;
	};

	struct testFac192{
		uint32 p;
		uint64 d2;
		uint64 d1;
		uint64 d0;
	};

	struct testFac256{
		char p[80];
		char q[80];
	};

	/* Exponent/factor pair arrays for self-tests of various bitlengths. Must pad each array with a trailing pair of zeros. */

	/* Testcases with factors < 2^63 = 9223372036854775808: */
	static const struct testFac fac63[] =
	{
		{16219289, 7464112771264190017ull},{16230061, 7074289273913679991ull},{16232017, 7411932855077041073ull},{16232537, 6692065114888767967ull},{16233463, 7281938355280163287ull},
		{16238797, 7160849857727202529ull},{16241383, 8321268976801733153ull},{16247081, 6851345661512506279ull},{16264097, 6651246518968801591ull},{16270871, 8750884836637970639ull},
		{16273021, 8530948234727688607ull},{16275769, 8656222760818941631ull},{16276951, 8420763231476654791ull},{16287319, 7856663174122645703ull},{16291313, 7319751180156635263ull},
		{16292609, 9092939873876576857ull},{16304579, 8962807897733335697ull},{16309159, 7820104075051972591ull},{16310741, 7118960435061194119ull},{16315669, 7962842793467390041ull},
		{16317043, 8806735752647806361ull},{16323829, 8450744492397916153ull},{16336891, 7155399841291768831ull},{16344187, 8776703566703469847ull},{16344221, 8505188423818202153ull},
		{16344301, 7953229808761833919ull},{16357703, 7108223032778653207ull},{16372787, 6619838028511456999ull},{16373947, 7438987258875431921ull},{16377859, 8096713054586341063ull},
		{16384493, 7028583389392946873ull},{16385287, 7046001957550504913ull},{16386353, 7907418222099564433ull},{16393847, 7396873540638046079ull},{16402271, 8752890924846173591ull},
		{16410893, 6781869984316584449ull},{16413157, 8150367549328875839ull},{16419283, 8379034208328962239ull},{16419373, 4590586513826579537ull},{16421459, 1904620098914423441ull},
		{16421773, 1919634559953409777ull},{16422079, 1617297709004215951ull},{16422143,  351667921325618969ull},{16422587,  347957656837497407ull},{16422607, 5079529025476239473ull},
		{16422617,  877523758063210759ull},{16422641, 1904594759403697657ull},{16423129,  639383433125674231ull},{16424033,  876833185557798433ull},{16425109, 6929484154075657241ull},
		{16425967, 4868798027321748281ull},{16426297,  664300343615680241ull},{16427093,  647622110489212231ull},{16430203, 5947021049954262703ull},{16430263,  531416416863478007ull},
		{16430567, 6714238248345211081ull},{16430759, 1040588024141145631ull},{16431221, 7515765841945454129ull},{16431301,  769260698510760751ull},{16432147, 2775802912966282649ull},
		{16432331, 4485830256538297097ull},{16432817, 7811250160082452639ull},{16433741,  373097143060190383ull},{16433777, 7025465442860330327ull},{16433867, 2122188836804569639ull},
		{16433881, 6274909219403483887ull},{16433887, 1178275771257792817ull},{16435187,  404893783099670863ull},{16435207, 5706498478502752097ull},{16436087, 1249687921657073809ull},
		{16436681, 5418270029220506569ull},{16437227,  880527514744739041ull},{16437803, 1050659558835031697ull},{16438349, 1152641923853707873ull},{16438459, 8494499222030730001ull},
		{16438733,  897957128490827369ull},{16438921,  355469347041668513ull},{16438931, 6363980290034318527ull},{16439183,  727804660219798193ull},{16439531,  381922949073827639ull},
		{16440629,  551592949703045713ull},{16441427,  514743839833790687ull},{16441723, 7826810543654605759ull},{16442941,  852026135819507489ull},{16443001,  680825060844814393ull},
		{16443893, 1277077523412980857ull},{16444399,  403946809003560737ull},{16445029, 1313020171506418103ull},{16445449, 4532532117087171361ull},{16445881,  314816963337354217ull},
		{16445999, 4000347492271511999ull},{16447793, 3909966094211431663ull},{16448987, 6702585753220580233ull},{16449113, 1395256032300764801ull},{16449187,  371179628750936801ull},
		{16449593, 1283294140172967047ull},{16449661,  382963805761197047ull},{16449827,  589484546028463361ull},{16450703, 8740277214666380953ull},{16451681, 2707820247743716409ull},
		{17715697, 2405285686624656961ull},{17716921, 7862694219641149649ull},{17725703, 1709828509468925647ull},{17729219, 1818195666940512361ull},{17732269, 4749139467781751281ull},
		{17732531, 8620020444320802169ull},{17741401, 1588232881627535471ull},{17741771, 2800144830835674079ull},{17743751, 2269674038404230343ull},{17747491, 8598509628823480727ull},
		{17748257, 9087140485434854489ull},{17750333, 7251833404705913977ull},{17751163, 3820553770628769199ull},{17752633, 4704959116091028679ull},{17753363, 7075257636385056583ull},
		{17754259, 7297159751574473761ull},{17758189, 4396811225247180479ull},{17760511, 4745090588707286561ull},{17760893, 2853041236643552393ull},{17765563, 1672908406048342823ull},
		{17765659, 4428560580432537343ull},{17767787, 1837671283556578471ull},{17770043, 3092513594545328617ull},{17770777,  779919558137764991ull},{17771933, 1217980041393079889ull},
		{17771989, 3683503882483319137ull},{17772103,  934951397486511551ull},{17773807, 2835009341000295337ull},{17774051, 1916127240891187847ull},{17774917, 6513143384743979257ull},
		{17776513, 1948595367612706247ull},{17777099, 3140841499126593247ull},{17777297, 6654525407953706177ull},{17778391, 2960846207983915487ull},{17779787, 8799635039454374711ull},
		{17780947, 1338327839026813807ull},{17786393, 2479692584449808633ull},{17786479, 3705119304553621399ull},{17788829, 4337975187311263769ull},{17793301, 3363405780011350313ull},
		{17796997,  644515749614290871ull},{17799139, 4850550556337408063ull},{17809373, 8858673253181631769ull},{17811337, 5616750395550952409ull},{17811853, 3227714233149548983ull},
		{17812411, 4684506166881580409ull},{17812589, 8674042470759946327ull},{17814707, 1181105980369035367ull},{17816543, 7023683719607349833ull},{17817647, 5482282061362804081ull},
		{17818763, 8358943986123319271ull},{17820659, 1666842203779044511ull},{17821913, 1622936916022631081ull},{17822183, 3907752947435394377ull},{17826299, 1329300478629304361ull},
		{17828047, 2423187390334065937ull},{17829613, 3369241733425614041ull},{17831083, 1477733878367589473ull},{17833499, 1531563491873924849ull},{17834923, 2190674486659724089ull},
		{17835149, 3271992840407563639ull},{17835347, 3564903515554180057ull},{17838193, 1741480327901108647ull},{17838697, 6672437126818019801ull},{17839741, 5448515813271799129ull},
		{17842001, 4652601937964804191ull},{17845909, 8815568571441254321ull},{17845969, 3553263474276793049ull},{17846581, 2048983536460732087ull},{17847689, 7778712127779173767ull},
		{17848387, 3907383057407439271ull},{17848933, 2464245591905914177ull},{17849053, 2150183260070870471ull},{17849191, 2407856202749932553ull},{17851157, 5888131719304374961ull},
		{17851307, 8439995926524285881ull},{17851741, 3407041535153554681ull},{17852273, 6051572822283142393ull},{17857379,  685402904791012417ull},{17861069, 5197640349369569873ull},
		{17861183, 2817440372348117777ull},{17861309, 2323778877594576001ull},{17861561, 7613389509871645681ull},{17862001, 1274705791716433303ull},{17863873, 3718381908400885441ull},
		{17867039, 2848730709312090247ull},{17868757, 4049709796007485271ull},{17869031, 7240853613770980279ull},{17870807, 3143753649823393489ull},{17870953, 1524830233471897897ull},
		{17875537, 1664465123229227681ull},{17876251, 2403629034158699383ull},{17878099,  712042873447678601ull},{17881309,  903201483228046399ull},{17883809, 8490501007003379807ull},
		{17888639, 2105629043627382127ull},{17890667, 5735679228382833647ull},{17891113, 2876396552211694177ull},{17891147, 3093927243161087143ull},{17891807, 2664231706296909673ull},
		{17892221, 1978238729073140969ull},{17893643, 5419863053469262121ull},{17895089, 1533338567834601023ull},{17895103, 5160136017722307967ull},{17896811, 7897800523391520407ull},
		{17897839, 3374272067429879321ull},{17898479,  749593692866362247ull},{17908691, 1327377814615443967ull},{17909531, 1685626660799023367ull},{17909929, 2057175048146017463ull},
		{17915189, 1502198297363289137ull},{17916007, 2548941981249916039ull},{17918779, 6250235537067221041ull},{17920313,  982796297387492737ull},{17920367,  616895704215165097ull},
		{17920663, 6556922280592103159ull},{17921363, 3344080983855421297ull},{17923667, 1310662441188923177ull},{17926043, 1112470599742175431ull},{17929829, 7790880448537146551ull},
		{17930141, 5488202995825707401ull},{17930449, 6804159664440658391ull},{17931607, 5283700822626454303ull},{17931803, 3700358431737961943ull},{17931853, 8959646386932483937ull},
		{17933089, 3094872653106269879ull},{17933821, 5805307060406953537ull},{17934187, 2146159967654259929ull},{17936447, 7823722696080620041ull},{17937497, 3514677418927413071ull},
		{17938157, 1231292317361854199ull},{17940749, 5059333168351045729ull},{17943293, 5993577327478456249ull},{17943533, 1388115696739083727ull},{17948417, 4732957426757595103ull},
		{17948851, 2394620018782987729ull},{17951159, 2058879430641527057ull},{17951729, 7474004052629873911ull},{17952611, 2516644147971176591ull},{17952917, 1864851701193217279ull},
		{17953073, 1007670704243820809ull},{17954081, 1301079621918711617ull},{17954891,  964648425701599319ull},{17957509, 6840963133271524111ull},{17957683, 3978152863479088207ull},
		{17959793, 4669330482742391657ull},{17960119, 6752560053788375471ull},{17960783, 1678745601392391911ull},{17960977, 1228182543339675761ull},{17961421, 1020658709440637711ull},
		{17961443, 2797636755196101839ull},{17961721, 9063572628875007847ull},{17963123,  815678591888801513ull},{17963287, 1686003604554390599ull},{17964007,  778257809046093137ull},
		{17964613, 3754431528196358599ull},{17964931, 6361663250068077871ull},{17965289, 4428736923932099951ull},{17970331, 8117285082720974767ull},{17970349, 3864521381056789633ull},
		{17970529, 1426577669200287553ull},{17970709, 4518264433954012039ull},{17971237, 5471173681460147033ull},{17971697, 3699375676644287231ull},{17972971, 1359645139272461927ull},
		{17974861, 1691952521705558759ull},{17975981, 5648969327860083959ull},{17977579, 3748493120761985231ull},{17977957,  627232853285495647ull},{17978243, 1736248171119512263ull},
		{17979613, 2620854359698631863ull},{17982973, 5845737077781621887ull},{17984053, 2256835105241380121ull},{17984179, 1036884414685348673ull},{17984509, 8476679719127171777ull},
		{17985281, 1810544315152389041ull},{17986021, 2437445911911384503ull},{17986523, 4599843559465033063ull},{17986949, 1748229558785170831ull},{17987491, 2032912769179543457ull},
		{17987941,  630951207087221641ull},{17990671, 4331370829474908449ull},{17990983, 3525084813671441983ull},{17991541,  815037019285024057ull},{17992063, 2834821057516610377ull},
		{17994631, 3640971086950719167ull},{17994709, 6165252858770522527ull},{17994841, 3699354237817492591ull},{17997229, 2985492437257596839ull},{17997613, 3058804716917440529ull},
		{17998921, 1382684188503730727ull},{17999239, 1500972887730833927ull},{18004897, 4759900927558675889ull},{18005509, 9172509111918008737ull},{18005881, 7736227950495029071ull},
		{18006683, 3063561940694759783ull},{18011219, 2390466914947953551ull},{18011557, 7366817463725456441ull},{18011771, 2226790528673362367ull},{18011809, 1503751987321572641ull},
		{18012307,  220881355348927807ull},{18013507,  940523625874376009ull},{18013889, 1510301576718077839ull},{18014389, 7538190749320752511ull},{18014839,  277820521370888999ull},
		{18015551, 2340902482533374311ull},{18015953,  190079508451330231ull},{18016001, 4348492870379062169ull},{18016049, 3626126767636896889ull},{18016189, 1208034199034769401ull},
		{18016223, 8227372396468321529ull},{18016267, 2470104015463296281ull},{18016837, 1161245128754030233ull},{18017513, 3253408194517706441ull},{18018349, 1101875138253273577ull},
		{18018467,  195863445150291847ull},{18019637,  253771669953795991ull},{18020077, 3094501034482670753ull},{18021217,  178202077941327599ull},{18021617, 1095316961454549121ull},
		{18022343, 1902723646205275703ull},{18022379, 6182940253225886719ull},{18022517,  669237263128794313ull},{18023483, 2819237485165040417ull},{18023543,  664891496674705343ull},
		{18024137, 3423810082502902159ull},{18024623, 1358245988590673033ull},{18024833, 2413382318575227841ull},{18025171, 4953558993717617273ull},{18025493, 4046226592751303561ull},
		{18026167, 7301081045496468719ull},{18026759,  347459848092058087ull},{18027403, 1390530689850382279ull},{18027613,  553667433157303321ull},{18027643,  804282151680440903ull},
		{18028457, 3410205068438600407ull},{18029237,  384382401233265737ull},{18030157, 1814163598947018881ull},{18030811,  218703143967921281ull},{18031129,  336284434526159191ull},
		{18031199, 1773675444104420711ull},{18031807,  449829212253045649ull},{18032213,  809991539314593359ull},{18032737, 5563212097056992351ull},{18033047, 4242124268372681071ull},
		{18033313,  892754292286804439ull},{18033559,  578363464774452089ull},{18033749,  649107982030132321ull},{18034129, 8411740586508222721ull},{18034153,  228575622232707121ull},
		{18034193, 1568046814620032273ull},{18034487, 6563374615048802527ull},{18034867,  585223207509348217ull},{18035107, 2402182266587944111ull},{18035789, 6855462942253804601ull},
		{18035819,  430643152681188121ull},{18036311, 1309864431794423207ull},{18036407,  634094963019467681ull},{18036539, 2764330705944299369ull},{18036751,  969575221888062233ull},
		{18037189, 4391462561032616009ull},{18037231, 6998278073234944297ull},{18038123,  234324071638369567ull},{18038299, 1034209390921824937ull},{18038689,  285195009201221039ull},
		{18038843, 8465335113608243977ull},{18039719,  939317313181647817ull},{18039821, 8483872917922747399ull},{18040051,  550135978585350383ull},{18040597,  369386639326138207ull},
		{18040691, 7437117407042207281ull},{18040751, 3007057566367235767ull},{18040969, 1440061135634909441ull},{18041173, 1801135275958123841ull},{18041251,  212667050862844247ull},
		{18041371, 1607487587321961431ull},{18041449,  331381074274740977ull},{18041531, 8155698232304113193ull},{18042161,  719516832900729697ull},{18042293, 4045697812716293801ull},
		{18042361, 1195388362488578681ull},{18042547, 2264048456405883071ull},{18042809, 1041025085117227487ull},{18042887,  820583244199534793ull},{18043657, 6698885379723509521ull},
		{18044771,  217751151498027799ull},{18045019,  886346438516147753ull},{18045553,  684060296358930769ull},{18045983, 1727756785397843353ull},{18046849,  344383295054587687ull},
		{18046937, 1582723876470302791ull},{18046957, 6265230556365760207ull},{18047851, 2794465755922650769ull},{18048769, 1272884020935274439ull},{18048869, 2687244032076582031ull},
		{18048967, 2882596357369915999ull},{18049021,  151593119343580553ull},{18049079,  146863140298552751ull},{18049279,  302279348097426983ull},{18049607, 1027073160738358417ull},
		{18049729,  170705412915485111ull},{18049783, 2193137766783224489ull},{18050027,  249763397783639767ull},{18050477, 9034549389428481287ull},{18051151, 8270716773764582561ull},
		{18052591,  213534006096423721ull},{18053131,  145637662655615297ull},{18053641, 3574744060404862439ull},{18053681, 3523102587334514273ull},{18053713, 1274525953140893983ull},
		{18053771,  179298408456414497ull},{18054019, 5649369575053961591ull},{18054229,  466796606374323649ull},{18054577, 2331242743843392751ull},{18055153,  964029306347175647ull},
		{18055781, 1131377662856950169ull},{18056021, 3306352774543498007ull},{18056341, 2199830028736195519ull},{18056959,  575696006576981399ull},{18057101, 1032151692346949719ull},
		{18057253,  700043530529500567ull},{18057257,  317329196933100529ull},{18057751, 3201031337245812953ull},{18057761, 1268134802832477257ull},{18058127,  975859961953336007ull},
		{18059207, 3648110332144819729ull},{18059857,  428772495755334047ull},{18060187,  239976875255863241ull},{18060257,  306692189293676009ull},{18061111,  161771569920155527ull},
		{18061223,  993238009496376041ull},{18061597,  531092340787785431ull},{18061721,  397467971850349511ull},{18061889,  170575814893989689ull},{18062197,  459009642330749087ull},
		{18062221, 4762721205492398143ull},{18063697,  155760394292528407ull},{18064261,  869279864055005729ull},{18064609,  902086647190626031ull},{18064663, 4326753552702418993ull},
		{18065473, 1016638870230715063ull},{18065573, 4980322140187853369ull},{18066827, 3041030515267231999ull},{18067013, 2965222136820402343ull},{18068201,  732115975825870919ull},
		{18068377, 2654786510720728759ull},{18068873,  382620704518269719ull},{18069367,  935330914958678617ull},{18069533,  439156261511080703ull},{18069851,  895513289517439447ull},
		{18070309,  169411595004322703ull},{18070981,  468402609294531217ull},{18071509,  619224414211506937ull},{18071783,  269279113553092543ull},{18071891, 2051286244830893879ull},
		{18072773, 5242009072298288161ull},{18072793, 8819126928139257361ull},{18073207,  303650943296322233ull},{18073613, 2204719604073948097ull},{18073843, 2123288934790210753ull},
		{18074057,  170868633716270417ull},{18074129,  231723590213766793ull},{18074531, 5617874574099630319ull},{18074869, 1313575677565859287ull},{18075227, 5966010148617767489ull},
		{18075413, 1072730263421826137ull},{18075469,  157453782618412799ull},{18075829, 3540387457043046913ull},{18075929, 1427015700350286601ull},{18076417,  350296688447252401ull},
		{18076753, 9106402842275874799ull},{18076987, 6513441085781826191ull},{18077041,  954866887065157361ull},{18077077,  156911835368516561ull},{18077509, 2858210469415838191ull},
		{18077539, 7409642155457441729ull},{18077849, 1727714706371758799ull},{18078019,  208075572945254543ull},{18078097,  809063907179527457ull},{18078773,  209054887364316841ull},
		{18079447, 2991325265195645407ull},{18079757,  469481662092691673ull},{18080059,  156437228555447297ull},{18080497,  265091087382571111ull},{18080773,  863973615071231263ull},
		{18081527,  629299790246739247ull},{18081593, 1569037754951646233ull},{18082327,  294136552344507503ull},{18082601, 7772927443359071831ull},{18083011,  764051439321188063ull},
		{18083851, 1093556287922395681ull},{18083941, 5005994961296695481ull},{18084103, 5396859190608684961ull},{18084511,  280218395260026287ull},{18085163, 3958373172235987537ull},
		{18085259, 2421951227499722447ull},{18085597, 1652097288619224871ull},{18085877, 5970055030215365329ull},{18086069, 5194261471992541321ull},{18086473,  175396807623692647ull},
		{18086837,  428007377950999711ull},{18086897, 2086916000630989369ull},{18086941,  507585516102880289ull},{18087053, 6736325484534062567ull},{18087241,  229349757904405031ull},
		{18088823,  348983282328464657ull},{18088997, 3817682373416327543ull},{18089221, 7717318284654310807ull},{18090749, 4400781849969539081ull},{18090829,  254929304698201369ull},
		{18091243, 2178950725735373921ull},{18091793, 5360440248670130159ull},{18091939, 2955370698546160567ull},{18092299,  189845745823406633ull},{18092729,  786834525027893201ull},
		{18093421, 2528677625598381841ull},{18094199, 7475161236393989161ull},{18094523,  500414590814444351ull},{18094829, 1692354721386162271ull},{18095381, 1488542967045098257ull},
		{18095489, 3474495571049451089ull},{18096017, 2381707920189331807ull},{18096829, 4298659432822913113ull},{18097117,  252582943145637983ull},{18097691, 1452486143800069319ull},
		{18097777, 3811727973559918463ull},{18098173, 4646682542258342239ull},{18098467, 2766600574338603679ull},{18098719,  498347184635824031ull},{18099317,  197887977417451367ull},
		{18099593,  692527271711510801ull},{18100351,  986858833532297393ull},{18100487, 5559545560067206831ull},{18101351, 5892698227386194249ull},{18101723,  330663381619973953ull},
		{18102113, 4108304515751346191ull},{18102169,  658093059110448113ull},{18102551,  278135947855081399ull},{18102827, 3614226096429255457ull},{18103049, 5669365061064864839ull},
		{18103699, 3418868997915619559ull},{18103961,  300843536605165847ull},{18104221,  382634038236483721ull},{18104369,  833152711474330081ull},{18105079, 2294178426436943801ull},
		{18105331,  200171358090730927ull},{18105929,  233146044693157391ull},{18106423, 9010404214242243343ull},{18106733,  240725289847112183ull},{18108067,  173634447567858457ull},
		{18108109, 2039429751651682297ull},{18108749, 8907523168165945903ull},{18109099, 1421698886573962441ull},{18109373, 1148928461554787041ull},{18109783,  219645083823801679ull},
		{18110101, 6356333444674501297ull},{18110329,  636409319403626969ull},{18110633, 5137754947683470257ull},{18110737, 6949931723478004673ull},{18112219, 1038596187216405943ull},
		{18113047, 2636979483956432687ull},{18113423, 5711003588895540041ull},{18113437, 7237656685324752551ull},{18113647, 3664424537447090401ull},{18113819,  644487044676701329ull},
		{18114329,  180937307436358751ull},{18114851,  191730898327800319ull},{18115219, 6967968772129631927ull},{18116167, 3284006162755109681ull},{18116473,  295911982481558263ull},
		{18116653,  905674446545077337ull},{18116933,  182298573362242793ull},{18117343,  179042324916860929ull},{18117611,  276403239447018521ull},{18117727,  265355157611625017ull},
		{18118589, 2100547192247488343ull},{18118813,  297889740791115089ull},{18118901, 2006169583836711151ull},{18118907, 1394872940423976479ull},{18119047, 3274845436157029897ull},
		{18119107,  149695768675358137ull},{18120203,  931416251824709527ull},{18120373,  326540082364905463ull},{18120517, 2475413327350678009ull},{18120733,  190253658549352231ull},
		{18121843, 6359751903252262831ull},{18122623, 4096620322163539519ull},{18123043, 4163005457310656519ull},{18123817, 7035605257132928143ull},{18123877,  841608666156857441ull},
		{18124969,  250169084767618031ull},{18125017,  185850489228528127ull},{18125089, 2115940694316175591ull},{18125573,  156569053638942983ull},{18126587,  160497608613885097ull},
		{18127093, 2729552475111634177ull},{18127631,  202972162459180159ull},{18129077,  826185140698051193ull},{18129103, 7756965693917461751ull},{18129487, 5710844170141724833ull},
		{18129953, 1026702811985035831ull},{18130379,  844753854261726401ull},{18132473,  508082638582175071ull},{18132703,  984788573937426871ull},{18133009, 4179248003537482327ull},
		{18134377,  353995670830449383ull},{18134561, 1644404173956643577ull},{18135521,  193091585683392047ull},{18135841, 1592191104201793057ull},{18136043,  164769434262411527ull},
		{18136087,  588583452577383391ull},{18136757,  942155756229059431ull},{18136897,  498022844181805609ull},{18137389, 2124101979953718983ull},{18137543, 1712231773162793983ull},
		{18137857,  306824264431376327ull},{18138451, 7582282194251423767ull},{18138649,  172912609859686919ull},{18138871, 3502704858995300303ull},{18138943,  246436192567308041ull},
		{18139543, 7285407584197933721ull},{18139549, 8194085954986376671ull},{18139601,  151382510178993257ull},{18139711, 2628003804944996063ull},{18139787,  426501575901789887ull},
		{18139909, 1046433785458137217ull},{18140159, 3453473050646226497ull},{18140273, 5713537045599308921ull},{18140971,  483292855669549327ull},{18141997, 3815540980096758137ull},
		{18142309, 8994056844398885153ull},{18144433, 7624512815589709681ull},{18144851,  910777532920154969ull},{18145009,  188541992445693137ull},{18146059,  510420446392176527ull},
		{18146173, 1077844070144357809ull},{18146389, 1542355791176058953ull},{18147403, 2286897497466736321ull},{18147457, 1717929434260216087ull},{18147923, 1863286297415992049ull},
		{18148337, 4530369323750308271ull},{18148799, 3297933472724493719ull},{18149039,  880845054646901471ull},{18149707, 1185286443100915081ull},{18149843,  916379742324037193ull},
		{18150389, 3822485160260893033ull},{18151093,  276821161702590647ull},{18151249, 3813458507193178439ull},{18151433,  504627225601545217ull},{18152203, 2250101091316519247ull},
		{18152227,  177869433900604409ull},{18152297,  624789460689330721ull},{18152833,  495113827785503497ull},{18152839,  885462025654928081ull},{18152861,  745935741309920879ull},
		{18153169, 3605232236719796351ull},{18153271, 3877198473695927321ull},{18154307,  849875488878394039ull},{18154781,  571926881349174353ull},{18154943,  155169642064458841ull},
		{18155341, 2105616473697176423ull},{18155399, 6043531412317122401ull},{18155939, 3895014398342628833ull},{18156067, 2786585146312304017ull},{18156139, 5200014469418315143ull},
		{18156353, 3580508484628476463ull},{18156517,  589464156813894023ull},{18156659,  606575457511111639ull},{18156767,  203157325643180927ull},{18157187,  397214103754615871ull},
		{18157303,  576095881253912743ull},{18157859, 6212058775368239569ull},{18157943,  159009663500900609ull},{18158879, 3046826399782247647ull},{18160739, 1834647890429700191ull},
		{18160949,  593999785117695553ull},{18161167,  515672149352372599ull},{18162563,  325095769929189751ull},{18162769,  803974127577401471ull},{18162913, 1357411268881729807ull},
		{18163111,  184841740940977937ull},{18163459, 2856141027727809919ull},{18163823, 2023000940646103897ull},{18164953, 6200977504829196521ull},{18164999,  209733008010133879ull},
		{18165449,  581632703556685577ull},{18165757, 8551912773780986681ull},{18166429, 5446844587056314327ull},{18166543, 2266665690147190831ull},{18166787,  284384707970416967ull},
		{18167431,  472166489464865399ull},{18167533,  454009591465948559ull},{18167563,  708026462172382921ull},{18168611,  249407869166136743ull},{18169201,  166259287297693223ull},
		{18169861,  443632828183509721ull},{18170197,  551075689667191967ull},{18170377,  495087521203707449ull},{18171443,  158909252898758617ull},{18171731, 1761088143471303481ull},
		{18171877,  193406421160001207ull},{18171949,  959021713174709729ull},{18171971,  212582186997306377ull},{18172283,  306340199670707177ull},{18173159, 2710192223805113503ull},
		{18173341, 2655893467840057759ull},{18173773, 5208297326830612199ull},{18173801, 2566037605552291639ull},{18173803, 7609123229331745631ull},{18174001,  280538571090706153ull},
		{18174461,  373169859737261921ull},{18174613, 3696057688567765441ull},{18175307, 4606467234303035863ull},{18175433, 1671941933015884697ull},{18175603,  358104212205598393ull},
		{18176129,  297748851152334433ull},{18176479, 1727768194505086439ull},{18176971,  580938966948809543ull},{18177721,  288661255622268247ull},{18178481, 1412900492698726673ull},
		{18178747, 1051870922187653719ull},{18179011, 4129359287631769799ull},{18179107, 6950769019465931417ull},{18179251,  209784776455622567ull},{18179339, 1071223273576351913ull},
		{18179743, 5450404147513203847ull},{18179747,  278846268444797423ull},{18179881,  579166105626521671ull},{18179963,  422004445218799519ull},{18180161, 6611758316647537577ull},
		{18180523, 3866032370946584039ull},{18180619, 3511515211683351449ull},{18180677, 2788648282376867167ull},{18180931, 6090731622611663591ull},{18181103,  639713485080233719ull},
		{18181591,  493845656085060953ull},{18181643, 6505947238121659543ull},{18182093,  148609684310517929ull},{18182149, 1421216450235542759ull},{18182257, 1446565977045436033ull},
		{18182933, 6599802010049618921ull},{18183043, 4557063360658169617ull},{18183713, 3243799555344182671ull},{18183853,  395470449031694161ull},{18184009, 5686173517548316087ull},
		{18184043,  373695005994685607ull},{18184417,  231657393871958423ull},{18185021,  500385408994477393ull},{18186167, 2137325682797422129ull},{18186403, 3705306186874921793ull},
		{18186653, 4636504888324534583ull},{18186919, 4487805898789947119ull},{18187153, 6983373698391292919ull},{18187291,  370733891538789481ull},{18187451,  556367250482015719ull},
		{18188207, 4575824555835552737ull},{18188347, 2947808031323356391ull},{18188897,  279655125154038481ull},{18189211,  682770116581096463ull},{18189239,  721353005779623391ull},
		{18189683,  284497605842290153ull},{18190547, 2366428611869035327ull},{18190633,  611552330470076887ull},{18190883, 3401415680513815457ull},{18191449,  335577525522872177ull},
		{18191869,  430855402541381393ull},{18192523, 3295002558186922673ull},{18193271,  719309171397378511ull},{18194773, 2206473614203878367ull},{18195173, 2198996002033853881ull},
		{18195563,  870871242175451887ull},{18195643, 6182575437692950537ull},{18196777,  244421485308650417ull},{18196807,  214838963113848809ull},{18198001, 3797160104673324583ull},
		{18198307, 3261313241635456673ull},{18198407,  908961388000467377ull},{18198611,  147117672508277161ull},{18198757, 1291057922497655201ull},{18198839, 7702578482357557921ull},
		{18199123,  627938298322402391ull},{18199243, 5715394251020166799ull},{18199319, 1751859472378580993ull},{18200447, 2241185363083369897ull},{18200453,  964234051444955183ull},
		{18200729,  226278029714621743ull},{18201653,  453572672024917831ull},{18201751,  177416839093993703ull},{18201977, 7556583206839917529ull},{18204647,  384711185932909679ull},
		{18202727,  324976325860139897ull},{18202763, 3619808293690777481ull},{18203599,  255716891729650409ull},{18204551, 1240325425602719639ull},{18206063, 6154427524543057841ull},
		{18204833, 5064367179117501257ull},{18205427,  171635048851402607ull},{18205567,  498049680871445783ull},{18205849,  420551620709984063ull},{18208871, 4825503957031353559ull},
		{18206707,  194980615976282599ull},{18206767,  598824763799582977ull},{18207751, 5450962935976347551ull},{18208459,  732071086083278041ull},{18210487, 7904260220388114433ull},
		{18209309,  421921108806185609ull},{18209663, 8914936054468409521ull},{18209677,  502857357742033897ull},{18210287, 3828673568316018007ull},{18212209, 8790088711977627727ull},
		{18210749, 2639089913010052231ull},{18210839, 1252897572756897161ull},{18210989, 5449720962043005161ull},{18211819, 1475550183670841617ull},{18215221,  326578760775994607ull},
		{18213947, 1836680918690277743ull},{18213967, 5459789331634736321ull},{18214393,  195882229760802737ull},{18214969,  908643053573127737ull},{18217841,  796311598662086929ull},
		{18216113, 2407520616714053377ull},{18216281, 1012316473329291833ull},{18217097, 7081648448968956167ull},{18217231, 7391482353834144271ull},{18219679, 7151731110031749079ull},
		{18218107, 1024998043469714399ull},{18218329, 4062483484914991183ull},{18218821, 1574151660610168777ull},{18219193,  465003359815917473ull},{18222047,  183179527238201713ull},
		{18220121, 1250742979702200079ull},{18220193, 6884674196094390961ull},{18220427, 7661835938013915577ull},{18221563,  355351420754789057ull},{18223081,  271683140874255079ull},
		{18222431, 1345721149104357527ull},{18222473, 3615247421609496839ull},{18222541, 4684088799094989457ull},{18222679, 8986103483467189951ull},{18226207, 2704015245587660479ull},
		{18223157, 5504989872766853537ull},{18224113,  337598450890815041ull},{18225239, 1774628704161652543ull},{18225947,  170795563856396191ull},{18227941,  378986137162265657ull},
		{18226259, 2649773119432899799ull},{18226573,  911655289398967943ull},{18226661,  445670037826519969ull},{18227501, 7493941152443672183ull},{18230129,  797093455655673119ull},
		{18228671, 9040364929018544423ull},{18229217, 6172674414859643609ull},{18229609,  226169112606204431ull},{18229957, 6222489105657968551ull},{18232183,  944222602441112623ull},
		{18230347,  189233265048197969ull},{18230479,  604328392674667081ull},{18231443,  147016546516653391ull},{18232063, 8986734322535829143ull},{18233221,  445148471262696793ull},
		{18232589, 4142114913805405951ull},{18232657,  178737507169092407ull},{18232861, 7113129966272258737ull},{18232873,  910196727414821809ull},{18235691,  164802005523725623ull},
		{18233599,  219626590199244689ull},{18233653, 3827298988308429593ull},{18234467, 5822485231311541927ull},{18235501,  392569969513211351ull},{18236741,  196115251171071497ull},
		{18235759,  634470290505529649ull},{18235829,  209128182032467463ull},{18236173, 1072782161927740559ull},{18236201,  790424566760147359ull},{18240023, 1145096636605819193ull},
		{18236807,  466544298281538161ull},{18237683,  150980093785031393ull},{18238039, 8257131768449278303ull},{18238439,  344896464741121177ull},{18241291, 6931896967949517449ull},
		{18240689,  575543924177829127ull},{18240707, 2551774584244094753ull},{18240791,  502038045619799519ull},{18240793, 1170545082309195503ull},{18244049, 6069262720224940337ull},
		{18242249, 5828183487410879561ull},{18242837,  329863222762232767ull},{18243541, 1145311999667281321ull},{18243691, 4730620580709702407ull},{18245393, 1756929621995499241ull},
		{18244397,  192953761876994009ull},{18244609,  693347914896424681ull},{18244871,  185263315342358527ull},{18244969,  313851947884446847ull},{18246359, 1724545012534814191ull},
		{18245431, 2427947115805275401ull},{18245483, 2236899860371720217ull},{18245489, 3135301377567517289ull},{18245911, 5185505342138518889ull},{18248129, 1889170052270492231ull},
		{18246493,  661645029293447761ull},{18246617,  282971109500942873ull},{18247231,  270517615508384401ull},{18247321,  159147066856219279ull},{18250627,  291592687904150233ull},
		{18248161, 7709695907107275271ull},{18248557, 3186743502444660737ull},{18248621, 4251433917700860097ull},{18249817,  493224469282714441ull},{18251957,  254280057031881247ull},
		{18250751,  254345153322583249ull},{18250927,  924384987729884311ull},{18251573, 8971192775529465359ull},{18251921,  818573016843409937ull},{18253201, 2107029553327261049ull},
		{18252413, 6276507976472527231ull},{18252439, 1382377176451739687ull},{18252473,  156153666341913271ull},{18252721,  955287304650810977ull},{18255473,  319847903150459953ull},
		{18254153,  967283619169722713ull},{18254179,  219243245853140479ull},{18254261,  426226079762262881ull},{18254713, 5193684555003623513ull},{18257809,  308089528042217839ull},
		{18256003, 5286812608446677431ull},{18256541, 2553532129640010329ull},{18257039,  448060853576070257ull},{18257563,  321458459567713471ull},{18261493,  531522059923681919ull},
		{18259859, 2803350460979415799ull},{18260069,  331082250694020607ull},{18261137,  154050640123958233ull},{18261491, 3702574820038690927ull},{18262639, 1209709784108600393ull},
		{18261953, 2806113676062110233ull},{18262523,  684985867125297457ull},{18262577, 2194723316765298271ull},{18262597,  320968254367629577ull},{18265301, 1346964077869385711ull},
		{18263249,  232092702284631449ull},{18263251,  333277109337857999ull},{18263629, 1713796095354485687ull},{18264707, 1832987592900191017ull},{18267541, 1496402839560725617ull},
		{18265801, 4423192174067168921ull},{18266051, 1547492141360310889ull},{18267031,  567432888774070073ull},{18267047, 5106988365977004847ull},{18268391,  305702301712820839ull},
		{18267679,  174693156677091359ull},{18267827,  622339054125734633ull},{18267869, 1029565792938412967ull},{18268213, 1567498750360311343ull},{18270283, 3267912895027409807ull},
		{18268609,  849946831856870551ull},{18268849, 3589933220064654217ull},{18269851,  187189076554887889ull},{18269941,  684132024494418671ull},{18272459,  185218879178598929ull},
		{18270697, 4883150130560297143ull},{18271153,  847597287242915641ull},{18271373, 2678811554504263327ull},{18271699, 1035077953363428593ull},{18273979,  163029569082413321ull},
		{18272867, 4292910235570102649ull},{18273131,  209741654531247401ull},{18273377, 2209176452708378567ull},{18273919, 2540283736047175687ull},{18275233,  615695688832633991ull},
		{18274357, 5250220205935681729ull},{18274603, 1651356375517532207ull},{18274769,  683353857184539559ull},{18274793,  358189838547272569ull},{18276473, 2368605654265044937ull},
		{18275489,  358780015246475209ull},{18275633,  714810154491785543ull},{18275671,  777591913390936481ull},{18276131,  407054061248703889ull},{18279707, 2260875022023462961ull},
		{18277121,  986369995008748303ull},{18277283,  228176384967746561ull},{18278233, 4556501041742873849ull},{18278863, 2454505365996506623ull},{18280693, 4432908001376646401ull},
		{18279997,  154021947782950943ull},{18280187, 4079581038301390247ull},{18280189,  878473513058879207ull},{18280319,  357247190862453119ull},{18282479,  211056575094586799ull},
		{18280897, 2014965098614430153ull},{18281111,  313018661846486831ull},{18281147, 1046495746119219161ull},{18282149, 1158393037316521873ull},{18284093, 8438246621794815367ull},
		{18282533, 2542230761454948857ull},{18282749,  252921162085242593ull},{18282833, 6228271224778947713ull},{18283879,  202167909800447377ull},{18287299,  699415163018787223ull},
		{18284107, 6555765084751538351ull},{18284437, 4596424749553843079ull},{18284887, 3864332598578495761ull},{18287099, 7075693236187789471ull},{18290131, 3505439438466316217ull},
		{18287447,  791184749579030377ull},{18287623, 7137233656547846431ull},{18288509, 1903735137621720479ull},{18289937,  219531327119618807ull},{18291743, 2873872397818760873ull},
		{18290411,  684228304469438089ull},{18290659,  563712281110395383ull},{18290927, 3424153274995352719ull},{18291583, 3062407520782516471ull},{18294047, 4139587137772912577ull},
		{18291773, 2657423207973350447ull},{18292039,  251983731817092089ull},{18293101, 6998952403324571639ull},{18293657,  751539795410988359ull},{18295987, 6428839976520012353ull},
		{18294259,  602428265212755713ull},{18294721, 7589034719689448759ull},{18295003,  530722364249779991ull},{18295183,  155518178941858441ull},{18296737, 1282191130922981113ull},
		{18297571, 3288951767406279151ull},{18299003, 4522165993393804423ull},{18299447, 1506874563020357233ull},{0,0ull}
	};

	/* Testcases with factors < 2^64 = 18446744073709551616: */
	static const struct testFac fac64[] =
	{
		{17922587,10500365774503436201ull},{17924587,15641779111884102847ull},{17927311,12915704346519849697ull},{17938027, 9287694977263609817ull},{17941211,10016045939325808271ull},
		{17942927,12928465186953089863ull},{17963653,10943084366908922353ull},{17964227,12431505097071887473ull},{17967659,15718414880628053417ull},{17971007,17130259977555383783ull},
		{17973443,17017539148249318519ull},{17981947,17331582637129315543ull},{17984683,17075071760459211223ull},{17988793,10651829289881962249ull},{17990153,13875348797185757897ull},
		{17990213, 9612328233936311881ull},{17996261,10983089768339907263ull},{18016303,11011193468080521223ull},{18019909,12625693644608762351ull},{18024151,10754411617748801759ull},
		{18024311,12013002667638145399ull},{18025781,12825068851465148441ull},{18032587,17170312062251360359ull},{18033511,12031568180050170481ull},{18037577,10566050601376248193ull},
		{18040663,14859011986541991007ull},{18047423,14989510186280279071ull},{18048313,16214445839716767361ull},{18051923,10598954534434896529ull},{18055627,14057592431325128593ull},
		{18056047,16560715604598816241ull},{18059039,12811182984027587681ull},{18064777,15539690406724276993ull},{18066073, 9985641878418216991ull},{18067711,11449566963261644983ull},
		{18075257,13764994941016683383ull},{18075791,16672552177382226647ull},{18077821,11623423906484739527ull},{18079043,17169614195768327983ull},{18079123,17990551511959203257ull},
		{18080273,12155150476665080887ull},{18090001, 9789648295780602191ull},{18091883,10985008068068673007ull},{18095521,12658180920879996367ull},{18107017,15044832325095723511ull},
		{18107351,14046232068642146993ull},{18119851,11179467653397253391ull},{18120799,11418381227787294353ull},{18121517, 9600311723751200999ull},{18121799,10641782461606146511ull},
		{18122101, 9238369956591864047ull},{18125911,14284214035586927489ull},{18130529,16132196293595357033ull},{18131303,12132533847075902297ull},{18133517,13711702151742952271ull},
		{18136529,13553802287542899791ull},{18138227, 9814223728786685249ull},{18138437,11664104294072220647ull},{18142753,11841941210452963607ull},{18143239,13495717684024316977ull},
		{18144733,11453374630895585671ull},{18146147,12409236261334108927ull},{18146309,13941936454603083961ull},{18151307,16695225546321153647ull},{18157823,15274150651947770057ull},
		{18159851,10670964685324409993ull},{18162883,13984615577478771737ull},{18166397,16478002069230680743ull},{18170359,11555285165538057473ull},{18173191,13017176322370888999ull},
		{18174743,10899353333633834737ull},{18174829,13082852309834271431ull},{18175387, 9469759966159211119ull},{18177011,16562044284339342287ull},{18181343,12857396115642922399ull},
		{18184013, 9771683082091843559ull},{18190691,13254207919455131647ull},{18190903,15437851890296633887ull},{18196709,16287562569554793953ull},{18196993, 9275136914779640273ull},
		{18198841,11025186727945055441ull},{18199583, 9854261882174597857ull},{18200849,15285818081668067519ull},{18202049,11180960576914148191ull},{18211309,14428852738137829687ull},
		{18211993,11752043400810302297ull},{18215051,15463714506600122897ull},{18220127,12907674385704768017ull},{18220999,11394039312173819999ull},{18224827,10366044942826856209ull},
		{18228937,17973037128357378841ull},{18231331,18328139888296813361ull},{18232931,10003907358728522969ull},{18235879,15548404807307836393ull},{18242963,16134040372770842257ull},
		{18245207,17112902589623655359ull},{18253589,13909553524167145703ull},{18255499,11109231768403310369ull},{18257399,10738982321410344871ull},{18258283,15374699987470193449ull},
		{18263647,13762137093959242159ull},{18266777,14732963741405224223ull},{18268189, 9989690110846448329ull},{18269219,16284666399547421921ull},{18275251,13620718892071208681ull},
		{18275263,11262843094267061911ull},{18275651,13846368038170428023ull},{18277607,10504362932070630521ull},{18280159,12772485980427473983ull},{18281927,12631296696930554257ull},
		{18286687,17931410955470787601ull},{18292013,12702828058463407919ull},{18296671,14627091909328461551ull},{33402073,13932143274652230937ull},{17719931,12646230872610358319ull},
		{17719993,17458131644489262929ull},{17734169,11268951794162923127ull},{17742793,16341053115349924417ull},{17771027,12007015401209325023ull},{17773141,15918852021480399527ull},
		{17774641, 9341752468258236431ull},{17775269,10013306797089936121ull},{17811401,16160582285842380959ull},{17812637,15811238096354839487ull},{17815169,12298642243571509687ull},
		{17820757,12597566906366358017ull},{17829943,18335410068788651849ull},{17831813,15899391255100053209ull},{17851397,16860276014915517791ull},{17853761,16072139673628398673ull},
		{17870731,12143859436446628321ull},{17889841,16375574063043584023ull},{17902987,16086636940765296889ull},{17905253,17558635633759926961ull},{17911027,14646809963723851673ull},
		{17913557,17895543665490669193ull},{17915981,16726174377018723457ull},{16100419,14461463666320960511ull},{16104013,13440101789246121791ull},{16105279,10991970915886596511ull},
		{16118143,11337011726859890543ull},{16120229,16582660415820077063ull},{16121711,15998585226804618071ull},{16131469,14271788618292432257ull},{16132931,10760230434599829143ull},
		{16132969,10730782077481732817ull},{16135981,14331950710727986663ull},{16136507,10961703930971884903ull},{16137271,15296117896318004719ull},{16138747,17040351390832159609ull},
		{16140287,14702865045484912391ull},{16140419,11533383163345547927ull},{16141121,12125342584232876329ull},{16141553,15810596930722833329ull},{16142201,16759807228908186473ull},
		{16142437,14680112878087367873ull},{16143041,10214864560585659127ull},{16152289,18111383456669963153ull},{16152901,11554056516029888111ull},{16153601,14102697559575163223ull},
		{16157303,10951036977490542007ull},{16161121,12068660979042357751ull},{16161923,13936597432397301953ull},{16167427,17741531859834789367ull},{16169077,13038897762986995439ull},
		{16172587,12923341570853700409ull},{16173133,12468959361471384367ull},{16173691,12146036035731849143ull},{16181381,17389980150980900167ull},{16181761,13632984658968284321ull},
		{16184771,12579003037333710127ull},{16185919,18017349281491722863ull},{16186981,16300711072026110783ull},{16187707,12837482707778126729ull},{16191941,14435333013673979377ull},
		{16194601,10362937015011578407ull},{16199899,14943059862662596097ull},{16201201,13083808953378894799ull},{16203571,10961371406875908433ull},{16203631,15948970413144688847ull},
		{16203851,11851486348839027743ull},{16213993,13617531092155742599ull},{16100213,16092742349020987151ull},{16100297,10748446445825061761ull},{16098127,13581925937697282097ull},
		{16098883,17001973141862761433ull},{16098931,18338048883043493801ull},{16099169,11445451093632964279ull},{16072711,11466372601071120199ull},{16076597,13435999004029409279ull},
		{16080049,18266526887928755321ull},{16081679,11868117613510431529ull},{16085071,14158058431764629761ull},{16086911,16826194113484414487ull},{16087829,14626742151491329369ull},
		{16091021,14224052887860439639ull},{16064149,13197622355391030409ull},{16065149,13545314040804294319ull},{16067243,14152269016994013583ull},{16068049,16067045133341942353ull},
		{16070969,15370375936060062839ull},{16071529,15059986833339178897ull},{16057751,17402936053714225153ull},{16056451,15488725481110429159ull},{16054043,12672311049187782367ull},
		{16052353,11593765511293358047ull},{16052657,11085431129434680449ull},{16050487,10218100740052053263ull},{16048763,14100978243368072207ull},{16045357,12183869854186459801ull},
		{16035809,11855169834318581681ull},{16035941,17649706665176130473ull},{16027681,16209706991529970753ull},{16026343,10440895312670202409ull},{16026499,14608723870843452887ull},
		{16022003,16542024904771148857ull},{15838057,13724050657344286793ull},{15798119,18033822787942121599ull},{15372727,13620902108656457471ull},{15370987,13141770251775333463ull},
		{16423567, 9593004739201446737ull},{16424743,11207409667480506167ull},{16426331, 9315521980684624207ull},{16427317,12920971770507553729ull},{16427401,16822696323471127217ull},
		{16431991,13793486024804669009ull},{16434511,13533131423401796863ull},{16438259, 9952502816461400807ull},{16438421,13236391347894754153ull},{16441151,18194162210171783167ull},
		{16446379, 9889326862010987471ull},{16421063,15295542430741533281ull},{16411141,14567378334050418241ull},{16408439,10288195248504974393ull},{16386497,10040647230145986479ull},
		{16379327,12344397890070085393ull},{16383739, 9942526727677974137ull},{16384727,12597569013851067049ull},{16369789,10288230960652346249ull},{16364419,10607814077757516457ull},
		{16359293,11028045969272017577ull},{16344319, 9803688218926567111ull},{16339627,10586347451730006521ull},{16323487,12699616391325608273ull},{16307677,10780482862846368239ull},
		{16286441,11747242053545138911ull},{16280959,10537253101166306807ull},{16269433,10520779020741875777ull},{16264579,10000450921799397911ull},{16263427,12056468544232052593ull},
		{16229383,10028147391258765553ull},{16218541,11886145592975848529ull},{16237721,11289182387241165217ull},{18202697, 9523705169798429639ull},{0,0ull},{0,0ull},{0,0ull},{0,0ull}
	};

	/* 65-bit factors. Only store the bottom 64 bits of each factor - 65th bit assumed == 1. */
	static const struct testFac fac65[] =
	{
		{16446217, 2580748063118626543ull},{16441037, 7159845698788165911ull},{16423243,16053932793878088265ull},{16422199,15449225178445266103ull},{12307619,  834960775198036465ull},
		{12891233,  320347219092137433ull},{13091369, 4490626336223492551ull},{13251437, 5252892907907759335ull},{13278611, 4992876320436398817ull},{14191367, 3043526892782259057ull},
		{15372433,  835012824499792921ull},{15378317, 1469384281496492841ull},{15381727, 3296686288473649015ull},{15716923, 1071681628997604121ull},{15792929, 4568661977477836713ull},
		{15829339, 1353718096095573831ull},{15857663, 1877275782840805977ull},{15896423, 2846280113165409217ull},{15389291,18328954321183659201ull},{15424001,14055059218732619601ull},
		{15649649,16271423290019634663ull},{15716923, 1071681628997604121ull},{15792079,14719270918611609657ull},{15792929, 4568661977477836713ull},{15829339, 1353718096095573831ull},
		{15857663, 1877275782840805977ull},{15888107, 9672885011805764433ull},{15896423, 2846280113165409217ull},{15896591,12753248453534549335ull},{15913669,10042894560178858561ull},
		{15919751, 9077968001905706863ull},{15935603,11440996883202164671ull},{15937421, 3477787277761589433ull},{15940453, 3293099948043389463ull},{15990151, 9384163689137796817ull},
		{16020359,15674564692213482777ull},{16020997,10583884050943532673ull},{16021231, 2457557263587737193ull},{16023079, 7172265904034801095ull},{16023647,12254780112882764065ull},
		{16026047, 2015612163892272583ull},{16030051,12636535017081930135ull},{16030981, 4533504886207341415ull},{16032113, 4098116656401037545ull},{16033373, 4283833442114036481ull},
		{16037731, 4669494584567097327ull},{16042031, 8521202797833889425ull},{16042363, 1118497044506213463ull},{16043689, 5061951072668619745ull},{16045877, 7034068819169950713ull},
		{16046413, 7970266257131337337ull},{16047763,17720298914808722185ull},{16049867, 2777504824160429671ull},{16051073,17305172545354635225ull},{16052317, 6141121158983034457ull},
		{16056541,10695684989098787847ull},{16061009, 1456724931068173687ull},{16063109,13596747992403972297ull},{16063357, 8295891058026308023ull},{16070227, 2132028069846281607ull},
		{16074001,  613796669972356527ull},{16078813, 6533829271585121673ull},{16085423,10209359921277170607ull},{16090609, 2161620649992862905ull},{16096469, 1554699406605092793ull},
		{16100053, 8795628605553802671ull},{16100347,13291493148042713257ull},{16103719, 1585997210388541833ull},{16109507,12512063892223428961ull},{16109749,  968325311857141351ull},
		{16113029,18313175825134571025ull},{16123907, 7411731869541221617ull},{16126067, 4236545548179355081ull},{16126601,13228754303985015511ull},{16135051, 5990895667432870231ull},
		{16135411,15090056596912858585ull},{16137103,10560319150004001961ull},{16141709,17519457444182672455ull},{16147013,11445706533097774785ull},{16147393, 2659601528506615945ull},
		{16148129,17675056835266093305ull},{16149409,  204949170576663745ull},{16149787,16731036664601428255ull},{16149803, 7545607839488943193ull},{16150331, 6874010104330448145ull},
		{16155731, 9207449049005699935ull},{16162171, 9369851092374283137ull},{16163359, 4539568180228208935ull},{16164581,18211837706550913441ull},{16165507,15412546995979766593ull},
		{16174409, 1732140531559079415ull},{16179661,10492475743208936665ull},{16180903,16145957810547426145ull},{16184957,15091206671754796143ull},{16186603,15907332645141087985ull},
		{16189127, 5212322745663667383ull},{16194487,10173479279066636175ull},{16195183,15192552222295211305ull},{16197113,13841445967322975943ull},{16197499,17050899974760590215ull},
		{16193159, 1385423280458214967ull},{16200641, 2828285506828385065ull},{16203211,11100172884046605975ull},{16205971, 9273740347421492193ull},{16206349,10694307907604074233ull},
		{16213033, 1614410328985344607ull},{16213187, 1954435271914117233ull},{16215149,16532972262340179657ull},{16215317, 1008121765686796233ull},{17801687,  128917458759517407ull},
		{17807753,  336494230971911497ull},{17716367,  905665796573663601ull},{17751211, 5618955195753508855ull},{17774759, 6014993229899159887ull},{17720089,13529342842575268383ull},
		{17760683,14990248056153767583ull},{17775391, 2350339510098510591ull},{17777197, 9571464417356251447ull},{17779403,18177477733292920041ull},{17779837, 7906895062697711601ull},
		{17789269,10001883951858619657ull},{17789957,18252033438277821393ull},{17820343,15700395625722743455ull},{17820353,15618585221939458585ull},{17822141, 3164553597118799223ull},
		{17829673,11147254248974845591ull},{17830871,11225984642974396225ull},{17835733,10023921494986403217ull},{17838259, 3260207741789404783ull},{17848801, 4875901499668317943ull},
		{17852519,15091062508870596217ull},{17852047,  601058353873004391ull},{17857373, 1701161678010384433ull},{17866621, 5208343099296284167ull},{17866657,13299976954651583865ull},
		{17869171,16676513047471408473ull},{17869783,  621259534838019577ull},{17870123,15084110248119306447ull},{17881901, 2826293090465457897ull},{17883293,13129524775288454065ull},
		{17893621, 5577207661761066993ull},{17898871,13731800934001310335ull},{17903773,15168446379627624537ull},{17903917,  840239117157541023ull},{17907991, 1108904181398829207ull},
		{17914537,14467964519448464401ull},{17924609,11950510395434416473ull},{17933621,14476051576170801127ull},{17933987,12271121888256658441ull},{17943683, 4871696868526692145ull},
		{17945779, 2390989063500577855ull},{17952059, 4526068326859465345ull},{17957671,11917441992759533751ull},{17955761, 7098876507611502201ull},{17960443, 1402663829241032233ull},
		{17968817,14222886584371031521ull},{17971001,15950977244893884273ull},{17972399, 3710008620325908985ull},{17972657, 7132236937769524687ull},{17975669, 7099626784541023537ull},
		{17979631, 4226380440331508463ull},{17979641,14785225336208575737ull},{17984581,  858523932063013273ull},{17987267, 6850516154583906681ull},{17987461,14388480591581056111ull},
		{17988371,12210936384520386513ull},{17994199, 2164882008197615161ull},{18005447,  166370812775332375ull},{18250433,  344598024120039225ull},{18224719,  553997798478189057ull},
		{18154817,   79872243127358095ull},{18150971,  655633122262579545ull},{18200599,   92076886106971825ull},{18284677, 1888915001773035865ull},{18051997, 1150367354656911321ull},
		{18238631, 1017245559490767655ull},{18206621, 1568022926158681023ull},{18100601, 2745906387390898953ull},{18245951, 2231815919872618561ull},{18014323, 2458848702076602991ull},
		{18023917, 2058241897646001985ull},{18110201, 2720723434949125423ull},{18282137, 2035603280846190463ull},{18133991, 2632171659342400255ull},{18123323, 3330516929914639263ull},
		{18006713, 3028904303953805257ull},{18229837, 3685053582537101961ull},{18287713, 4160915327054246911ull},{18053807, 4543935829736639911ull},{18290663, 4062712588739458377ull},
		{18076511, 4182270262765602793ull},{18066679, 4897645337609563137ull},{18072421, 5488276451463637903ull},{18144029, 5575221700433972071ull},{18144589, 5051459111074577343ull},
		{18151787, 5763204143979111753ull},{18035429, 6300514689716925561ull},{18224863, 6179587156579443145ull},{18262147, 6266978406726558697ull},{18287327, 6195008163268138447ull},
		{18210433, 6203752099699856671ull},{18050729, 6425811605110608777ull},{18143687, 6473267153150631561ull},{18174397, 6246898253762108191ull},{18062267, 6855361096834950297ull},
		{18292607, 6407061090330898495ull},{18248981, 7276207334850673095ull},{18207569, 7642254765211602895ull},{18091121, 8151237761253289881ull},{18054097, 8052096042537656761ull},
		{18200087, 8912314933991519977ull},{18055393, 8317264894231219935ull},{18249053, 8407382588101954711ull},{18189331, 8789539481715341863ull},{18043997, 8515722445328005785ull},
		{18011239, 8951373386839770463ull},{18298117, 8636556078317653257ull},{18271801, 8490243542019023553ull},{18202253, 8748336695715872857ull},{18100171, 8782994045353648191ull},
		{18191993, 8974531565168049591ull},{0,0ull}
	};

	/* Factors <= 96 bits: */
	static const struct testFac96 fac96[] =
	{
		{18276023,         1u, 9352652860056109297ull},{18169451,         1u, 9391223343761911353ull},{18101203,         1u, 9245198838244718175ull},{18200431,         1u, 9638047650792060207ull},{18153137,         1u, 9331979875586794647ull},
		{18286589,         1u, 9164964664217404903ull},{18087869,         1u,18404873023603575487ull},{18211181,         1u,10434605500782496975ull},{18211313,         1u,15746090072000275711ull},{18085237,         1u,10657076381559003585ull},
		{18210259,         1u,16355331429482797863ull},{18084967,         1u,12535841202704578975ull},{18084109,         1u,16470485288787225105ull},{18214087,         1u,10207338191440827513ull},{18214733,         1u,17740871572718924041ull},
		{18219479,         1u,18017792182604237361ull},{18066011,         1u,11376490360570509583ull},{18066007,         1u,11743936157345608143ull},{18242551,         1u,16695389546547233823ull},{18243733,         1u,13242634967295051207ull},
		{18051727,         1u,12764547214878403897ull},{18198319,         1u,14789209292635722871ull},{18252719,         1u,11949949204123386865ull},{18112553,         1u,14699169213035249007ull},{18188237,         1u,12547222997198167135ull},
		{18253273,         1u,15022424507268036615ull},{18177769,         1u,11181456191737830247ull},{18261431,         1u,12524685482980431153ull},{18263183,         1u,13717086022817448657ull},{18266477,         1u,13203156723265013793ull},
		{18165269,         1u,15387405357686244967ull},{18268543,         1u,10094150846373329745ull},{18134009,         1u,16150555121170358703ull},{18134147,         1u,12395351030116788801ull},{18134503,         1u,15773366615529206215ull},
		{18039589,         1u,12778558630672248943ull},{18276109,         1u,16390963948859540473ull},{18030241,         1u,15223465608795025207ull},{18285769,         1u,16970223144559381623ull},{18128549,         1u,15621768181131297471ull},
		{18285779,         1u,16993305172548993081ull},{18018739,         1u,14782732913885672961ull},{18295141,         1u,15005657306462735095ull},{18067589,         1u,13635840857860527775ull},{18295429,         2u,11468839311814080137ull},
		{18141763,         2u, 3092281768231311825ull},{18013091,         2u, 6772961738882249817ull},{18141511,         2u, 9576098065896122991ull},{18141127,         2u, 2247772876461344439ull},{18138203,         2u, 4695706118051975177ull},
		{18161641,         2u, 3950924079024657471ull},{18292093,         2u,12421322989569225951ull},{18123713,         2u,12125574039462479825ull},{18123709,         2u,10308047940655965639ull},{18173257,         2u,  207535002320717055ull},
		{18173983,         2u,14403605950085358951ull},{18120779,         2u, 9422223333804691761ull},{18019927,         2u,  408406707228848249ull},{18288797,         2u,17360156522995678599ull},{18177359,         2u,14832757638836506257ull},
		{18021973,         2u,13957432374640225095ull},{18025373,         2u,10098147461342295887ull},{18030193,         2u,15607091523248359911ull},{18118223,         2u, 2086356729639751937ull},{18185821,         2u, 1689334627499619465ull},
		{18117667,         2u,18215785349680460505ull},{18191837,         2u, 4493229489136679145ull},{18039271,         2u,16908805479784654401ull},{18281567,         2u,  933612760336845065ull},{18277937,         2u,10828438976824746849ull},
		{18039583,         2u,16417153962708385977ull},{18106591,         2u, 6626926712493143231ull},{18104287,         2u, 5723270436532623081ull},{18100177,         2u, 5071318343531010431ull},{18201467,         2u, 8160208643402298681ull},
		{18096061,         2u, 5937864839522586857ull},{18273883,         2u, 9773485756057249919ull},{18205183,         2u,15965092645879202447ull},{18272207,         2u,18262224097511217255ull},{18034481,         2u,13499269779109594391ull},
		{18206509,         2u, 8346049916247856479ull},{18093931,         2u, 9016815379266258047ull},{18270737,         2u,14523795906613507401ull},{18093689,         2u, 7580734199533821447ull},{18268721,         2u,11636683762416614271ull},
		{18092993,         2u, 3762951486187803561ull},{18089803,         2u,15886632766576700241ull},{18034843,         2u, 9087385776245663847ull},{18268303,         2u, 7107598341676734585ull},{18041711,         2u,10757635336355125415ull},
		{18080327,         2u, 4758087939326186009ull},{18264241,         2u,11059071541209885857ull},{18044431,         2u,12003164749400602311ull},{18259963,         2u,15572392068966635289ull},{18258577,         2u,10083568368046177095ull},
		{18076199,         2u, 1454254024310888471ull},{18067363,         2u, 6406596177417022745ull},{18050309,         2u,18266669341317591087ull},{18225367,         2u,  761543200176047729ull},{18066091,         2u, 4899820894457011847ull},
		{18233899,         2u,15827163809275823697ull},{18233951,         2u,12763352503716067857ull},{18050917,         2u,12630824986549901607ull},{18237679,         2u,  577537617363161615ull},{18051611,         2u,  926957969535303017ull},
		{18051823,         2u, 7818658096538148999ull},{18248603,         2u,16682557782845116569ull},{18064201,         2u, 4069052049914747889ull},{18060871,         2u,11707201997664612815ull},{18243989,         2u, 6890936471658773391ull},
		{18248441,         2u,17190543255548706647ull},{18246433,         2u,12208236782114945297ull},{18056369,         3u,17384615928981125225ull},{18239717,         3u,13146163309434854663ull},{18239423,         3u, 9830331743268882449ull},
		{18064247,         3u,12694290879965764249ull},{18051413,         3u,14413895596060013105ull},{18250439,         3u,10025619183380103271ull},{18237281,         3u, 9125012626367750681ull},{18224879,         3u,11767560264583516825ull},
		{18255343,         3u, 5870725649191146911ull},{18256097,         3u, 3190651672811461271ull},{18221701,         3u, 3582478237908082991ull},{18219983,         3u, 8327348782275241889ull},{18050233,         3u, 6535190184551801743ull},
		{18261623,         3u,17086528894147714391ull},{18048889,         3u,14630863141546358215ull},{18078727,         3u,15550160336321956111ull},{18217873,         3u, 3021804603112513103ull},{18082877,         3u,10987147732897659511ull},
		{18086017,         3u,12672060712653398353ull},{18088957,         3u, 2906408230830983393ull},{18208621,         3u, 9127697742932317439ull},{18207347,         3u, 6623005940415687023ull},{18206281,         3u,11960252621902730281ull},
		{18271933,         3u,12291953682343228271ull},{18205601,         3u,16600095605189677529ull},{18203707,         3u,18008003865578937049ull},{18039629,         3u, 9427695590083594375ull},{18198977,         3u, 3076193691622372985ull},
		{18110383,         3u,  185345134978204289ull},{18196499,         3u,11880812732795403521ull},{18111229,         3u,11071059034249992329ull},{18035989,         3u, 5539705418955744265ull},{18183743,         3u,11415352866482141719ull},
		{18028897,         3u, 3716387045703399295ull},{18285781,         3u, 9357102466781895559ull},{18180077,         3u,15536479403169204695ull},{18022649,         3u, 5654606217092758855ull},{18118489,         3u, 6394983796367039201ull},
		{18287957,         3u, 8752778334904342079ull},{18176321,         3u,17471759203966653145ull},{18175529,         3u, 2271464572669811305ull},{18163883,         3u, 3719255206030166033ull},{18019699,         3u, 4310391407591765215ull},
		{18151579,         3u, 1595301140365420159ull},{18142301,         3u,12867206532962105191ull},{18143519,         3u, 2481422238311117321ull},
		{ 7244507,  25571934u,17645344339951798897ull},{ 7414637,       164u, 4116711638593590185ull},{ 7723447,      5420u,12562746707691010049ull},
		{ 7818977,      1353u,  659102583034765273ull},{ 8029633,       831u, 7916220548900207543ull},{ 8053889,   2103436u, 1167145018735557081ull},{ 8086453,      1227u,17541595206117360217ull},{ 8095291,      1704u,13708852579508485207ull},
		{ 8168357,     87810u, 6610049516710328711ull},{ 8184557,        33u, 2763581858425117679ull},{ 8243537,       531u, 5525174834371803241ull},{ 8259871,        14u,  796855330669004183ull},{ 8272661,       380u,14241720166580408009ull},
		{ 8273437,  25987538u,14814742953278716353ull},{ 8283053,       161u,13929456041379261263ull},{ 8297321,   3034093u, 8730546825436233825ull},{ 8314843,   2684125u, 6454422580796036649ull},{ 8333579,       854u,13655594228639799257ull},
		{ 8361211,        12u, 8939076096818105929ull},{ 8390441,       595u, 4193551430717959153ull},{ 8422597,      1366u, 7870914753859973521ull},{ 8427803,      1474u,11450161366987292943ull},{ 8444941,      2885u,11827496755524969729ull},
		{ 8461697,        90u, 5398489150994146721ull},{ 8484347,         6u,12630454963470541663ull},{ 8489857,         8u,17355799175298876081ull},{ 8493427,       805u, 9747852211561597759ull},{ 8529877,       136u,16465808959478947065ull},
		{ 8592989,      1038u, 8509600750746547649ull},{ 8620109,         4u, 9079157166504874159ull},{ 8622461,         5u, 2437973634125785521ull},{ 8654389,         8u, 9482848212441108929ull},{ 8654579,        21u,11899068713858479361ull},
		{ 8656603,        93u,15062407632802667551ull},{ 8658217,        80u, 6325248917681739887ull},{ 8668423,        28u,18320769443016069721ull},{ 8674759,         7u,18284948339037548257ull},{ 8676287,        14u, 3843963214618658969ull},
		{ 8678947,      5396u, 2636802174995602407ull},{ 8681021,       401u, 4998736748668298991ull},{ 8681579,        30u,16135213582861992497ull},{ 8683729,         8u,11293259574337184559ull},{ 8688011,       145u, 9578503463191650391ull},
		{ 8692877,     36661u,18428023068529200991ull},{ 8697607,        17u,  870550676082897689ull},{ 8704219,     27999u,16201955968424701817ull},{ 8711159,        17u,11366350694546647641ull},{ 8719301,        88u,13672547084272167169ull},
		{ 8722339,      7423u,18156437144620420569ull},{ 8723123,    217954u, 6973216771046930049ull},{ 8725657,        63u, 2916601161951227239ull},{ 8725841,        25u,13195469447575389151ull},{ 8738729,         6u, 8170383313133995223ull},
		{ 8740939,       240u, 4617356654063117857ull},{ 8747819,    108516u, 9367350152656600871ull},{ 8749571,         9u,15657372839554601087ull},{ 8751563,         5u,13841889794965422657ull},{ 8755027,       593u,16519620384372861863ull},
		{ 8756101,      8284u, 6072693151654549537ull},{ 8763817,       119u, 6048599338562527617ull},{ 8767069,    257333u,15121360214969010561ull},{ 8776997,        64u,14339583161777897937ull},{ 8789447,       215u, 3202800343531181993ull},
		{ 8799389,       709u, 1702544524884741217ull},{ 8799529,     22022u, 3369348266587752401ull},{ 8800037,        17u, 1648884270309857487ull},{ 8801491,      3693u,16652078850798618551ull},{ 8802329,       419u,15755726911414877649ull},
		{ 8808773,       440u, 2473070962046579177ull},{ 8815151,        52u,  819707353106726625ull},{ 8816747,     92343u,16904660106867077831ull},{ 8823883,    520923u, 3776175324622247383ull},{ 8824301,       439u, 8808290111578886823ull},
		{ 8827319,   9331025u,10299995606463506351ull},{ 8839343,        93u,10232357004734229929ull},{ 8845349,     17999u,17028006110880085593ull},{ 8845399,       480u, 5232264661915708753ull},{ 8851631,       881u,11375193854275230591ull},
		{ 8852323,      3529u,13976988789038676439ull},{ 8879971,     55760u, 4065954677724111201ull},{ 8885839,    189157u,13972705208713530009ull},{ 8887667,     15650u, 3479161486544600081ull},{ 8891479,       281u, 3908734036550545881ull},
		{ 8892001,    399980u,  348160936584190151ull},{ 8895067,       659u,12293902350439178087ull},{ 8896403,    281473u, 4911135064261999521ull},{ 8907659,     28045u,14784606591196077103ull},{ 8910043,       821u, 5656531726894273265ull},
		{ 8914519,       949u, 4686244932662218297ull},{ 8925463,  34406392u, 6947221817440081257ull},{ 8928847,    280991u,18128549402387363145ull},{ 8941447,       170u, 7578823934664030161ull},{ 8942761,    285889u,12419432609440032345ull},
		{ 8943461,    268039u,15846513700731858799ull},{ 8947891,      1735u, 9265596559543333297ull},{ 8955143, 101273010u,12253893124535158577ull},{ 8980789,     22537u,13426157623604500687ull},{ 8982371,       101u,14022829103709041663ull},
		{ 9009229,     89356u,15359747832206463841ull},{ 9023117,      1296u, 9569964735123059105ull},{ 9331061,       203u, 1005489040573919343ull},{ 9360067,      7440u, 1016920852914327511ull},{11836397,        76u, 4753937900335225801ull},
		{12342461,      3185u, 1753345721477568209ull},{12682547,   4085607u,16926237622668427889ull},{12702857,     55435u,15473514712868330607ull},{12999053,   1235292u, 3762487385164613785ull},{14498369,    128237u,14526323552203604241ull},
		{15165389,       485u,  330179403340003319ull},{15190393,     13872u,11887173197900552719ull},{15267589,        74u,14963262145345516425ull},{15331573,     49730u, 4408178729149087001ull},{15421487,       921u, 8877756807240402497ull},
		{15626909,  11906539u, 4417661925555319825ull},{15729583,       186u,10717054419563574223ull},{15729827,1057892912u,14816318765732916257ull},{15829861,     19825u,15865309391356950409ull},{15904423,       110u, 4238645735120536409ull},
		{15983707,        48u, 4357300712211145471ull},{15991193,      3046u, 3680186924956910097ull},{15997109,       308u,15794942471928637713ull},{16051547,     11155u,15864453969212219103ull},{16129213,       392u, 3754198172882755785ull},
		{16131979,      6827u,10576842754565059055ull},{16172621,    191569u,  891829992192399319ull},{16204523,  18537874u,13853273991470839569ull},{16210483,        64u,11178113142365390047ull},{16218907,      3470u, 9365149503113345247ull},
		{16226809,      1100u, 7659583808777621319ull},{16296349,     74952u, 6789913543149950497ull},{16322297,       748u, 8822692284702673065ull},{16364057,       268u,10431176301742662465ull},{16377743,      3176u, 5972801908074189743ull},
		{16406363,     30172u,  253845389692387185ull},{16416161,     84184u, 8026903278674309185ull},{16444163,    123743u,13602749018509000529ull},{16445119, 199993173u, 2826719993506082993ull},{16462993,      1933u, 2246545941595562751ull},
		{16465439,    767792u, 7421856042576531887ull},{16468129,    672932u, 9193735353107684049ull},{16503173,      2024u, 9443492740464039183ull},{16521053,      4172u, 4215545972090492199ull},{16544719,   3532287u,15490834954328089129ull},
		{16608113,       993u,11973891496836029831ull},{16658221,    994392u, 9265003897988786177ull},{16662589,      5583u,10877104196614353761ull},{16669259,     37695u,14727883460246356457ull},{16685437,   9776194u, 6889969512162125377ull},
		{16723717,    212092u,14906504205635945761ull},{16727479,     14410u,18068882455710331257ull},{16785413,    129671u, 9903178178510980001ull},{16792663,      9703u,11105483931030878809ull},{16800587,     11130u,13650391737015148049ull},
		{16804847,   6500829u, 3533341371541809833ull},{16808453,      4936u, 7844623794952651617ull},{16809391,     29703u, 9869185788127161889ull},{16817747,   4387352u, 2015829708477243887ull},{16819343,    227351u,14577617651386377761ull},
		{16820549,  29259736u, 2579164402117877625ull},{16825007, 390682869u, 9671153211854428993ull},{16825889,      1645u, 5034090624360750817ull},{16826959,    394522u, 4262342457128545047ull},{16832939,   2283480u, 3499229584108421473ull},
		{16843219,1740637150u,16678575536200532911ull},{16843987,    892167u,11320504716025434577ull},{16861753,     27509u, 4966077503304358433ull},{16864429,   3472340u, 7383710753692858103ull},{16865557, 141107518u,12657461798830290009ull},
		{16872847,      7042u, 5664463976168682217ull},{16876267,    768500u, 2386605663683715839ull},{16877227,     26909u,16828458807433451793ull},{16878749,    347420u, 5530942263660718719ull},{16892789,     37499u,15689282913842113409ull},
		{16895803,   1532721u,18305119409047103975ull},{16897009,    317299u,   35208741571512609ull},{16900309,      2472u,13474962507039928007ull},{16910191,    170146u, 5170061300924029473ull},{16928419,      1489u, 5006545141137940057ull},
		{16930393,   9582022u,11727071280078615841ull},{16937773,      3510u, 9267789279716192833ull},{16938461,     77244u, 4261887363890383759ull},{16942561,    333713u,16416959992066943223ull},{16950361,      2580u,11177105512311418417ull},
		{16969409,     39842u,14393933843859339287ull},{16979441,    505755u,16434730466875831753ull},{16981427,     28066u, 9296044504676969833ull},{16983727,  94240809u,17752094683956384025ull},{16983983,     28059u,16091607843728445223ull},
		{16995779,      6661u, 7830143707771831545ull},{17025413,     10724u, 8148147940903146705ull},{17026687,     31859u, 6811989873351804369ull},{17034133,     20487u,17357576493083550241ull},{17039059,    122645u,11496188035198294967ull},
		{17048029,    285247u,13305518687973938281ull},{17056447,   2606122u,12574870762596486535ull},{17083237,   8461215u, 9905576412463209257ull},{17083777,     18430u,11428865434586521009ull},{17087557,     37215u,14875832505057766609ull},
		{17095889,   1323377u, 3717220050156882191ull},{17097389,1760731413u, 9843676629243088873ull},{17105299,     81371u, 1929162103058421135ull},{17109713,     51459u,17280464114564148169ull},{17110757,   2046067u, 8067475805035482625ull},
		{17112113,     52542u, 1517105784283888919ull},{17112191,     24884u,15515225620652684223ull},{17113253,      7250u,15583958528602828257ull},{17114791,     13155u,15934260513033726703ull},{17140177, 819404853u, 7737165812083468943ull},
		{17154157,   2917808u,14475130768968748289ull},{17168243,      1189u,14031023330502092233ull},{17174827,     20877u, 3116423579334084745ull},{17191459,    164012u,11124925933076103519ull},{17196229,    452235u,11155442872175691889ull},
		{17199473,     51825u, 6083166130595396831ull},{17213509,   1022179u,12911928712002520737ull},{17220101,   3214549u, 7363134224170851673ull},{17227849,    172183u,10847800035774997255ull},{17238307,  12542043u,15663835937396410441ull},
		{17251489,2144117919u,15480179807909042479ull},{17253517,  12309654u, 6025235993786279423ull},{17257879,    161418u, 1382566104163313935ull},{17260589, 115175336u,10283224490478819833ull},{17264011,   1744457u,  994697667365615745ull},
		{17268703,   2063251u, 9350765217636640455ull},{17269621,  13735949u,  673788709708729265ull},{17270191,    259556u,13644816076166641193ull},{17277367,    378545u,10258283237536366089ull},{17295857,    164529u,12996504031838402257ull},
		{17297321,    136045u, 3477326686230228009ull},{17300057,    485742u,10134593588474735065ull},{17309261,    131275u, 6030008496201936663ull},{17326747,   1611645u, 1921630189938798817ull},{17358763,   3232800u, 4928905537991785441ull},
		{17359063,  35383704u, 2015083763123199095ull},{17362099,     53690u, 9683541530822602193ull},{17385503,4046742644u,16856501793554568897ull},{17387893,  41374286u, 2560656520549446921ull},{17395817, 159852898u,16792033592198659863ull},
		{17427923,    188981u,  532633914835864385ull},{17433629,    695925u, 3505119555206483393ull},{17444443,    513163u, 5445979551755147943ull},{17450053,    157812u,18415231095804314545ull},{17456651,    551552u, 3880353390263834249ull},
		{17467139,    211059u,10062518427716833465ull},{17477639,    264827u, 6507519522524416335ull},{17503567,    319478u,15607288692565636353ull},{17506249,   7246235u,10929482532834898487ull},{17518877,   8867104u,11570050222122965689ull},
		{17527283, 136813947u, 3326024563062685825ull},{17536823,    440352u, 9878707771636535647ull},{17539007,   4354617u, 4406481822187523599ull},{17540879,    726756u, 1118113451897253593ull},{17555399,  35153812u, 4507443726068176209ull},
		{17566609,  21653383u, 7399444876854645393ull},{17569711, 479166769u,11868486932669699833ull},{17571031,    484527u, 7060215751726447079ull},{17616943,    114090u,14738812321054635817ull},{17622817,  13690398u, 4811636227715074249ull},
		{17647373,    103263u, 3189089353926248513ull},{17652469,   1244343u,  141431592584913433ull},{17675893,   4077389u,13651439017267265249ull},{17679919,   7872193u, 3894559783103852031ull},{17698939,     47810u, 7782021279990355767ull},
		{17711143,    640279u, 5303785660976639535ull},{17732801,   4103871u, 4583035766799531017ull},{17739133, 130747716u, 1947030475661309305ull},{17739583,     69157u,  539914343514113919ull},{17746877,   6306926u,13250449299753722625ull},
		{17783203,    128254u, 9322981120069197199ull},{17797207,    117994u, 6024425248459124193ull},{17807701,  16601701u, 2797681640543443633ull},{17814431,     59907u, 3165706124645613559ull},{17833331,    108749u,10677366860900144129ull},
		{17835473,    865553u, 8821789166368052975ull},{17841821,  16595068u, 2785009705636697065ull},{17858671,     83788u,11636762661956212849ull},{17860541,    127880u,11679412360494356457ull},{17871673, 899827073u, 4365981991822767335ull},
		{17883197, 171007919u,14112849719432819969ull},{17891383,  15314611u, 5494386947721296607ull},{17901223,  26483927u, 8759360566729963809ull},{17907917,   2699547u,15287649357901403887ull},{17920373,    117967u,14284930551950649009ull},
		{17941151,    135102u,13697963633382258847ull},{17953391,   4407462u, 3856268332031058257ull},{18015407,    823035u, 3863124271074440977ull},{18017383,   1360055u, 7566698478337249511ull},{18120731,    223471u, 3508167879733895305ull},
		{33227807,  14922325u, 2838567728392815481ull},{33233503,  12807462u, 3334091319432416681ull},{33241399,    166492u,12812515124938083865ull},{33250067,2182275258u, 8923029501170211169ull},{33251227,   6911594u,13590065507670693809ull},
		{33256609,   1818244u,  220871972264494263ull},{33259153,  38814254u,16386977130529408193ull},{33268253,  27991294u, 3898646068209270567ull},{33277301,    683360u, 4806541503703691279ull},{33280787,    282030u, 9924364295782824137ull},
		{33282257,     79056u, 8075902570930756103ull},{33284753,    111827u,15449457299209774881ull},{33286807,  81756638u, 2255231334031845305ull},{33290197,    189083u,14424443831930143785ull},{33291679,    367547u,18387530411978866559ull},
		{33299443,    776963u, 2636922682980779825ull},{33311869,    186338u, 1874415908399668103ull},{33337613,    323616u, 3695590210606875881ull},{33340963,     96949u,11960300797586306719ull},{33344947,    205119u,12785072524810844153ull},
		{33357251, 120482483u, 5734238336333966079ull},{33360631,    124712u, 6837598985057705985ull},{33364561,    247352u,17266053889495344551ull},{33369911,   6119593u, 2157811649735073519ull},{33379673,    500668u, 1793898280018450369ull},
		{33394931,    504443u,12345311626227159743ull},{33396289,    389902u,15587540931804441849ull},{33396457, 328283329u, 3027562459369760823ull},{33399761,    279642u, 9658553917939196047ull},{33406151,  57459294u,12082998895638046327ull},
		{33406621, 125212997u, 5566884921004692039ull},{33408533,    120922u,12235980571743216255ull},{33408943,   2787233u, 9527286207438248745ull},{33411487,   1062745u,12865415306884302993ull},{33422659,    403467u, 6257350676364808409ull},
		{33423319,     57634u,17459695061727397089ull},{2147483647,      13u, 2749942686469094193ull},{19016461,3264525660u, 8603927029340062289ull},{0,0,0ull}
	};

	/* Factors > 96 but <= 128 bits. If desired, we can construct more test factors
	by multiplying together a 63/64-bit factor q1 of M(p1) and a 65/64-bit factor q2 of M(p2)
	and checking whether q1*q2 divides M(p1*p2).*/
	static const struct testFac128 fac128[] =
	{
		{     695,   12240518780192025ull, 1654746039858251761ull},
		{     845, 2923447923687422893ull,  353773459776294223ull},
		{    1113,     128099917305337ull, 7733695761441692271ull},
		{    1145,   10811609908058563ull, 5349936413307099433ull},
		{    1149,        700245770430ull,  701890237964104231ull},
		{     733,  756146046438660814ull, 7804835620876695225ull},
		{     737,  106450884062962221ull,17050154159176967743ull},
		{     871, 7448657723978021346ull,15223106393317212577ull},
		{     947,     644719741813452ull,16055621295463638505ull},
		{     953,      44696312570505ull, 4961431981940124743ull},
		{     989,   99970972632587991ull, 1738540175825943815ull},
		{    1081,         67677680549ull,13887741953162944095ull},
		{    1091,    5287390011750720ull, 2894679571106043497ull},
		{    1097,      11129117045170ull,10375766809019373543ull},
		{    1099,       1551337752834ull, 8321741389535251703ull},
		{    1133,  133834206206032981ull, 6586095673132787791ull},
		{    1141,       5747037125100ull, 2460710484528304153ull},
		{    1181,      10824073357153ull, 7361144750966677159ull},
		{    1189,   32559650929209964ull, 8212830436061989903ull},
		{   27691,   94004235929829273ull, 4235226679561594903ull},
		{  319057,        103337218078ull, 8676403300852410079ull},
		{17363977,      62897895526806ull,14211535226588354713ull},
		{10624093,          5492917609ull,14854696485656401105ull},
		{10698673,          5799457823ull,10285356664749312993ull},
		{20799431,          4303087381ull,16578386512849109713ull},
		{33652757,          5202063708ull,18263664019678288919ull},
		{21823211,          7785579841ull, 7607475409566672241ull},
		{22330859,          7593776864ull, 5630449305759171207ull},
		{11808917,         20308449831ull, 9058738039473012457ull},
		{20090969,         15531431134ull, 5034609389988515233ull},
		{20313967,         18216394609ull, 8291172543411688687ull},
		{20544481,         16259503442ull,15859685870849762975ull},
		{22217387,         20551559047ull,11995354231649723881ull},
		{10207999,         28364424832ull,15122069645900159367ull},
		{19964723,         34441477586ull, 9636073161914837921ull},
		{21145199,         30977655046ull, 1304857345634219175ull},
		{22030163,         43144178324ull, 4788416424359163737ull},
		{33562153,         45963786472ull, 2258783450670948535ull},
		{33693587,         66325700032ull,15262466751214122975ull},
		{11865241,         57210216387ull, 3082735332820781609ull},
		{21801929,         80355238912ull,15689518004012743009ull},
		{19951201,        109346652057ull,10819675441336938065ull},
		{20616781,      17534809723250ull,10329047311584913071ull},
		{20648443,       1221873279710ull, 2595613477835803991ull},
		{21250771,      12549422209078ull, 8612165677489771129ull},
		{21547787,        112416184026ull, 9015544550402598895ull},
		{21675733,        142220976614ull,11385509628023387489ull},
		{15714269,      14320762091913ull, 2773697912020767049ull},
		{19687561,       1996508583829ull, 7515490546312285159ull},
		{20152333,        365842230851ull, 2388855518206098663ull},
		{20510053,        261078947686ull,  465403687781705377ull},
		{20759821,     199835753775288ull,17079803649869853575ull},
		{20989043,        202355339943ull,15105677628487752455ull},
		{33713123,      18738454648009ull,16692905930976531153ull},
		{20542751,        412571049040ull,18170931828058363183ull},
		{20812849,     534505286298455ull, 2216600112648316881ull},
		{0,0,0ull}
	};

	/* Factors > 96 but <= 128 bits, with p > 64 bits - most of these are from my Jan 2003 runs of primes near 2^89: */
	static const struct testFac128x2 fac128x2[] =
	{
		{33554431ull,18446744073709551175ull,      30899672449023ull,18446744073303442655ull},
		{33554431ull,18446744073709551295ull,      85098334519295ull,18446744072895454529ull},
		{33554431ull,18446744073709551513ull,  430360347665235967ull,18446742752658555745ull},
		{33554431ull,18446744073709551513ull,  259661119604391935ull,18446743276643598623ull},
		{33554431ull,18446744073709551513ull,  293843670505881599ull,18446743171715500217ull},
		{33554431ull,18446744073709551567ull,   12593691025735679ull,18446744055318810857ull},
		{33554431ull,18446744073709551595ull,            67108863ull,18446744073709551575ull},
		{33554431ull,18446744073709551595ull,        631158865919ull,18446744073709156607ull},
		{33554432ull,                  89ull,      16384159383552ull,            43457455ull},
		{33554432ull,                 705ull, 7006880245689090048ull,     147219019329871ull},
		{33554432ull,                 741ull,        882615779328ull,            19491265ull},
		{33554432ull,                 741ull,     220386851553280ull,          4866917641ull},
		{33554432ull,                 767ull,     460834488713216ull,         10533930447ull},
		{33554432ull,                 837ull,    3613005073874944ull,         90124763455ull},
		{33554432ull,                 837ull,    1504315717976064ull,         37524469375ull},
		{33554432ull,                1059ull,            67108864ull,                2119ull},
		{33554432ull,                1275ull,          4898947072ull,              186151ull},
		/*{33554432ull,                1275ull,    1096248325046272ull,         41655201151ull},*/
		{33554432ull,                1337ull,      16333760626688ull,           650830209ull},
		{33554432ull,                1337ull,       1481763717120ull,            59041921ull},
		{33554432ull,                1521ull,   19343955296518144ull,        876848578633ull},
		{33554432ull,                1547ull,          2147483648ull,               99009ull},
		{33554432ull,                1917ull,    1124806032359424ull,         64261351945ull},
		/*{33554432ull,                1917ull,    2192593957945344ull,        125265199465ull},*/
		{33554432ull,                1917ull,         22749904896ull,             1299727ull},
		{33554432ull,                2097ull,      34829164871680ull,          2176665031ull},
		{33554432ull,                2585ull,      37028188127232ull,          2852614711ull},
		/*{33554432ull,                2585ull,    1096267786616832ull,         84455377711ull},*/
		{33554432ull,                2661ull,          2080374784ull,              164983ull},
		{33554432ull,                2675ull,           805306368ull,               64201ull},
		{33554432ull,                2729ull,      42057326395392ull,          3420544975ull},
		{33554432ull,                2729ull,       4876868255744ull,           396638319ull},
		{33554432ull,                2907ull,         22615687168ull,             1959319ull},
		{33554432ull,                3045ull,    1301649700159488ull,        118122200281ull},
		{33554432ull,                3045ull,         99321118720ull,             9013201ull},
		{33554432ull,                3155ull,      26011932557312ull,          2445806481ull},
		{33554432ull,                3159ull,        413994582016ull,            38975743ull},
		{33554432ull,                3507ull,        250450280448ull,            26176249ull},
		{33554432ull,                4155ull,   62084915730055168ull,       7687891270471ull},
		{33554432ull,                4451ull,          7851737088ull,             1041535ull},
		{33554432ull,                4485ull,        434328567808ull,            58053841ull},
		{33554432ull,                4745ull,         82678120448ull,            11691681ull},
		{33554432ull,                4745ull,         71672266752ull,            10135321ull},
		{33554432ull,                5121ull,        143814295552ull,            21948607ull},
		{33554432ull,                5247ull,            67108864ull,               10495ull},
		{33554432ull,                5411ull,     544322411823104ull,         87777631593ull},
		{33554432ull,                5499ull,    1739631741632512ull,        285096017935ull},
		{33554432ull,                5735ull,      10563740499968ull,          1805515641ull},
		{33554432ull,                5837ull,       7317214986240ull,          1272874591ull},
		{0ull,0ull,0ull,0ull}
	};

	/* Factors > 128 but <= 160 bits. If desired, we can construct more test factors
	by multiplying together a 64-bit factor q1 of M(p1) and a 96-bit factor q2 of M(p2)
	and checking whether q1*q2 divides M(p1*p2).*/
	static const struct testFac160 fac160[] =
	{
		{     629,       133ull,11545660419510266595ull,15875370168207932041ull},
		{     631,      1394ull,15571349859840161706ull,  509892144742137431ull},
		{     673,    121320ull, 4492854135134704005ull,14226674137430228263ull},
		{     695,2649519282ull,14842833464112563611ull,10174116463236461383ull},
		{     731, 655903171ull,17652352551621896287ull, 7660429456444636239ull},
		{     805,1083827012ull,18314245293386716597ull, 2219421057460140527ull},
		{     877,  13161208ull,18225246095436784582ull,12343089078196252631ull},
		{     957,      4730ull,14663183769241509326ull, 8097149896429635207ull},
		{     967,    215159ull,  881920578744577810ull,17184239148975426263ull},
		{    1017, 212724356ull, 9900144438119899815ull,17733134473107607967ull},
		{    1033,       261ull, 5238930328752646394ull, 2803405107698253561ull},
		{    1087,         1ull, 4415476118538293365ull,16346425147370540471ull},
		{    1087,     70130ull,11905462972019801043ull, 6167785434693019223ull},
		{    1131,   5800574ull,18429773635221665090ull,17951008765075981215ull},
		{    1157,  22381525ull,14500669099417213747ull,15903397166638806257ull},
		{    1283,        14ull, 3291757557782450881ull, 3893270457587058239ull},
		{    1319,      1552ull, 1390029428449091172ull,14288981644299514807ull},
		{    1483,      2674ull,14802171160149427175ull, 5085420234315110585ull},
		{    6659,       664ull,14291576310931480037ull, 4949688733053552967ull},
		{    8191,    617742ull, 6334326874596939334ull,11405337619840706193ull},
		{18031451,      2122ull, 5198971222801411122ull,12425019173815339143ull},	/* Note: composite factor! */
		{0,0ull,0ull,0ull}
	};

	/* Factors > 160 but <= 192 bits. We can construct more test factors by multiplying
	together smaller factors of M(p) with multiple factors, or for exponents p1, p2, p3, ...
	and corresponding factors q1, q2, q3, ... , checking whether q1*q2*q3*...
	divides M(p1*p2*p3*...). */
	static const struct testFac192 fac192[] =
	{
		{     677,     157590042578912ull,10558642444782195772ull,  329809049266961143ull},
		{     773,       9118322195022ull, 1933308633079010416ull,17814616685598394119ull},
		{     971,      70286054459973ull,17012949627558354271ull, 3547755741880899889ull},
		{     997,  492416983078691417ull, 8040689323464953445ull,16007877010440112335ull},
		{    1001,         59364131986ull, 9565712986615012496ull,10050950882119470361ull},
		{0,0ull,0ull,0ull}
	};

	/* 256-bit Factors are easier to give in character-string form: */
	/* EWM: These are from my April 2006 shakedown runs of the P4WORD functionality -
	ran ??? 64-65-digit test exponents up to k = 10^10; ??? had factors below this bound,
	compared to ??? predicted by theory (Dickman's function).
	*/
	static const struct testFac256 fac256[] =
	{
		{"1000000000000000000000000000000000000000000000000000000001059"			,"40000000000000000000000000000000000000000000000000000000042361"					},	/* k =          20 */
		{"12160287649628674460477464915995054973742562690104903778198683593"		,"543592246870442485937175551111623340804481341938942752102988291735322287319"		},	/* k = 22351126163 */
		{"20992192221842725502542568876717904946016534668049886272327917860857843"	,"41984384443685451005085137753435809892033069336099772544655835721715687"			},	/* k =           1 */
		{"24247014121478057345510500801908699603302763478708108175450119307"		,"2079083331892761004876676951418337621569030224230467189523407626117207889809"		},	/* k = 42872976472 */
		{"3082533446850352619311881710100031378387528865875332083814206171"			,"6165066893700705238623763420200062756775057731750664167628412343"					},	/* k =           1 */
		{"32046927906821207388377814233562823608963208068222468012248261177"		,"192281567440927244330266885401376941653779248409334808073489567063"				},	/* k =           3 */
		{"32046927906821207388377814233562823608963208068222468012248261177"		,"7261513394406617382132528927183000201554973316178529026895333500096431"			},	/* k =      113295 */
		{"3444030707469211201913020330380197621101100449293215160842444859637669"	,"53389364027187712052055641161553823522309259164943421423379580214103144839"		},	/* k =        7751 */
		{"3600113305305488204665213841469519415116094330572703657595919530921861"	,"1605650534166247739280685373295405659141778071435425831287780110791150007"		},	/* k =         223 */
		{"3852254995466672782398645659611635488623057745649803559363456817432411"	,"22788707831582286845380020155651359827337650244785629920055214225748565104481"	},	/* k =     2957840 */
		{"3873455283316355076479185358932261854896321329330898570642046752590709"	,"2921297999392661936999377930740968974773127205440094407601101388055871276457"		},	/* k =      377092 */
		{"4088350865739177150968288747826569959957449066175834413752239709"			,"532990125664685046817433867476654272539732719859211180852051986382913"			},	/* k =       65184 */
		{"41927056387293174872332083760112302991136793862708943879936201629"		,"586978789422104448212649172641572241875915114077925214319106822807"				},	/* k =           7 */
		{"53710507922796892589235420199561121290219608640344181598136297747713099"	,"107421015845593785178470840399122242580439217280688363196272595495426199"			},	/* k =           1 */
		{"54973742562690104903778198683593814657412680492564879855614537234786733"	,"769632395877661468652894781570313405203777526895908317978603521287014263"			},	/* k =           7 */
		{"5509792592309907965473761255176567513575178296664547791745011299"			,"742776869444172678136618913571387191947269048779332840473151581151737887"			},	/* k =    67405157 */
		{"570658748822569815793678976697422057505968344086973502014102067"			,"322107495328491256282531776450837995333351643082236449882652963072723913"			},	/* k =   282224268 */
		{"62735676303544776280350450777235547105859548702790814356240145171"		,"19573531006705970199469340642497490697028179195270734079146925293353"				},	/* k =         156 */
		{"62749567351885752724891227938183011949129833673362440656643086021"		,"6902452408707432799738035073200131314404281704069868472230739462311"				},	/* k =          55 */
		{"6402474964732639141992726042699227967823547816360093417216412199"			,"59547637466852043611708058111909725657028150812842162510646420336832110759"		},	/* k =  4650360821 */
		{"7195429162991930645537799140373404328752628889639958794757291746426357"	,"957164768977838582192020192849031737427989705415465878713793977276619713569"		},	/* k =       66512 */
		{"7095890455635792122103334669749923563025494780249011419521238281"			,"93538027986191011753566157616643492407802072193242468532128963020143"				},	/* k =        6591 */
		{"83011949129833673362440656643086021394946395224737190702179860943"		,"2473258012374264464160556924024104921441032899325819859780746776935743"			},	/* k =       14897 */
		{"85102283345085048608250393021332197155184306354550076682829493041"		,"23658434769933643513093609259930350809141237166564921317826599065399"				},	/* k =         139 */
		{"9104140792886215078424516709087000699282120660418371806535567252532567"	,"207009953348646758453216660931220221900276859576592938137005728188085508447"		},	/* k =       11369 */
		{"9729971208443357326548938239119325974636673058360414281388303203"			,"215547993800818444194894669517580993600170370441819907413109392526239783"			},	/* k =    11076497 */
		{""	,""		},	/* k =             */
		{""	,""		},	/* k =             */
		{""	,""		},	/* k =             */
		{""	,""		},	/* k =             */
		{""	,""		},	/* k =             */
		{""	,""		},	/* k =             */
		{""	,""		},	/* k =             */
		{"",""}
	};

	uint32	ntest63,ntest64,ntest65,ntest96,ntest128,ntest128x2,ntest160,ntest192,ntest256;
	uint64	p63, p64 ,pinv64 ,two_p64 ,q64 ,x64 ,res64 ;
	uint128 p128,pinv128,two_p128,q128,x128,res128;
	uint192 p192,pinv192,two_p192,q192,x192,res192;
	uint256 p256,pinv256,two_p256,q256,x256,res256;

	/* 10^31 in binary form - need this to reconstruct large factors that were truncated at 30 digits in the PrimeNet report printout: */
	const uint128 ten31 = {542101086242ull, 13875954555633532928ull};
	const uint64 two64mod60 = 16;
	uint64 two64modp;
	uint64 k;
	uint32 i,i2,i3,i4,j,ii,jj;

	uint32 pm60,km60;
	uint64 hi64,lo64,tmp64;
	char cbuf0[STR_MAX_LEN], cbuf1[STR_MAX_LEN], cbuf2[STR_MAX_LEN], cbuf3[STR_MAX_LEN], cbuf4[STR_MAX_LEN], cbuf5[STR_MAX_LEN], cbuf6[STR_MAX_LEN];

	uint64 *p,*q,*q2,*two_p,*u64_arr;

/****12/12/05: check p%4==3 / q%60 correlations: *****/
	uint32 pqmod60arr[60][60] = {{0}};
/*****************************************************/

	/* 3/29/2006: by way of testing the 256-bit factoring routines, find all 70-digit base-2
	probable primes occurring in the first few thousand digits of Pi: */
#if 0
	/* Here are the first 10000 or so digits of Pi: */
	char Pi[10240] = "";
	const uint32 primelen = 64;

	/* To avoid compiler limits on character literal length, copy digits into Pi[] in 1Kbyte chunks: */
	strcpy(cbuf0, "314159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912983367336244065664308602139494639522473719070217986094370277053921717629317675238467481846766940513200056812714526356082778577134275778960917363717872146844090122495343014654958537105079227968925892354201995611212902196086403441815981362977477130996051870721134999999837297804995105973173281609631859502445945534690830264252230825334468503526193118817101000313783875288658753320838142061717766914730359825349042875546873115956286388235378759375195778185778053217122680661300192787661119590921642019893809525720106548586327");
	strcat(Pi, cbuf0);
	strcpy(cbuf0, "886593615338182796823030195203530185296899577362259941389124972177528347913151557485724245415069595082953311686172785588907509838175463746493931925506040092770167113900984882401285836160356370766010471018194295559619894676783744944825537977472684710404753464620804668425906949129331367702898915210475216205696602405803815019351125338243003558764024749647326391419927260426992279678235478163600934172164121992458631503028618297455570674983850549458858692699569092721079750930295532116534498720275596023648066549911988183479775356636980742654252786255181841757467289097777279380008164706001614524919217321721477235014144197356854816136115735255213347574184946843852332390739414333454776241686251898356948556209921922218427255025425688767179049460165346680498862723279178608578438382796797668145410095388378636095068006422512520511739298489608412848862694560424196528502221066118630674427862203919494504712371378696095636437191728746776465757396241389086583264599581339047802759009946576407895126946839835259570982582262052248");
	strcat(Pi, cbuf0);
	strcpy(cbuf0, "940772671947826848260147699090264013639443745530506820349625245174939965143142980919065925093722169646151570985838741059788595977297549893016175392846813826868386894277415599185592524595395943104997252468084598727364469584865383673622262609912460805124388439045124413654976278079771569143599770012961608944169486855584840635342207222582848864815845602850601684273945226746767889525213852254995466672782398645659611635488623057745649803559363456817432411251507606947945109659609402522887971089314566913686722874894056010150330861792868092087476091782493858900971490967598526136554978189312978482168299894872265880485756401427047755513237964145152374623436454285844479526586782105114135473573952311342716610213596953623144295248493718711014576540359027993440374200731057853906219838744780847848968332144571386875194350643021845319104848100537061468067491927819119793995206141966342875444064374512371819217999839101591956181467514269123974894090718649423196156794520809514655022523160388193014209376213785595663893778708303906");
	strcat(Pi, cbuf0);
	strcpy(cbuf0, "979207734672218256259966150142150306803844773454920260541466592520149744285073251866600213243408819071048633173464965145390579626856100550810665879699816357473638405257145910289706414011097120628043903975951567715770042033786993600723055876317635942187312514712053292819182618612586732157919841484882916447060957527069572209175671167229109816909152801735067127485832228718352093539657251210835791513698820914442100675103346711031412671113699086585163983150197016515116851714376576183515565088490998985998238734552833163550764791853589322618548963213293308985706420467525907091548141654985946163718027098199430992448895757128289059232332609729971208443357326548938239119325974636673058360414281388303203824903758985243744170291327656180937734440307074692112019130203303801976211011004492932151608424448596376698389522868478312355265821314495768572624334418930396864262434107732269780280731891544110104468232527162010526522721116603966655730925471105578537634668206531098965269186205647693125705863566201855810072936065987648");
	strcat(Pi, cbuf0);
	strcpy(cbuf0, "611791045334885034611365768675324944166803962657978771855608455296541266540853061434443185867697514566140680070023787765913440171274947042056223053899456131407112700040785473326993908145466464588079727082668306343285878569830523580893306575740679545716377525420211495576158140025012622859413021647155097925923099079654737612551765675135751782966645477917450112996148903046399471329621073404375189573596145890193897131117904297828564750320319869151402870808599048010941214722131794764777262241425485454033215718530614228813758504306332175182979866223717215916077166925474873898665494945011465406284336639379003976926567214638530673609657120918076383271664162748888007869256029022847210403172118608204190004229661711963779213375751149595015660496318629472654736425230817703675159067350235072835405670403867435136222247715891504953098444893330963408780769325993978054193414473774418426312986080998886874132604721569516239658645730216315981931951673538129741677294786724229246543668009806769282382806899640048243540370141631496");
	strcat(Pi, cbuf0);
	strcpy(cbuf0, "589794092432378969070697794223625082216889573837986230015937764716512289357860158816175578297352334460428151262720373431465319777741603199066554187639792933441952154134189948544473456738316249934191318148092777710386387734317720754565453220777092120190516609628049092636019759882816133231666365286193266863360627356763035447762803504507772355471058595487027908143562401451718062464362679456127531813407833033625423278394497538243720583531147711992606381334677687969597030983391307710987040859133746414428227726346594704745878477872019277152807317679077071572134447306057007334924369311383504931631284042512192565179806941135280131470130478164378851852909285452011658393419656213491434159562586586557055269049652098580338507224264829397285847831630577775606888764462482468579260395352773480304802900587607582510474709164396136267604492562742042083208566119062545433721315359584506877246029016187667952406163425225771954291629919306455377991403734043287526288896399587947572917464263574552540790914513571113694109119393251910");
	strcat(Pi, cbuf0);
	strcpy(cbuf0, "760208252026187985318877058429725916778131496990090192116971737278476847268608490033770242429165130050051683233643503895170298939223345172201381280696501178440874519601212285993716231301711444846409038906449544400619869075485160263275052983491874078668088183385102283345085048608250393021332197155184306354550076682829493041377655279397517546139539846833936383047461199665385815384205685338621867252334028308711232827892125077126294632295639898989358211674562701021835646220134967151881909730381198004973407239610368540664319395097901906996395524530054505806855019567302292191393391856803449039820595510022635353619204199474553859381023439554495977837790237421617271117236434354394782218185286240851400666044332588856986705431547069657474585503323233421073015459405165537906866273337995851156257843229882737231989875714159578111963583300594087306812160287649628674460477464915995054973742562690104903778198683593814657412680492564879855614537234786733039046883834363465537949864192705638729317487233208376011230299113679386");
	strcat(Pi, cbuf0);
	strcpy(cbuf0, "270894387993620162951541337142489283072201269014754668476535761647737946752004907571555278196536213239264061601363581559074220202031872776052772190055614842555187925303435139844253223415762336106425063904975008656271095359194658975141310348227693062474353632569160781547818115284366795706110861533150445212747392454494542368288606134084148637767009612071512491404302725386076482363414334623518975766452164137679690314950191085759844239198629164219399490723623464684411739403265918404437805133389452574239950829659122850855582157250310712570126683024029295252201187267675622041542051618416348475651699981161410100299607838690929160302884002691041407928862150784245167090870006992821206604183718065355672525325675328612910424877618258297651579598470356222629348600341587229805349896502262917487882027342092222453398562647669149055628425039127577102840279980663658254889264880254566101729670266407655904290994568150652653053718294127033693137851786090407086671149655834343476933857817113864558736781230145876871266034891390956");
	strcat(Pi, cbuf0);
	strcpy(cbuf0, "200993936103102916161528813843790990423174733639480457593149314052976347574811935670911013775172100803155902485309066920376719220332290943346768514221447737939375170344366199104033751117354719185504644902636551281622882446257591633303910722538374218214088350865739177150968288747826569959957449066175834413752239709683408005355984917541738188399944697486762655165827658483588453142775687900290951702835297163445621296404352311760066510124120065975585127617858382920419748442360800719304576189323492292796501987518721272675079812554709589045563579212210333466974992356302549478024901141952123828153091140790738602515227429958180724716259166854513331239480494707911915326734302824418604142636395480004480026704962482017928964766975831832713142517029692348896276684403232609275249603579964692565049368183609003238092934595889706953653494060340216654437558900456328822505452556405644824651518754711962184439658253375438856909411303150952617937800297412076651479394259029896959469955657612186561967337862362561252163208628692221");
	strcat(Pi, cbuf0);
	strcpy(cbuf0, "032748892186543648022967807057656151446320469279068212073883778142335628236089632080682224680122482611771858963814091839036736722208883215137556003727983940041529700287830766709444745601345564172543709069793961225714298946715435784687886144458123145935719849225284716050492212424701412147805734551050080190869960330276347870810817545011930714122339086639383395294257869050764310063835198343893415961318543475464955697810382930971646514384070070736041123735998434522516105070270562352660127648483084076118301305279320542746286540360367453286510570658748822569815793678976697422057505968344086973502014102067235850200724522563265134105592401902742162484391403599895353945909440704691209140938700126456001623742880210927645793106579229552498872758461012648369998922569596881592056001016552563756785667227966198857827948488558343975187445455129656344348039664205579829368043522027709842942325330225763418070394769941597915945300697521482933665556615678736400536665641654732170439035213295435291694145990416087532018683793702348");
	strcat(Pi, cbuf0);

//	printf("First %d digits of Pi = %s\n", strlen(Pi), Pi);

	strcpy(cbuf0,"\0");
	for(i = 0; i < 10240; i++)
	{
		// If less than (primelen) digits remaining, quit:
		if(strlen(Pi+i) < primelen)
		{
			break;
		}

		strncpy(cbuf0, Pi+i, primelen);
		// Make sure surrent digit string ends after (primelen) digits:
		cbuf0[primelen] = '\0';
		p256 = convert_base10_char_uint256(cbuf0);
		/* Only test odds: */
		// Workaround for an MSVC compiler bug:
		//printf("p.d0 = %s\n", &cbuf1[convert_uint64_base10_char(cbuf1, p256.d0)]);
		tmp64 = p256.d0 & (uint64)0x0000000000000001ull;
		if(tmp64 == 0)
		{
			continue;
		}
		SUB256(p256,ONE256,q256);
		x256 = twopmodq256(q256,p256);
		if(CMPEQ256(x256,ONE256))
			printf("%s is a base-2 probable prime\n", cbuf0);
	}
#endif

#ifdef FACTOR_STANDALONE
	printf("Mfactor build flags:\n");

	/* TRYQ: */
	#ifndef TRYQ
		printf("TRYQ not defined\n");
		/* This flag is required: */
		ASSERT(HERE, 0,"defined(TRYQ)");
	#else
		i = TRYQ;
		printf("TRYQ = %u\n", i);
	#endif

	/* THREE_OP128: */
	#ifndef THREE_OP128
		printf("THREE_OP128 not defined\n");
	#elif(THREE_OP128 == 0)
		printf("THREE_OP128 = FALSE\n");
	#else
		i = THREE_OP128;
		printf("THREE_OP128 = %u\n", i);
		/* iF NONZERO, Must = 1 : */
		ASSERT(HERE, (THREE_OP128 == 1),"THREE_OP128 Must = 0 or 1!");
		/* Only relevant for TRYQ = 4 or 8: */
		#if(TRYQ != 4 && TRYQ != 8)
			#error	THREE_OP128 Only relevant for TRYQ = 4 or 8!
		#endif
		/* Only relevant for factoring up to 128 bits: */
		#if(defined(P3WORD) || defined(P4WORD))
			#error	THREE_OP128 Only relevant for factoring up to 128 bits!
		#endif
		/* Only relevant if using fully 128-bit modmul routines: */
		#if(defined(USE_128x96) && USE_128x96 != 0)
			#error	THREE_OP128 Only relevant if using fully 128-bit modmul routines - undef USE_128x96 or set = 0!
		#endif
	#endif

	/* NUM_SIEVING_PRIME: */
	#ifndef NUM_SIEVING_PRIME
		printf("NUM_SIEVING_PRIME not defined\n");
		/* This flag is required: */
		ASSERT(HERE, 0,"defined(NUM_SIEVING_PRIME)");
	#else
		i = NUM_SIEVING_PRIME;
		printf("NUM_SIEVING_PRIME = %u\n", i);
	#endif

	/* USE_FLOAT: */
	#ifndef USE_FLOAT
		printf("USE_FLOAT not defined\n");
	#else
		printf("USE_FLOAT = true\n");
	#endif

	/* USE_FMADD: */
	#ifndef USE_FMADD
		printf("USE_FMADD not defined\n");
	#else
		printf("USE_FMADD = true\n");
	#endif

	/* FACTOR_STANDALONE: */
	#ifndef FACTOR_STANDALONE
		printf("FACTOR_STANDALONE not defined\n");
	#else
		printf("FACTOR_STANDALONE = true\n");
	#endif

	/* FAC_DEBUG: */
	#ifndef FAC_DEBUG
		printf("FAC_DEBUG not defined\n");
	#else
		printf("FAC_DEBUG = true\n");
	#endif

	/* DBG_SIEVE: */
	#ifndef DBG_SIEVE
		printf("DBG_SIEVE not defined\n");
	#else
		i = DBG_SIEVE;
		printf("DBG_SIEVE = true\n");
	#endif

	/* NOBRANCH: */
	#ifndef NOBRANCH
		printf("NOBRANCH not defined\n");
	#else
		printf("NOBRANCH = true\n", NOBRANCH);
	#endif

	/* QUIT_WHEN_FACTOR_FOUND: */
	#ifndef QUIT_WHEN_FACTOR_FOUND
		printf("QUIT_WHEN_FACTOR_FOUND not defined\n");
	#else
		printf("QUIT_WHEN_FACTOR_FOUND = true\n");
	#endif

	/* USE_65BIT: */
	#ifndef USE_65BIT
		printf("USE_65BIT not defined\n");
	#else
		printf("USE_65BIT = true\n");
	#endif

	/* USE_128x96: */
	#ifndef USE_128x96
		printf("USE_128x96 not defined\n");
	#else
		printf("USE_128x96 = true\n");
		/* Only relevant for factoring up to 128 bits: */
		#if(defined(P3WORD) || defined(P4WORD))
			#error	USE_128x96 Only relevant for factoring up to 128 bits!
		#endif
	#endif

	/* P2WORD: */
	#ifndef P2WORD
		printf("P2WORD not defined\n");
	#else
		printf("P2WORD = true\n");

		#ifndef USE_128x96
			printf("    USE_128x96 not defined\n");
		#else
			printf("    USE_128x96 = %u\n", USE_128x96);
		#endif

	#endif

	/* P3WORD: */
	#ifndef P3WORD
		printf("P3WORD not defined\n");
	#else
		printf("P3WORD = true\n");

		#ifndef PIPELINE_MUL192
			printf("    PIPELINE_MUL192 not defined\n");
		#else
			printf("    PIPELINE_MUL192 = %u\n", PIPELINE_MUL192);
		#endif

	#endif

	/* P4WORD: */
	#ifndef P4WORD
		printf("P4WORD not defined\n");
	#else
		printf("P4WORD = true\n");
	#endif
#endif

#ifdef FACTOR_STANDALONE
	printf("Mfactor self-tests:\n");
#endif

	/* 01/09/2008 mi64_div bug debug: */
	p = convert_base10_char_mi64("531137992816767098689588206552468627329593117727031923199444138200403559860852242739162502265229285668889329486246501015346579337652707239409519978766587351943831270835393219031728127", &i);
	two_p = (uint64 *)calloc(i, sizeof(uint64));
	mi64_add(p,p,two_p,i);
	q = convert_base10_char_mi64("4969289881134175801642878989330437804491760137935869781219375395913301677808943323410612629818326630668131744420258226244511522022525093242408710254941677603671849301746980479735516135243111", &j);
	ASSERT(HERE, i==j,"0");
	q2      = (uint64 *)calloc(i, sizeof(uint64));
	u64_arr = (uint64 *)calloc(i, sizeof(uint64));
	mi64_div(q,two_p,q2,u64_arr,i);
	ASSERT(HERE, mi64_getlen(q2, i) == 1 , "k must be 64-bit!");
	if(!mi64_cmpeq_scalar(u64_arr, 1ull, i))
	{
		fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",&cbuf0[convert_mi64_base10_char(cbuf0,p,i)], &cbuf1[convert_mi64_base10_char(cbuf1, q, i)], &cbuf2[convert_mi64_base10_char(cbuf2, u64_arr, i)]);
		ASSERT(HERE, 0,"0");
	}
	else
		fprintf(stderr,"mi64_div quicktest passes.\n");

	/* 7/21/2005 bugfix test: */
	q192.d2=506560280167ull; q192.d1=18446744073709551615ull; q192.d0=18446743060588991281ull;
	p192 = q192; p192.d0 -= 1;
	x192 = twopmodq192(p192,q192);
	ASSERT(HERE, CMPEQ192(ONE192, x192),"CMPEQ192(ONE192, x192)");
	/* 12/23/2008: Use this to help debug the mi64 powering routine: */
	ASSERT(HERE, mi64_twopmodq(&p192.d0, 3, &q192.d0, 3, 0x0), "mi64_twopmodq != 1");

	/* 1/23/2004 bugfix test (cf. def. of MULH192 in imul_macro.h for details):

	X =                   14*2^128 +  3291757557782450881*2^64 +  3893270457587058239;
	Y = 14334090244500356821*2^128 + 14839649155872891980*2^64 + 12743646208794279936;
	! and w3 = 2846153632803221901, rather than the true w2 = 0 and w3 = 2846153632803221902.
	!
	! However, this kind of thing is only likely to happen in the one q*(qinv << shift) multiply
	! that we do just prior to entering the modmul-based powering loop. So we could define two
	! versions of the MULH routine: an exact one which will be used only for the initial mul,
	! and one which approximates the (presumably quasirandom) lower bits of the mul so as to get
	! the proper carry into the upper half with very high probability, which we use everywhere else.
	! ****TODO???****

	*/
	p192.d2=                  14ull; p192.d1= 3291757557782450881ull; p192.d0= 3893270457587058239ull;
	q192.d2=14334090244500356821ull; q192.d1=14839649155872891980ull; q192.d0=12743646208794279936ull;
	MULH192(p192,q192,x192);
	/* Reference value to compare to: */
	q192.d2=                  11ull; q192.d1=  320947345442520101ull; q192.d0= 2846153632803221902ull;
	ASSERT(HERE, CMPEQ192(x192, q192),"CMPEQ192(x192, q192)");

	/* Count the # of test q's of the various sizes: */
	for(ntest63    = 0; fac63   [ntest63   ].p          != 0; ++ntest63   ){}
	for(ntest64    = 0; fac64   [ntest64   ].p          != 0; ++ntest64   ){}
	for(ntest65    = 0; fac65   [ntest65   ].p          != 0; ++ntest65   ){}
	for(ntest96    = 0; fac96   [ntest96   ].p          != 0; ++ntest96   ){}
	for(ntest128   = 0; fac128  [ntest128  ].p          != 0; ++ntest128  ){}
	for(ntest128x2 = 0; fac128x2[ntest128x2].plo        != 0; ++ntest128x2){}
	for(ntest160   = 0; fac160  [ntest160  ].p          != 0; ++ntest160  ){}
	for(ntest192   = 0; fac192  [ntest192  ].p          != 0; ++ntest192  ){}
	for(ntest256   = 0; STRNEQ(fac256[ntest256].p, "")		; ++ntest256  ){}

	/* Test 63-bit factors using the 63, 64 and 96-bit modmul routines */
#ifdef FACTOR_STANDALONE
	printf("Testing 63-bit factors...\n");
#endif
	for(i = 0; fac63[i].p != 0; i++)
	{
		p64 = fac63[i].p; q64 = fac63[i].q;
		/* Make sure the MSB = 0: */
		ASSERT(HERE, ( int64)p64 > 0, "test_fac : ( int64)p64 > 0");
		ASSERT(HERE, q64%(2*p64) ==1, "test_fac : q64%(2*p64) ==1");

		k = (q64-1)/(2*p64);
		pm60 = p64%60;
		km60 = k  %60;
/****12/12/05: check p%60 / q%60 correlations: *****/
/*	if(p64&3==3)printf("q mod 60 == %2u\n",q64%60);*/
	++pqmod60arr[pm60][0];	/* Since we know q%60 != 0, use the zero column to store the total count of q's for each p%60 value */
	++pqmod60arr[pm60][q64%60];
/*****************************************************/
		/* This property only applies for prime exponents, so use a quick base-2 Fermat
		compositeness test as an exponent filter: */
		if(twopmodq64(p64-1, p64) && !CHECK_PKMOD60(pm60, km60))
		{
			fprintf(stderr,"Illegal (p,k) mod 60 pair: p, p mod 60, q64, k mod 60 = %s %4u %s %4u\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)],pm60,&cbuf1[convert_uint64_base10_char(cbuf1, q64)],km60);
			ASSERT(HERE, 0,"0");
		}

		if((res64 = twopmodq63(p64, q64)) != 1)
		{
			fprintf(stderr,"ERROR: twopmodq63(%s, %s) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint64_base10_char(cbuf1, q64)], &cbuf2[convert_uint64_base10_char(cbuf2, res64)]);
			ASSERT(HERE, 0,"0");
		}
		if((res64 = twopmodq64(p64, q64)) != 1)
		{
			fprintf(stderr,"ERROR: twopmodq64(%s, %s) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint64_base10_char(cbuf1, q64)], &cbuf2[convert_uint64_base10_char(cbuf2, res64)]);
			ASSERT(HERE, 0,"0");
		}

		q128.d1 = (uint64)0; q128.d0 = q64;
	#ifdef USE_FLOAT
		res64 = twopmodq78_3WORD_DOUBLE(p64, q128);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE(%s, %s) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint64_base10_char(cbuf1, q64)], &cbuf2[convert_uint64_base10_char(cbuf2, res64)]);
			ASSERT(HERE, 0,"0");
		}
	#endif
		res128 = twopmodq96(p64, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR: twopmodq96(%s, %s) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint64_base10_char(cbuf1, q64)], &cbuf2[convert_uint128_base10_char(cbuf2, res128)]);
			ASSERT(HERE, 0,"0");
		}

		res128 = twopmodq128_96(p64, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR: twopmodq128_96(%s, %s) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint64_base10_char(cbuf1, q64)], &cbuf2[convert_uint128_base10_char(cbuf2, res128)]);
			ASSERT(HERE, 0,"0");
		}

	#ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE(p64, q128);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE(%s, %s) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint64_base10_char(cbuf1, q64)], &cbuf2[convert_uint64_base10_char(cbuf2, res64)]);
			ASSERT(HERE, 0,"0");
		}
	#endif

		/* Also test the multiple-q versions of the modular exponentiation routines: */
	#if(TRYQ == 2)
	  #ifdef USE_FLOAT
		res64 = twopmodq78_3WORD_DOUBLE_q2(p64, q128,q128);
		if(res64 != 3)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q2( %s, %s x 2 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
	  #ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE_q2(p64, q128,q128);
		if(res64 != 3)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE_q2( %s, %s x 2 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
	#elif(TRYQ == 4)
		res64 = twopmodq63_q4(p64,q64,q64,q64,q64);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq63_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint64_base10_char(cbuf1, q64)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #ifdef USE_FLOAT
		res64 = twopmodq78_3WORD_DOUBLE_q4(p64, q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
	  #ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE_q4(p64, q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
		res64 = twopmodq96_q4(p64,q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq96_q4( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char (cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
		res64 = twopmodq128_96_q4(p64,q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq128_96_q4( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char (cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#elif(TRYQ == 8)
		res64 = twopmodq63_q8(p64,q64,q64,q64,q64,q64,q64,q64,q64);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq63_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint64_base10_char(cbuf1, q64)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
		res64 = twopmodq96_q8(p64,q128,q128,q128,q128,q128,q128,q128,q128);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq96_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char (cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
		res64 = twopmodq128_96_q8(p64,q128,q128,q128,q128,q128,q128,q128,q128);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq128_96_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char (cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif
	}

	/* Test 64-bit factors using the 64 and 96-bit modmul routines */
#ifdef FACTOR_STANDALONE
	printf("Testing 64-bit factors...\n");
#endif
	for(i = 0; fac64[i].p != 0; i++)
	{
		p64 = fac64[i].p; q64 = fac64[i].q;

		ASSERT(HERE, q64%(2*p64)==1, "test_fac : q64%(2*p64)==1");

		k = (q64-1)/(2*p64);
		pm60 = p64%60;
		km60 = k  %60;
/****12/12/05: check p%60 / q%60 correlations: *****/
/*	if(p64&3==3)printf("q mod 60 == %2u\n",q64%60);*/
	++pqmod60arr[pm60][0];	/* Since we know q%60 != 0, use the zero column to store the total count of q's for each p%60 value */
	++pqmod60arr[pm60][q64%60];
/*****************************************************/
		/* This property only applies for prime exponents, so use a quick base-2 Fermat
		compositeness test as an exponent filter: */
		if(twopmodq64(p64-1, p64) && !CHECK_PKMOD60(pm60, km60))
		{
			fprintf(stderr,"Illegal (p,k) mod 60 pair: p, p mod 60, q64, k mod 60 = %s %4u %s %4u\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)],pm60,&cbuf1[convert_uint64_base10_char(cbuf1, q64)],km60);
			ASSERT(HERE, 0,"0");
		}

		if(q64%(2*p64) != 1)
		{
			fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint64_base10_char(cbuf1, q64)], &cbuf2[convert_uint64_base10_char(cbuf2, q64%(2*p64))]);
			ASSERT(HERE, 0,"0");
		}

		if((res64 = twopmodq64(p64, q64)) != 1)
		{
			fprintf(stderr,"ERROR: twopmodq64(%s, %s) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint64_base10_char(cbuf1, q64)], &cbuf2[convert_uint64_base10_char(cbuf2, res64)]);
			ASSERT(HERE, 0,"0");
		}

		q128.d1 = (uint64)0; q128.d0 = q64;

	#ifdef USE_FLOAT
		res64 = twopmodq78_3WORD_DOUBLE(p64, q128);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE(%s, %s) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint64_base10_char(cbuf1, q64)], &cbuf2[convert_uint64_base10_char(cbuf2, res64)]);
			ASSERT(HERE, 0,"0");
		}
	#endif
		res128 = twopmodq96(p64, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR: twopmodq96(%s, %s) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint64_base10_char(cbuf1, q64)], &cbuf2[convert_uint128_base10_char(cbuf2, res128)]);
			ASSERT(HERE, 0,"0");
		}

		res128 = twopmodq128_96(p64, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR: twopmodq128_96(%s, %s) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint64_base10_char(cbuf1, q64)], &cbuf2[convert_uint128_base10_char(cbuf2, res128)]);
			ASSERT(HERE, 0,"0");
		}

	#ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE(p64, q128);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE(%s, %s) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint64_base10_char(cbuf1, q64)], &cbuf2[convert_uint64_base10_char(cbuf2, res64)]);
			ASSERT(HERE, 0,"0");
		}

	#endif

		/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
	#if(TRYQ == 2)
	  #ifdef USE_FLOAT
		res64 = twopmodq78_3WORD_DOUBLE_q2(p64, q128,q128);
		if(res64 != 3)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q2( %s, %s x 2 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
	  #ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE_q2(p64, q128,q128);
		if(res64 != 3)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE_q2( %s, %s x 2 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
	#elif(TRYQ == 4)
		res64 = twopmodq64_q4(p64,q64,q64,q64,q64);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq64_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint64_base10_char(cbuf1, q64)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #ifdef USE_FLOAT
		res64 = twopmodq78_3WORD_DOUBLE_q4(p64, q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
	  #ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE_q4(p64, q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
		res64 = twopmodq96_q4(p64,q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq96_q4( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char (cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
		res64 = twopmodq128_96_q4(p64,q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq128_96_q4( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char (cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#elif(TRYQ == 8)
		res64 = twopmodq64_q8(p64,q64,q64,q64,q64,q64,q64,q64,q64);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq64_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint64_base10_char(cbuf1, q64)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
		res64 = twopmodq96_q8(p64,q128,q128,q128,q128,q128,q128,q128,q128);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq96_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char (cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
		res64 = twopmodq128_96_q8(p64,q128,q128,q128,q128,q128,q128,q128,q128);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq128_96_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char (cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif
	}

	/* Test 65-bit factors using the 65 and 96-bit modmul routines */
#ifdef FACTOR_STANDALONE
	printf("Testing 65-bit factors...\n");
#endif
	for(i = 0; fac65[i].p != 0; i++)
	{
		p64 = fac65[i].p; q64 = fac65[i].q;
		q128.d1 = (uint64)1; q128.d0 = q64;

		/* Modify this so it'll work with 65-bit q's: */
		ASSERT(HERE, ((q64-1)/2 + 0x8000000000000000ull)%p64==0, "test_fac : ((q64-1)/2 + 0x8000000000000000ull)%p64==0");

		k = ((q64-1)/2 + 0x8000000000000000ull)/p64;
		pm60 = p64%60;
		km60 = k  %60;

		/* This property only applies for prime exponents, so use a quick base-2 Fermat
		compositeness test as an exponent filter: */
		if(twopmodq64(p64-1, p64) && !CHECK_PKMOD60(pm60, km60))
		{
			fprintf(stderr,"Illegal (p,k) mod 60 pair: p, p mod 60, q64, k mod 60 = %s %4u %s %4u\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)],pm60,&cbuf1[convert_uint128_base10_char(cbuf1, q128)],km60);
			ASSERT(HERE, 0,"0");
		}
		if((res64 = twopmodq65(p64, q64)) != 1)
		{
			fprintf(stderr,"ERROR: twopmodq65(%s, %s) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], &cbuf2[convert_uint64_base10_char(cbuf2, res64)]);
			ASSERT(HERE, 0,"0");
		}

	#ifdef USE_FLOAT
		res64 = twopmodq78_3WORD_DOUBLE(p64, q128);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE(%s, %s) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], &cbuf2[convert_uint64_base10_char(cbuf2, res64)]);
			ASSERT(HERE, 0,"0");
		}
	#endif
		res128 = twopmodq96(p64, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR: twopmodq96(%s, %s) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint64_base10_char(cbuf1, q64)], &cbuf2[convert_uint128_base10_char(cbuf2, res128)]);
			ASSERT(HERE, 0,"0");
		}

		res128 = twopmodq128_96(p64, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR: twopmodq128_96(%s, %s) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], &cbuf2[convert_uint128_base10_char(cbuf2, res128)]);
			ASSERT(HERE, 0,"0");
		}

	#ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE(p64, q128);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE(%s, %s) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint64_base10_char(cbuf1, q64)], &cbuf2[convert_uint64_base10_char(cbuf2, res64)]);
			ASSERT(HERE, 0,"0");
		}
	#endif

		/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
	#if(TRYQ == 2)
	  #ifdef USE_FLOAT
		res64 = twopmodq78_3WORD_DOUBLE_q2(p64, q128,q128);
		if(res64 != 3)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q2( %s, %s x 2 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
	  #ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE_q2(p64, q128,q128);
		if(res64 != 3)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE_q2( %s, %s x 2 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
	#elif(TRYQ == 4)
		res64 = twopmodq65_q4(p64,q64,q64,q64,q64);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq65_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #ifdef USE_FLOAT
		res64 = twopmodq78_3WORD_DOUBLE_q4(p64, q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
	  #ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE_q4(p64, q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
		res64 = twopmodq96_q4(p64,q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq96_q4( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char (cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq128_96_q4( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char (cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#elif(TRYQ == 8)
		res64 = twopmodq65_q8(p64,q64,q64,q64,q64,q64,q64,q64,q64);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq65_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
		res64 = twopmodq96_q8(p64,q128,q128,q128,q128,q128,q128,q128,q128);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq96_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char (cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
		res64 = twopmodq128_96_q8(p64,q128,q128,q128,q128,q128,q128,q128,q128);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq128_96_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char (cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif
	}

	/* Test 96-bit factors using the 96 and 128-bit modmul routines */
#ifdef FACTOR_STANDALONE
	printf("Testing 96-bit factors...\n");
#endif
	for(i = 0; fac96[i].p != 0; i++)
	{
		p64 = fac96[i].p;
		q128.d1 = (uint64)fac96[i].d1; q128.d0 = fac96[i].d0;

		/* Modify this so it'll work with 96-bit q's: */
		two64modp = 0x8000000000000000ull%p64;
		two64modp = (two64modp + two64modp)%p64;
		res64 = (q128.d1*two64modp + q128.d0%p64)%p64;
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], &cbuf2[convert_uint64_base10_char(cbuf2, res64)]);
			ASSERT(HERE, 0,"0");
		}

		/* To find the quotient k = (q-1)/(2*p), which may be > 64 bits, use mod-inverse with base 2^128 arithmetic.
		Since the Newtonian mod-inverse algorithm only works for odd inputs, instead of finding (q-1)/(2*p), we find ((q-1)/2)/p.
		First, find inverse (mod 2^128) of p in preparation for modular multiply. See twopmodq128 for an explanation of this:
		*/
		pinv128.d0 = (p64 + p64 + p64) ^ (uint64)2;	pinv128.d1 = (uint64)0;
		for(j = 0; j < 4; j++)
		{
			hi64 = p64*pinv128.d0;
			pinv128.d0 = pinv128.d0*((uint64)2 - hi64);
		}
		/* pinv128 has 128 bits, but only the upper 64 get modified here. */
		#ifdef MUL_LOHI64_SUBROUTINE
			pinv128.d1 = -pinv128.d0*__MULH64(p64, pinv128.d0);
		#else
			MULH64(p64, pinv128.d0, hi64);
			pinv128.d1 = -pinv128.d0*hi64;
		#endif
		/* k is simply the bottom 128 bits of ((q-1)/2)*pinv128: */
		x128.d0	= ((q128.d0-1) >> 1) + (q128.d1 << 63);	x128.d1	= (q128.d1 >> 1);	/* (q-1)/2. */
		MULL128(x128, pinv128, x128);
		pm60 = p64%60;
		km60 = (x128.d1*two64mod60 + x128.d0%60)%60;

		/* This property only applies for prime exponents, so use a quick base-2 Fermat
		compositeness test as an exponent filter: */
		if(twopmodq64(p64-1, p64) && !CHECK_PKMOD60(pm60, km60))
		{
			fprintf(stderr,"Illegal (p,k) mod 60 pair: p, p mod 60, q96, k mod 60 = %s %4u %s %4u\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)],pm60,&cbuf1[convert_uint128_base10_char(cbuf1, q128)],km60);
			ASSERT(HERE, 0,"0");
		}

	#ifdef USE_FLOAT
	  if((q128.d1 >> 14) == 0)
	  {
		res64 = twopmodq78_3WORD_DOUBLE(p64, q128);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE(%s, %s) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], &cbuf2[convert_uint64_base10_char(cbuf2, res64)]);
			ASSERT(HERE, 0,"0");
		}
	  }
	#endif
		res128 = twopmodq96(p64, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR: twopmodq96(%s, %s ) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], &cbuf2[convert_uint128_base10_char(cbuf2, res128)]);
			ASSERT(HERE, 0,"0");
		}

		res128 = twopmodq128_96(p64, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR: twopmodq128_96(%s, %s ) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], &cbuf2[convert_uint128_base10_char(cbuf2, res128)]);
			ASSERT(HERE, 0,"0");
		}

		res128 = twopmodq128(p64, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR: twopmodq128(%s, %s ) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], &cbuf2[convert_uint128_base10_char(cbuf2, res128)]);
			ASSERT(HERE, 0,"0");
		}

		p128.d0 = p64; p128.d1 = 0;
		res128 = twopmodq128x2((uint64 *)&p128, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR: twopmodq128x2(%s, %s ) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], &cbuf2[convert_uint128_base10_char(cbuf2, res128)]);
			ASSERT(HERE, 0,"0");
		}

	#ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE(p64, q128);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE(%s, %s) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint64_base10_char(cbuf1, q64)], &cbuf2[convert_uint64_base10_char(cbuf2, res64)]);
			ASSERT(HERE, 0,"0");
		}
	#endif

		/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
	#if(TRYQ == 2)
	  #ifdef USE_FLOAT
	  if((q128.d1 >> 14) == 0)
	  {
		res64 = twopmodq78_3WORD_DOUBLE_q2(p64, q128,q128);
		if(res64 != 3)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q2( %s, %s x 2 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  }
	  #endif
	  #ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE_q2(p64, q128,q128);
		if(res64 != 3)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE_q2( %s, %s x 2 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
	#elif(TRYQ == 4)
	  #ifdef USE_FLOAT
	  if((q128.d1 >> 14) == 0)
	  {
		res64 = twopmodq78_3WORD_DOUBLE_q4(p64, q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  }
	  #endif
	  #ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE_q4(p64, q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
		res64 = twopmodq96_q4(p64,q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq96_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
		res64 = twopmodq128_96_q4(p64,q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq128_96_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#elif(TRYQ == 8)
		res64 = twopmodq96_q8(p64,q128,q128,q128,q128,q128,q128,q128,q128);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq96_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char (cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
		res64 = twopmodq128_96_q8(p64,q128,q128,q128,q128,q128,q128,q128,q128);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq128_96_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char (cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
		res64 = twopmodq128_q8(p128,q128,q128,q128,q128,q128,q128,q128,q128);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq128_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint128_base10_char(cbuf0,p128)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif
	}

#if(defined(P2WORD) || defined(P3WORD) || defined(P4WORD))

	/* Test 128-bit factors using the 128-bit modmul routines. */
  #ifdef FACTOR_STANDALONE
	printf("Testing 128-bit factors...\n");
  #endif
	/* 128_A: Factors > 96 but <= 128 bits. */
	for(i = 0; fac128[i].p != 0; i++)
	{
/* Comment out the left-justified continue's below to enable factor reconstruction code. */
		p64 = fac128[i].p;
		q128.d1 = fac128[i].d1; q128.d0 = fac128[i].d0;

		/* Modify this so it'll work with 128-bit q's: */
		two64modp = 0x8000000000000000ull%p64;
		two64modp = (two64modp + two64modp)%p64;
		/* Really large factors may have high part sufficiently large that q128.d1*two64modp
		overflows 64 bits, so stick an extra mod-p in there:
		*/
		res64 = ((q128.d1%p64)*two64modp + q128.d0%p64)%p64;
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)],&cbuf1[convert_uint128_base10_char(cbuf1, q128)], &cbuf2[convert_uint64_base10_char(cbuf2, res64)]);
			ASSERT(HERE, 0,"0");
		}

		/* This uses the generic 128-bit mod function to calculate q%(2*p): */
		p128.d0 = p64; p128.d1 = 0;
		ADD128(p128, p128, two_p128);
		x128 = xmody128(q128, two_p128);
		if(!CMPEQ128(x128, ONE128))
		{
			fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",&cbuf0[convert_uint128_base10_char(cbuf0, p128)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], &cbuf2[convert_uint128_base10_char(cbuf2, x128)]);
			ASSERT(HERE, 0,"0");
		}

		/* To find the quotient k = (q-1)/(2*p), which may be > 64 bits, use mod-inverse with base 2^128 arithmetic.
		Since the Newtonian mod-inverse algorithm only works for odd inputs, instead of finding (q-1)/(2*p), we find ((q-1)/2)/p.
		First, find inverse (mod 2^128) of p in preparation for modularmultiply. See twopmodq128 for an explanation of this:
		*/
		pinv128.d0 = (p64 + p64 + p64) ^ (uint64)2;  pinv128.d1 = (uint64)0;
		for(j = 0; j < 4; j++)
		{
			hi64 = p64*pinv128.d0;
			pinv128.d0 = pinv128.d0*((uint64)2 - hi64);
		}
		/* pinv128 has 128 bits, but only the upper 64 get modified here. */
		#ifdef MUL_LOHI64_SUBROUTINE
			pinv128.d1 = -pinv128.d0*__MULH64(p64, pinv128.d0);
		#else
			MULH64(p64, pinv128.d0, hi64);
			pinv128.d1 = -pinv128.d0*hi64;
		#endif
		/* k is simply the bottom 128 bits of ((q-1)/2)*pinv128: */
		x128.d0 = ((q128.d0-1) >> 1) + (q128.d1 << 63); x128.d1 = (q128.d1 >> 1);       /* (q-1)/2. */
		MULL128(x128, pinv128, x128);
		pm60 = p64%60;
		km60 = (x128.d1*two64mod60 + x128.d0%60)%60;

		/* This property only applies for prime exponents, so use a quick base-2 Fermat
		compositeness test as an exponent filter: */
		if(twopmodq64(p64-1, p64) && !CHECK_PKMOD60(pm60, km60))
		{
			fprintf(stderr,"ERROR: Illegal (p,k) mod 60 pair: p, p mod 60, q128, k mod 60 = %s %4u %s %4u\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)],pm60,&cbuf1[convert_uint128_base10_char(cbuf1, q128)],km60);
			ASSERT(HERE, 0,"0");
		}

		res128 = twopmodq128(p64, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR: twopmodq128(%s, %s ) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], &cbuf2[convert_uint128_base10_char(cbuf2, res128)]);
			ASSERT(HERE, 0,"0");

		#if 0
			/* In case this is a factor sufficiently large (> 10^31) that it was truncated at 30 digits
			in the PrimeNet report printout, attempt to reconstruct the true factor.

			Attempt to reconstruct the lower portion by repeatedly multiplying by 10 and
			filling in the vacated lower decimal digits:
			*/
			printf("Attempting to reconstruct lower digits of the factor: 10^\n");

		    k = 1;
		    for(idx = 1; idx < 10; idx++)       /* Reconstruct up to 9 lower decimal digits */
		    {
				printf("...%d\n", idx);
				k *= 10;

				/* Multiply the reported factor by 10^idx, unless that would cause the result to overflow: */
				if(k > ((uint32)1 << leadz64(q128.d1)))
					goto CONT128;

				MUL_LOHI64(q128.d0, k, x128.d0, x128.d1);
				x128.d1 += k*q128.d1;
				/* Subtract whatever small constant is needed to make the initial candidate == 1 mod p: */
				j = x128.d1%p64;
				j = (j*two64modp)%p64;
				j += x128.d0%p64;
				j = j%p64 - 1;
				res64 = x128.d0 - j;
				x128.d1 -= (res64 > x128.d0);     /* Borrow from high word is checked here. */
				x128.d0 = res64;
				/*printf("   Subtracting %s  gives %s \n", &cbuf0[convert_uint64_base10_char(cbuf0, j)], &cbuf1[convert_uint128_base10_char(cbuf1, x128)]);*/

				kmax = k/p64;
				for(j = 0; j <= kmax; j++)
				{
					x128.d0 += p64;	x128.d1 += (x128.d0 < p64);

					/* As a quick filter, only try the candidate if it: */
					/* 1) == +- 1 mod 8: */
					res64 = x128.d0 & (uint64)7;
					if(res64 == 3 || res64 == 5)
						continue;
					/*
					// 2) Is not divisible by 3,5,7,11,13,17,19:
					// Use that 2^64 == 1 mod  3, i.e. x128 %  3 = (   x128.d1+x128.d0)% 3:
					//	  2^64 == 1 mod  5, i.e. x128 %  5 = (   x128.d1+x128.d0)% 5:
					//	  2^64 == 2 mod  7, i.e. x128 %  7 = ( 2*x128.d1+x128.d0)% 7:
					//	  2^64 == 5 mod 11, i.e. x128 % 11 = ( 5*x128.d1+x128.d0)%11:
					//	  2^64 == 3 mod 13, i.e. x128 % 13 = ( 3*x128.d1+x128.d0)%13:
					//	  2^64 == 1 mod 17, i.e. x128 % 17 = (   x128.d1+x128.d0)%17:
					//	  2^64 ==17 mod 19, i.e. x128 % 19 = (17*x128.d1+x128.d0)%19:
					res64 = x128.d1+x128.d0;
					if(res64%3 == 0 || res64%5 == 0 || res64%17 == 0)
						continue;

					res64 += x128.d1;
					if(res64%7 == 0)
						continue;

					res64 += x128.d1;
					if(res64%13 == 0)
						continue;

					res64 += (x128.d1 << 1);
					if(res64%11 == 0)
						continue;

					res64 += (x128.d1 << 1);
					if(res64%11 == 0)
						continue;
					*/
					/* 3) Satisfies the (p,k)%60 rules: */
					lo.d0   = ((x128.d0-1) >> 1) + (x128.d1 << 63);	lo.d1   = (x128.d1 >> 1);       /* (q-1)/2. */
					MULL128(lo, pinv128, lo);
					km60 = (lo.d1*two64mod60 + lo.d0%60)%60;
					if(!CHECK_PKMOD60(pm60, km60))
						continue;

					if(twopmodq128(p64, x128) == 1)
					{
						q128 = x128;
						printf("***Reconstructed factor: Q =  %s \n", &cbuf0[convert_uint128_base10_char(cbuf0, q128)]);
						goto CONT128;
					}
				}
		    }

			/* Attempt to reconstruct the upper portion by repeatedly adding 10^31 and retrying: */
			printf("Attempting to reconstruct upper digits of the factor...\n");
			x128 = q128;
			for(j = 0; j < 0x10000000; j++)
			{
				ADD128(ten31, x128, x128);

				/* As a quick filter, only try the candidate if it satisfies the (p,k)%60 rules: */
				lo.d0   = ((x128.d0-1) >> 1) + (x128.d1 << 63);lo.d1   = (x128.d1 >> 1);       /* (q-1)/2. */
				MULL128(lo, pinv128, lo);
				km60 = (lo.d1*two64mod60 + lo.d0%60)%60;

				if(!CHECK_PKMOD60(pm60, km60))
				{
					continue;
				}

				if(twopmodq128(p64, x128) == 1)
				{
					q128 = x128;
					printf("***Reconstructed factor: Q =  %s \n", &cbuf0[convert_uint128_base10_char(cbuf0, q128)]);
					break;
				}
			}
		CONT128:
			continue;

		#endif	/* if(0) */
		}

		p128.d0 = p64; p128.d1 = 0;
		res128 = twopmodq128x2(p128, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR: twopmodq128x2(%s, %s ) returns non-unity result %s\n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], &cbuf2[convert_uint128_base10_char(cbuf2, res128)]);
			ASSERT(HERE, 0,"0");
		}

		/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
	#if(TRYQ == 4)
		res64 = twopmodq128_q4(p128,q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq128_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#elif(TRYQ == 8)
		p128.d0 = p64; p128.d1 = 0;
		res64 = twopmodq128_q8(p128,q128,q128,q128,q128,q128,q128,q128,q128);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq128_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif
	}

#endif	/* #endif(defined(P2WORD) || defined(P3WORD) || defined(P4WORD)) */

#if(defined(P2WORD))

	/*** Only do this time-consuming series of 128-bit factor tests in debug mode: ***/
  #if(FAC_DEBUG)
	/* 128_B: Construct more 128-bit test factors by multiplying together
	a 63-bit factor q1 of M(p1) and a 64-bit factor q2 of M(p2)
	and checking whether q1*q2 divides M(p1*p2).
	*/
   #ifdef FACTOR_STANDALONE
	printf("Testing 63*64-bit factors...I=");
   #endif
	/*for(i = 0; fac63[i].p != 0; i++)*/
	for(i = 0; i < 100; i++)
	{
   #ifdef FACTOR_STANDALONE
	printf("%u...",i);
   #endif
	  for(i2 = 0; fac64[i2].p != 0; i2++)
	  {
		if(fac63[i].p == fac64[i2].p)
			continue;

		p64 = (uint64)fac63[i].p * (uint64)fac64[i2].p;
	#ifdef MUL_LOHI64_SUBROUTINE
		MUL_LOHI64(fac63[i].q, fac64[i2].q,&q128.d0,&q128.d1);
	#else
		MUL_LOHI64(fac63[i].q, fac64[i2].q, q128.d0, q128.d1);
	#endif

		/* Skip the q%(2*p) == 1 and (p%60,q%60) checks, as they don't apply
		to composite factors which are a product of prime factors of
		different-exponent M(p)'s. */

		res128 = twopmodq128(p64, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR_63x64[%u][%u]: twopmodq128(%u*%u, %s*%s ) returns non-unity result %s\n", i,i2, fac63[i].p, fac64[i2].p, &cbuf0[convert_uint64_base10_char(cbuf0, fac63[i].q)], &cbuf1[convert_uint64_base10_char(cbuf1, fac64[i2].q)], &cbuf2[convert_uint128_base10_char(cbuf2, q128)]);
			ASSERT(HERE, 0,"0");
		}

		p128.d0 = p64; p128.d1 = 0;
		res128 = twopmodq128x2(p128, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR63x64[%u][%u]: twopmodq128x2(%u*%u, %s*%s ) returns non-unity result %s\n", i,i2, fac63[i].p, fac64[i2].p, &cbuf0[convert_uint64_base10_char(cbuf0, fac63[i].q)], &cbuf1[convert_uint64_base10_char(cbuf1, fac64[i2].q)], &cbuf2[convert_uint128_base10_char(cbuf2, q128)]);
			ASSERT(HERE, 0,"0");
		}

		/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
	#if(TRYQ == 4)
		res64 = twopmodq128_q4(p128,q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR_63x64[%u][%u]: (p1*p2, q1*q2) = (%u*%u, %s*%s )\n", i,i2, fac63[i].p, fac64[i2].p, &cbuf0[convert_uint64_base10_char(cbuf0, fac63[i].q)], &cbuf1[convert_uint64_base10_char(cbuf1, fac64[i2].q)]);
			fprintf(stderr,"ERROR: twopmodq128_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#elif(TRYQ == 8)
		res64 = twopmodq128_q8(p128,q128,q128,q128,q128,q128,q128,q128,q128);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR_63x64[%u][%u]: (p1*p2, q1*q2) = (%u*%u, %s*%s )\n", i,i2, fac63[i].p, fac64[i2].p, &cbuf0[convert_uint64_base10_char(cbuf0, fac63[i].q)], &cbuf1[convert_uint64_base10_char(cbuf1, fac64[i2].q)]);
			fprintf(stderr,"ERROR: twopmodq128_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif
	  }
	}
   #ifdef FACTOR_STANDALONE
	printf("\n");
   #endif

	/* 128_C: Construct more 128-bit test factors by multiplying together
	a 64-bit factor q1 of M(p1) and a 64-bit factor q2 of M(p2) (p1 != p2)
	and checking whether q1*q2 divides M(p1*p2).
	*/
   #ifdef FACTOR_STANDALONE
	printf("Testing 64*64-bit factors...I=");
   #endif
	/*for(i = 0; fac64[i].p != 0; i++)*/
	for(i = 0; i < 100; i++)
	{
   #ifdef FACTOR_STANDALONE
	printf("%u...",i);
   #endif
	  for(i2 = 0; fac64[i2].p != 0; i2++)
	  {
		if(fac64[i].p == fac64[i2].p)
			continue;

		p64 = (uint64)fac64[i].p * (uint64)fac64[i2].p;
	#ifdef MUL_LOHI64_SUBROUTINE
		MUL_LOHI64(fac64[i].q, fac64[i2].q,&q128.d0,&q128.d1);
	#else
		MUL_LOHI64(fac64[i].q, fac64[i2].q, q128.d0, q128.d1);
	#endif

		/* Skip the q%(2*p) == 1 and (p%60,q%60) checks, as they don't apply
		to composite factors which are a product of prime factors of
		different-exponent M(p)'s. */

		res128 = twopmodq128(p64, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR_64x64[%u][%u]: twopmodq128(%u*%u, %s*%s ) returns non-unity result %s\n", i,i2, fac64[i].p, fac64[i2].p, &cbuf0[convert_uint64_base10_char(cbuf0, fac64[i].q)], &cbuf1[convert_uint64_base10_char(cbuf1, fac64[i2].q)], &cbuf2[convert_uint128_base10_char(cbuf2, q128)]);
			ASSERT(HERE, 0,"0");
		}

		p128.d0 = p64; p128.d1 = 0;
		res128 = twopmodq128x2(p128, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR64x64[%u][%u]: twopmodq128x2(%u*%u, %s*%s ) returns non-unity result %s\n", i,i2, fac64[i].p, fac64[i2].p, &cbuf0[convert_uint64_base10_char(cbuf0, fac64[i].q)], &cbuf1[convert_uint64_base10_char(cbuf1, fac64[i2].q)], &cbuf2[convert_uint128_base10_char(cbuf2, q128)]);
			ASSERT(HERE, 0,"0");
		}

		/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
	#if(TRYQ == 4)
		res64 = twopmodq128_q4(p128,q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR_64x64[%u][%u]: (p1*p2, q1*q2) = (%u*%u, %s*%s )\n", i,i2, fac64[i].p, fac64[i2].p, &cbuf0[convert_uint64_base10_char(cbuf0, fac64[i].q)], &cbuf1[convert_uint64_base10_char(cbuf1, fac64[i2].q)]);
			fprintf(stderr,"ERROR: twopmodq128_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#elif(TRYQ == 8)
		res64 = twopmodq128_q8(p128,q128,q128,q128,q128,q128,q128,q128,q128);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR_64x64[%u][%u]: (p1*p2, q1*q2) = (%u*%u, %s*%s )\n", i,i2, fac64[i].p, fac64[i2].p, &cbuf0[convert_uint64_base10_char(cbuf0, fac64[i].q)], &cbuf1[convert_uint64_base10_char(cbuf1, fac64[i2].q)]);
			fprintf(stderr,"ERROR: twopmodq128_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif
	  }
	}
   #ifdef FACTOR_STANDALONE
	printf("\n");
   #endif

	/* 128_D: Construct more 128-bit test factors by multiplying together
	a 63-bit factor q1 of M(p1) and a 65-bit factor q2 of M(p2)
	and checking whether q1*q2 divides M(p1*p2).
	*/
   #ifdef FACTOR_STANDALONE
	printf("Testing 63*65-bit factors...I=");
   #endif
	/*for(i = 0; fac63[i].p != 0; i++)*/
	for(i = 0; i < 100; i++)
	{
   #ifdef FACTOR_STANDALONE
	printf("%u...",i);
   #endif
	  for(i2 = 0; fac65[i2].p != 0; i2++)
	  {
		if(fac63[i].p == fac65[i2].p)
			continue;

		p64 = (uint64)fac63[i].p * (uint64)fac65[i2].p;
		x128.d0 = fac65[i2].q;	x128.d1 = 1;	/* Store full q65 in a 128-bit temp for printing purposes */
	#ifdef MUL_LOHI64_SUBROUTINE
		MUL_LOHI64(fac63[i].q, fac65[i2].q,&q128.d0,&q128.d1);
	#else
		MUL_LOHI64(fac63[i].q, fac65[i2].q, q128.d0, q128.d1);
	#endif
		/* fac65.q's assumed to have (hidden) 65th bit = 1, so need
		to add 2^64*fac63.q to the output of MUL_LOHI64 here: */
		q128.d1 += fac63[i].q;
		if(q128.d1 <= fac63[i].q)
		{
			fprintf(stderr,"ERROR_63x65[%u][%u]: (p1*p2, q1*q2) = (%u*%u, %s*%s )\n", i,i2, fac63[i].p, fac65[i2].p, &cbuf0[convert_uint64_base10_char(cbuf0, fac63[i].q)], &cbuf1[convert_uint128_base10_char(cbuf1, x128)]);
			fprintf(stderr," q128.d1 += fac63[i].q overflows!\n");
			ASSERT(HERE, q128.d1 > fac63[i].q,"q128.d1 > fac63[i].q");	/* Make sure sum didn't overflow */
		}

		/* Skip the q%(2*p) == 1 and (p%60,q%60) checks, as they don't apply
		to composite factors which are a product of prime factors of
		different-exponent M(p)'s. */

		res128 = twopmodq128(p64, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR_63x65[%u][%u]: twopmodq128(%u*%u, %s*%s ) returns non-unity result %s\n", i,i2, fac63[i].p, fac65[i2].p, &cbuf0[convert_uint64_base10_char(cbuf0, fac63[i].q)], &cbuf1[convert_uint128_base10_char(cbuf1, x128)], &cbuf2[convert_uint128_base10_char(cbuf2, q128)]);
			ASSERT(HERE, 0,"0");
		}

		p128.d0 = p64; p128.d1 = 0;
		res128 = twopmodq128x2(p128, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR63x65[%u][%u]: twopmodq128x2(%u*%u, %s*%s ) returns non-unity result %s\n", i,i2, fac63[i].p, fac65[i2].p, &cbuf0[convert_uint64_base10_char(cbuf0, fac63[i].q)], &cbuf1[convert_uint128_base10_char(cbuf1, x128)], &cbuf2[convert_uint128_base10_char(cbuf2, q128)]);
			ASSERT(HERE, 0,"0");
		}

		/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
	#if(TRYQ == 4)
		res64 = twopmodq128_q4(p128,q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR_63x65[%u][%u]: (p1*p2, q1*q2) = (%u*%u, %s*%s )\n", i,i2, fac63[i].p, fac65[i2].p, &cbuf0[convert_uint64_base10_char(cbuf0, fac63[i].q)], &cbuf1[convert_uint128_base10_char(cbuf1, x128)]);
			fprintf(stderr,"ERROR: twopmodq128_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#elif(TRYQ == 8)
		res64 = twopmodq128_q8(p128,q128,q128,q128,q128,q128,q128,q128,q128);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR_63x65[%u][%u]: (p1*p2, q1*q2) = (%u*%u, %s*%s )\n", i,i2, fac63[i].p, fac65[i2].p, &cbuf0[convert_uint64_base10_char(cbuf0, fac63[i].q)], &cbuf1[convert_uint128_base10_char(cbuf1, x128)]);
			fprintf(stderr,"ERROR: twopmodq128_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif
	  }
	}
   #ifdef FACTOR_STANDALONE
	printf("\n");
   #endif
  #endif	/* #if FAC_DEBUG */

#ifdef FACTOR_STANDALONE
	printf("Testing 128x2-bit factors...\n");
#endif
	for(i = 0; fac128x2[i].plo != 0; i++)
	{
		p128.d1 = fac128x2[i].phi;	p128.d0 = fac128x2[i].plo;
		q128.d1 = fac128x2[i].d1;	q128.d0 = fac128x2[i].d0;

		/* This uses the generic -bit mod function to calculate q%(2*p): */
		ADD128(p128, p128, two_p128);
		x128 = xmody128(q128, two_p128);
		if(!CMPEQ128(x128, ONE128))
		{
			fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",&cbuf0[convert_uint128_base10_char(cbuf0, p128)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], &cbuf2[convert_uint128_base10_char(cbuf2, x128)]);
			ASSERT(HERE, 0,"0");
		}

		res128 = twopmodq128x2(p128, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR: twopmodq128x2( %s, %s ) returns non-unity result %s\n", &cbuf0[convert_uint128_base10_char(cbuf0, p128)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], &cbuf2[convert_uint128_base10_char(cbuf2, res128)]);
			ASSERT(HERE, 0,"0");
		}
		/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
	#if(TRYQ == 4)
		res64 = twopmodq128_q4(p128,q128,q128,q128,q128);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq128_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint128_base10_char(cbuf0, p128)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#elif(TRYQ == 8)
		res64 = twopmodq128_q8(p128,q128,q128,q128,q128,q128,q128,q128,q128);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq128_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",&cbuf0[convert_uint128_base10_char(cbuf0, p128)], &cbuf1[convert_uint128_base10_char(cbuf1, q128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif
	}

#endif	/* #endif(defined(P2WORD)) */

#if(defined(P3WORD) || defined(P4WORD))

	/* Test 128-bit factors using the 160 and 192-bit modmul routines */
#ifdef FACTOR_STANDALONE
	printf("Testing 128x2-bit factors using 160 and 192-bit modmul routines...\n");
#endif
	for(i = 0; fac128x2[i].plo != 0; i++)
	{
		p192.d2 = 0; p192.d1 = fac128x2[i].phi;	p192.d0 = fac128x2[i].plo;
		q192.d2 = 0; q192.d1 = fac128x2[i].d1;	q192.d0 = fac128x2[i].d0;

		/* This uses the generic -bit mod function to calculate q%(2*p): */
		ADD192(p192, p192, two_p192);
		x192 = xmody192(q192, two_p192);
		if(!CMPEQ192(x192, ONE192))
		{
			fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",&cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)], &cbuf2[convert_uint192_base10_char(cbuf2, x192)]);
			ASSERT(HERE, 0,"0");
		}

		res192 = twopmodq160(p192, q192);
		if(!CMPEQ192(ONE192,res192))
		{
			fprintf(stderr,"ERROR: twopmodq160( %s, %s ) returns non-unity result %s\n", &cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)], &cbuf2[convert_uint192_base10_char(cbuf2, res192)]);
			ASSERT(HERE, 0,"0");
		}

		res192 = twopmodq192(p192, q192);
		if(!CMPEQ192(ONE192,res192))
		{
			fprintf(stderr,"ERROR: twopmodq192( %s, %s ) returns non-unity result! %sn", &cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)], &cbuf2[convert_uint192_base10_char(cbuf2, res192)]);
			ASSERT(HERE, 0,"0");
		}

		/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
	#if(TRYQ == 4)
/*
		res64 = twopmodq160_q4(p192,q192,q192,q192,q192);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq160_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n", &cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
*/
		res64 = twopmodq192_q4(p192,q192,q192,q192,q192);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq192_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n", &cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#elif(TRYQ == 8)
/*
		res64 = twopmodq160_q8(p192,q192,q192,q192,q192,q192,q192,q192,q192);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq160_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n", &cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
*/
		res64 = twopmodq192_q8(p192,q192,q192,q192,q192,q192,q192,q192,q192);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq192_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n", &cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif
	}

	/* Test 160-bit factors using the 160 and 192-bit modmul routines */
#ifdef FACTOR_STANDALONE
	printf("Testing 160-bit factors using 160 and 192-bit modmul routines...\n");
#endif
	for(i = 0; fac160[i].p != 0; i++)
	{
		p64 = fac160[i].p;
		q192.d2 = fac160[i].d2; q192.d1 = fac160[i].d1; q192.d0 = fac160[i].d0;

		two64modp = 0x8000000000000000ull%p64;
		two64modp = (two64modp + two64modp)%p64;
		/* Really large factors may have high part sufficiently large that q.d2*two64modp
		overflows 64 bits, so stick an extra mod-p in there: */
		if((((q192.d2%p64)*two64modp + q192.d1%p64)*two64modp + q192.d0%p64)%p64 != 1)
		{
			fprintf(stderr,"ERROR: q != 1 modulo p for M( %s ), q = %s \n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)]);
			ASSERT(HERE, 0,"0");
		}

		/* This uses the generic 192-bit mod function to calculate q%(2*p): */
		p192.d0 = p64;	p192.d1 = p192.d2 = 0;
		ADD192(p192, p192, two_p192);
		x192 = xmody192(q192, two_p192);
		if(!CMPEQ192(x192, ONE192))
		{
			fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",&cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)], &cbuf2[convert_uint192_base10_char(cbuf2, x192)]);
			ASSERT(HERE, 0,"0");
		}
/*
		res192 = twopmodq160(p192, q192);
		if(!CMPEQ192(ONE192,res192))
		{
			fprintf(stderr,"ERROR: twopmodq160( %s, %s ) returns non-unity result %s\n", &cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)], &cbuf2[convert_uint192_base10_char(cbuf2, res192)]);
			ASSERT(HERE, 0,"0");
		}
*/
		res192 = twopmodq192(p192, q192);
		if(!CMPEQ192(ONE192,res192))
		{
			fprintf(stderr,"ERROR: twopmodq192( %s, %s ) returns non-unity result %s\n", &cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)], &cbuf2[convert_uint192_base10_char(cbuf2, res192)]);
			ASSERT(HERE, 0,"0");
		}

		/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
	#if(TRYQ == 4)
/*
		res64 = twopmodq160_q4(p192,q192,q192,q192,q192);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq160_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n", &cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
*/
		res64 = twopmodq192_q4(p192,q192,q192,q192,q192);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq192_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n", &cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#elif(TRYQ == 8)
/*
		res64 = twopmodq160_q8(p192,q192,q192,q192,q192,q192,q192,q192,q192);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq160_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n", &cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
*/
		res64 = twopmodq192_q8(p192,q192,q192,q192,q192,q192,q192,q192,q192);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq192_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n", &cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif
	}

#endif	/* #if(defined(P3WORD) || defined(P4WORD)) */

#if(defined(P3WORD) || defined(P4WORD))

	/* Test 192-bit factors using the 192 and 256-bit modmul routines */
	/* 192_A: prime factors < 2^192: */
#ifdef FACTOR_STANDALONE
	printf("Testing 192-bit factors using the 192 and 256-bit modmul routines...\n");
#endif
	for(i = 0; fac192[i].p != 0; i++)
	{
		p64 = fac192[i].p;
		q192.d2 = fac192[i].d2; q192.d1 = fac192[i].d1; q192.d0 = fac192[i].d0;

		two64modp = 0x8000000000000000ull%p64;
		two64modp = (two64modp + two64modp)%p64;
		/* Really large factors may have high part sufficiently large that q.d2*two64modp
		overflows 64 bits, so stick an extra mod-p in there: */
		if((((q192.d2%p64)*two64modp + q192.d1%p64)*two64modp + q192.d0%p64)%p64 != 1)
		{
			fprintf(stderr,"ERROR: q != 1 modulo p for M( %s ), q = %s \n", &cbuf0[convert_uint64_base10_char(cbuf0, p64)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)]);
			ASSERT(HERE, 0,"0");
		}

		/* This uses the generic 192-bit mod function to calculate q%(2*p): */
		p192.d0 = p64;	p192.d1 = p192.d2 = 0;
		ADD192(p192, p192, two_p192);
		x192 = xmody192(q192, two_p192);
		if(!CMPEQ192(x192, ONE192))
		{
			fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",&cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)], &cbuf2[convert_uint192_base10_char(cbuf2, x192)]);
			ASSERT(HERE, 0,"0");
		}

		res192 = twopmodq192(p192, q192);
		if(!CMPEQ192(ONE192,res192))
		{
			fprintf(stderr,"ERROR: twopmodq192( %s, %s ) returns non-unity result %s\n", &cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)], &cbuf2[convert_uint192_base10_char(cbuf2, res192)]);
			ASSERT(HERE, 0,"0");
		}

		/* This uses the generic 256-bit mod function to calculate q%(2*p): */
		p256.d0 = p64;	p256.d1 = p256.d2 = p256.d3 = 0;
		q256.d0 = q192.d0;
		q256.d1 = q192.d1;
		q256.d2 = q192.d2;
		q256.d3 =       0;
		ADD256(p256, p256, two_p256);
		x256 = xmody256(q256, two_p256);
		if(!CMPEQ256(x256, ONE256))
		{
			fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",&cbuf0[convert_uint256_base10_char(cbuf0, p256)], &cbuf1[convert_uint256_base10_char(cbuf1, q256)], &cbuf2[convert_uint256_base10_char(cbuf2, x256)]);
			ASSERT(HERE, 0,"0");
		}

		res256 = twopmodq256(p256, q256);
		if(!CMPEQ256(ONE256,res256))
		{
			fprintf(stderr,"ERROR: twopmodq256( %s, %s ) returns non-unity result %s\n", &cbuf0[convert_uint256_base10_char(cbuf0, p256)], &cbuf1[convert_uint256_base10_char(cbuf1, q256)], &cbuf2[convert_uint256_base10_char(cbuf2, res256)]);
			ASSERT(HERE, 0,"0");
		}

		/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
	#if(TRYQ == 4)
		res64 = twopmodq192_q4(p192,q192,q192,q192,q192);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq192_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n", &cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#elif(TRYQ == 8)
		res64 = twopmodq192_q8(p192,q192,q192,q192,q192,q192,q192,q192,q192);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq192_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n", &cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif
	}

#endif

#if(defined(P3WORD))

	/*** Only do this time-consuming series of 192-bit factor tests in debug mode: ***/
  #if(FAC_DEBUG)
	/* 192_B: Construct more 192-bit test factors by multiplying together
	a 63-bit factor q1 of M(p1), a 64-bit factor q2 of M(p2) and a
	65-bit factor q3 of M(p3) and checking whether q1*q2*q3 divides M(p1*p2*p3).
	*/
   #ifdef FACTOR_STANDALONE
	printf("Testing 63*64*65-bit factors: I = ");
   #endif
	/*for(i = 0; fac63[i].p != 0; i++)*/
	for(i = 0; i < 5; i++)
	{
   #ifdef FACTOR_STANDALONE
	printf("%u...",i);
   #endif
	  /*for(i2 = 0; fac65[i2].p != 0; i2++)*/
	  for(i2 = 0; i2 < 100; i2++)
	  {
		if(fac63[i].p == fac65[i2].p)
			continue;

		p64 = (uint64)fac63[i].p * (uint64)fac65[i2].p;
		x128.d0 = fac65[i2].q;	x128.d1 = 1;	/* Store full q65 in a 128-bit temp for printing purposes */
	#ifdef MUL_LOHI64_SUBROUTINE
		MUL_LOHI64(fac63[i].q, fac65[i2].q,&q128.d0,&q128.d1);
	#else
		MUL_LOHI64(fac63[i].q, fac65[i2].q, q128.d0, q128.d1);
	#endif
		/* fac65.q's assumed to have (hidden) 65th bit = 1, so need
		to add 2^64*fac63.q to the output of MUL_LOHI64 here: */
		q128.d1 += fac63[i].q;
		if(q128.d1 <= fac63[i].q)
		{
			fprintf(stderr,"ERROR192_63x65[%u][%u]: (p1*p2, q1*q2) = (%u*%u, %s*%s )\n", i,i2, fac63[i].p, fac65[i2].p, &cbuf0[convert_uint64_base10_char(cbuf0, fac63[i].q)], &cbuf1[convert_uint128_base10_char(cbuf1, x128)]);
			fprintf(stderr," q128.d1 += fac63[i].q overflows!\n");
			ASSERT(HERE, q128.d1 > fac63[i].q,"q128.d1 > fac63[i].q");	/* Make sure sum didn't overflow */
		}

		/* Now multiply the 128-bit 63x65-bit factor product by each 64-bit test factor in turn. */
		/*for(i3 = 0; fac64[i3].p != 0; i3++)*/
		for(i3 = 0; i3 < 100; i3++)
		{
			if(fac64[i3].p == fac63[i].p || fac64[i3].p == fac65[i2].p)
				continue;

			/* Since the product of three test exponents will generally
			overflow 64-bits, store that in the lower 2 words of the p192 variable:
			*/
		#ifdef MUL_LOHI64_SUBROUTINE
			/* Multiply to get 3-exponent product: */
			MUL_LOHI64(p64, fac64[i3].p,&p192.d0,&p192.d1);	p192.d2 = 0;
			/* Low  128 bits of the 192-bit 3-factor product: */
			MUL_LOHI64(q128.d0,fac64[i3].q,&q192.d0,&q192.d1);
			/* High 128 bits of the 192-bit 3-factor product: */
			MUL_LOHI64(q128.d1,fac64[i3].q,  &tmp64,&q192.d2);	q192.d1 += tmp64;	q192.d2 += (q192.d1 < tmp64);
		#else
			/* Multiply to get 3-exponent product: */
			MUL_LOHI64(p64, fac64[i3].p, p192.d0, p192.d1);	p192.d2 = 0;
			/* Low  128 bits of the 192-bit 3-factor product: */
			MUL_LOHI64(q128.d0,fac64[i3].q, q192.d0, q192.d1);
			/* High 128 bits of the 192-bit 3-factor product: */
			MUL_LOHI64(q128.d1,fac64[i3].q,   tmp64, q192.d2);	q192.d1 += tmp64;	q192.d2 += (q192.d1 < tmp64);
		#endif

			/* Skip the q%(2*p) == 1 and (p%60,q%60) checks, as they don't apply
			to composite factors which are a product of prime factors of
			different-exponent M(p)'s. */

			res192 = twopmodq192(p192, q192);
			if(!CMPEQ192(ONE192,res192))
			{
				fprintf(stderr,"ERROR_63x65x64[%u][%u][%u]: twopmodq192(%u*%u*%u = %s, %s*%s*%s = %s) returns non-unity result %s\n", i,i2,i3, fac63[i].p, fac65[i2].p, fac64[i3].p, &cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint64_base10_char(cbuf1, fac63[i].q)], &cbuf2[convert_uint128_base10_char(cbuf2, x128)], &cbuf3[convert_uint64_base10_char(cbuf3, fac64[i3].q)], &cbuf4[convert_uint192_base10_char(cbuf4, q192)], &cbuf5[convert_uint192_base10_char(cbuf5, res192)]);
				ASSERT(HERE, 0,"0");
			}

		p256.d0 = p192.d0;	q256.d0 = q192.d0;
		p256.d1 = p192.d1;	q256.d1 = q192.d1;
		p256.d2 = p192.d2;	q256.d2 = q192.d2;
		p256.d3 =       0;	q256.d3 =       0;
		res256 = twopmodq256(p256, q256);
		if(!CMPEQ256(ONE256,res256))
		{
			fprintf(stderr,"ERROR_63x65x64[%u][%u][%u]: twopmodq256(%u*%u*%u = %s, %s*%s*%s = %s) returns non-unity result %s\n", i,i2,i3, fac63[i].p, fac65[i2].p, fac64[i3].p, &cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint64_base10_char(cbuf1, fac63[i].q)], &cbuf2[convert_uint128_base10_char(cbuf2, x128)], &cbuf3[convert_uint64_base10_char(cbuf3, fac64[i3].q)], &cbuf4[convert_uint256_base10_char(cbuf4, q256)], &cbuf5[convert_uint256_base10_char(cbuf5, res256)]);
			ASSERT(HERE, 0,"0");
		}

			/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
		#if(TRYQ == 4)
			res64 = twopmodq192_q4(p192,q192,q192,q192,q192);
			if(res64 != 15)
			{
				fprintf(stderr,"ERROR_63x65x64[%u][%u][%u]: (p1*p2*p3, q1*q2*q3) = (%u*%u*%u, %s*%s*%s )\n", i,i2,i3, fac63[i].p, fac65[i2].p, fac64[i3].p, &cbuf1[convert_uint64_base10_char(cbuf1, fac63[i].q)], &cbuf2[convert_uint128_base10_char(cbuf2, x128)], &cbuf3[convert_uint64_base10_char(cbuf3, fac64[i3].q)]);
				fprintf(stderr,"ERROR: twopmodq192_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1,q192)], (uint32)res64);
				ASSERT(HERE, 0,"0");
			}
		#elif(TRYQ == 8)
			res64 = twopmodq192_q8(p192,q192,q192,q192,q192,q192,q192,q192,q192);
			if(res64 != 255)
			{
				fprintf(stderr,"ERROR_63x65x64[%u][%u][%u]: (p1*p2*p3, q1*q2*q3) = (%u*%u*%u, %s*%s*%s )\n", i,i2,i3, fac63[i].p, fac65[i2].p, fac64[i3].p, &cbuf1[convert_uint64_base10_char(cbuf1, fac63[i].q)], &cbuf2[convert_uint128_base10_char(cbuf2, x128)], &cbuf3[convert_uint64_base10_char(cbuf3, fac64[i3].q)]);
				fprintf(stderr,"ERROR: twopmodq192_q8( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",&cbuf0[convert_uint192_base10_char(cbuf0, p192)], &cbuf1[convert_uint192_base10_char(cbuf1,q192)], (uint32)res64);
				ASSERT(HERE, 0,"0");
			}
		#endif
		}
	  }
	}
   #ifdef FACTOR_STANDALONE
	printf("\n");
   #endif
  #endif	/* #if FAC_DEBUG */

#endif	/* #if(defined(P3WORD)) */


#if(defined(P4WORD))

  #ifdef FACTOR_STANDALONE
	printf("Testing 256-bit factors...\n");
  #endif
	for(i = 0; i < ntest256; i++)
	{
		p256 = convert_base10_char_uint256(fac256->p);
		q256 = convert_base10_char_uint256(fac256->q);
		res256 = twopmodq256(p256, q256);
		if(!CMPEQ256(ONE256,res256))
		{
			fprintf(stderr,"ERROR: twopmodq256( %s, %s ) returns non-unity result %s\n", &cbuf0[convert_uint256_base10_char(cbuf0, p256)], &cbuf1[convert_uint256_base10_char(cbuf1, q256)], &cbuf2[convert_uint256_base10_char(cbuf2, res256)]);
			ASSERT(HERE, 0,"0");
		}
	}

	/*** Only do this time-consuming series of 256-bit factor tests in debug mode: ***/
  #if(FAC_DEBUG)
	/* Construct 256-bit test factors by multiplying together a randomly chosen quartet
	consisting of a 63-bit factor q1 of M(p1), 2 (distinct) 64-bit factors q2 of M(p2) and q3 of M(p3)
	and a 65-bit factor q4 of M(p3) and checking whether q1*q2*q3*q4 divides M(p1*p2*p3*p4).
	*/
	#define NTEST256	1000000

   #ifdef FACTOR_STANDALONE
	printf("Testing 63*64*64*65-bit factors: I = ");
   #endif
	/*for(i = 0; fac63[i].p != 0; i++)*/
	for(i = 0; i < 5; i++)
	{
   #ifdef FACTOR_STANDALONE
	printf("%u...",i);
   #endif
	  /*for(i2 = 0; fac65[i2].p != 0; i2++)*/
	  for(i2 = 0; i2 < 100; i2++)
	  {
		if(fac63[i].p == fac65[i2].p)
			continue;

		p63 = (uint64)fac63[i].p * (uint64)fac65[i2].p;
		x128.d0 = fac65[i2].q;	x128.d1 = 1;	/* Store full q65 in a 128-bit temp for printing purposes */
	#ifdef MUL_LOHI64_SUBROUTINE
		MUL_LOHI64(fac63[i].q, fac65[i2].q,&q128.d0,&q128.d1);
	#else
		MUL_LOHI64(fac63[i].q, fac65[i2].q, q128.d0, q128.d1);
	#endif
		/* fac65.q's assumed to have (hidden) 65th bit = 1, so need
		to add 2^64*fac63.q to the output of MUL_LOHI64 here: */
		q128.d1 += fac63[i].q;
		if(q128.d1 <= fac63[i].q)
		{
			fprintf(stderr,"ERROR128_63x65[%u][%u]: (p1*p2, q1*q2) = (%u*%u, %s*%s )\n", i,i2, fac63[i].p, fac65[i2].p, &cbuf0[convert_uint64_base10_char(cbuf0, fac63[i].q)], &cbuf1[convert_uint128_base10_char(cbuf1, x128)]);
			fprintf(stderr," q128.d1 += fac63[i].q overflows!\n");
			ASSERT(HERE, q128.d1 > fac63[i].q,"q128.d1 > fac63[i].q");	/* Make sure sum didn't overflow */
		}

		/* Now multiply the 128-bit 63x65-bit factor product by the product of each pair of 64-bit test factors in turn. */
		srand(1);	/* Init stdlib RNG */
		/*for(i3 = 0; fac64[i3].p != 0; i3++)*/
		for(i3 = 0; i3 < 30; i3++)
		{
			ii = rand()%100;
			if(fac64[ii].p == fac63[i].p || fac64[ii].p == fac65[i2].p)
				continue;

			for(i4 = 0; i4 < 30; i4++)
			{
				jj = rand()%100;
				if(fac64[jj].p == fac64[ii].p)
					continue;

				p64 = (uint64)fac64[ii].p * (uint64)fac64[jj].p;
				/* Multiply the two 2-exponent products (p63 and p64) to get 4-exponent product: */
				MUL_LOHI64(p63,p64,&p256.d0,&p256.d1);	p256.d3 = p256.d2 = 0;

				/* Now do a pair of 64-bit scalar*vector MULs to build the 256-bit factor product: */
				q256.d2 = mi64_mul_scalar(&q128.d0, fac64[ii].q, &q256.d0, 2);
				q256.d3 = mi64_mul_scalar(&q256.d0, fac64[jj].q, &q256.d0, 3);

				res256 = twopmodq256(p256, q256);
				if(!CMPEQ256(ONE256,res256))
				{
					fprintf(stderr,"ERROR_63x65x64x64[%u][%u][%u][%u]: twopmodq256(%u*%u*%u*%u = %s, %s*%s*%s*%s = %s) returns non-unity result %s\n", i,i2,i3,i4, fac63[i].p, fac65[i2].p, fac64[ii].p, fac64[jj].p, &cbuf0[convert_uint256_base10_char(cbuf0, p256)], &cbuf1[convert_uint64_base10_char(cbuf1, fac63[i].q)], &cbuf2[convert_uint128_base10_char(cbuf2, x128)], &cbuf3[convert_uint64_base10_char(cbuf3, fac64[ii].q)], &cbuf4[convert_uint64_base10_char(cbuf4, fac64[jj].q)], &cbuf5[convert_uint256_base10_char(cbuf5, q256)], &cbuf6[convert_uint256_base10_char(cbuf6, res256)]);
					ASSERT(HERE, 0,"0");
				}
			}
		}
	  }
	}
   #ifdef FACTOR_STANDALONE
	printf("\n");
   #endif
  #endif	/* #if FAC_DEBUG */

#endif	/* #if(defined(P4WORD)) */

#ifdef FACTOR_STANDALONE
	printf("Factoring self-tests completed successfully.\n");
#endif
	return 0;
}

/******************/

/* For an exponent p and a factor index k, both mod 60, returns the factoring
pass number (in unit-offset form, i.e. 1-16) on which the factor should occur
if it's one of the valid combinations of p%60 and k%60. */
uint32 CHECK_PKMOD60(uint32 p, uint32 k)
{
if(p== 1){ if(k==0)return 16; else if(k== 3)return 1; else if(k== 8)return 2; else if(k==11)return 3; else if(k==15)return 4; else if(k==20)return 5; else if(k==23)return 6; else if(k==24)return 7; else if(k==35)return 8; else if(k==36)return 9; else if(k==39)return 10; else if(k==44)return 11; else if(k==48)return 12; else if(k==51)return 13; else if(k==56)return 14; else if(k==59)return 15; else ASSERT(HERE, 0,"Illegal (k,p)%60 pair in CHECK_PKMOD60"); };
if(p== 7){ if(k==0)return 16; else if(k== 5)return 1; else if(k== 8)return 2; else if(k== 9)return 3; else if(k==12)return 4; else if(k==17)return 5; else if(k==20)return 6; else if(k==24)return 7; else if(k==29)return 8; else if(k==32)return 9; else if(k==33)return 10; else if(k==44)return 11; else if(k==45)return 12; else if(k==48)return 13; else if(k==53)return 14; else if(k==57)return 15; else ASSERT(HERE, 0,"Illegal (k,p)%60 pair in CHECK_PKMOD60"); };
if(p==11){ if(k==0)return 16; else if(k== 1)return 1; else if(k== 4)return 2; else if(k== 9)return 3; else if(k==13)return 4; else if(k==16)return 5; else if(k==21)return 6; else if(k==24)return 7; else if(k==25)return 8; else if(k==28)return 9; else if(k==33)return 10; else if(k==36)return 11; else if(k==40)return 12; else if(k==45)return 13; else if(k==48)return 14; else if(k==49)return 15; else ASSERT(HERE, 0,"Illegal (k,p)%60 pair in CHECK_PKMOD60"); };
if(p==13){ if(k==0)return 16; else if(k== 3)return 1; else if(k== 8)return 2; else if(k==11)return 3; else if(k==12)return 4; else if(k==15)return 5; else if(k==20)return 6; else if(k==23)return 7; else if(k==27)return 8; else if(k==32)return 9; else if(k==35)return 10; else if(k==36)return 11; else if(k==47)return 12; else if(k==48)return 13; else if(k==51)return 14; else if(k==56)return 15; else ASSERT(HERE, 0,"Illegal (k,p)%60 pair in CHECK_PKMOD60"); };
if(p==17){ if(k==0)return 16; else if(k== 3)return 1; else if(k== 4)return 2; else if(k== 7)return 3; else if(k==12)return 4; else if(k==15)return 5; else if(k==19)return 6; else if(k==24)return 7; else if(k==27)return 8; else if(k==28)return 9; else if(k==39)return 10; else if(k==40)return 11; else if(k==43)return 12; else if(k==48)return 13; else if(k==52)return 14; else if(k==55)return 15; else ASSERT(HERE, 0,"Illegal (k,p)%60 pair in CHECK_PKMOD60"); };
if(p==19){ if(k==0)return 16; else if(k== 5)return 1; else if(k== 9)return 2; else if(k==12)return 3; else if(k==17)return 4; else if(k==20)return 5; else if(k==21)return 6; else if(k==24)return 7; else if(k==29)return 8; else if(k==32)return 9; else if(k==36)return 10; else if(k==41)return 11; else if(k==44)return 12; else if(k==45)return 13; else if(k==56)return 14; else if(k==57)return 15; else ASSERT(HERE, 0,"Illegal (k,p)%60 pair in CHECK_PKMOD60"); };
if(p==23){ if(k==0)return 16; else if(k== 1)return 1; else if(k==12)return 2; else if(k==13)return 3; else if(k==16)return 4; else if(k==21)return 5; else if(k==25)return 6; else if(k==28)return 7; else if(k==33)return 8; else if(k==36)return 9; else if(k==37)return 10; else if(k==40)return 11; else if(k==45)return 12; else if(k==48)return 13; else if(k==52)return 14; else if(k==57)return 15; else ASSERT(HERE, 0,"Illegal (k,p)%60 pair in CHECK_PKMOD60"); };
if(p==29){ if(k==0)return 16; else if(k== 4)return 1; else if(k== 7)return 2; else if(k==12)return 3; else if(k==15)return 4; else if(k==16)return 5; else if(k==19)return 6; else if(k==24)return 7; else if(k==27)return 8; else if(k==31)return 9; else if(k==36)return 10; else if(k==39)return 11; else if(k==40)return 12; else if(k==51)return 13; else if(k==52)return 14; else if(k==55)return 15; else ASSERT(HERE, 0,"Illegal (k,p)%60 pair in CHECK_PKMOD60"); };
if(p==31){ if(k==0)return 16; else if(k== 5)return 1; else if(k== 8)return 2; else if(k== 9)return 3; else if(k==20)return 4; else if(k==21)return 5; else if(k==24)return 6; else if(k==29)return 7; else if(k==33)return 8; else if(k==36)return 9; else if(k==41)return 10; else if(k==44)return 11; else if(k==45)return 12; else if(k==48)return 13; else if(k==53)return 14; else if(k==56)return 15; else ASSERT(HERE, 0,"Illegal (k,p)%60 pair in CHECK_PKMOD60"); };
if(p==37){ if(k==0)return 16; else if(k== 3)return 1; else if(k== 8)return 2; else if(k==12)return 3; else if(k==15)return 4; else if(k==20)return 5; else if(k==23)return 6; else if(k==24)return 7; else if(k==27)return 8; else if(k==32)return 9; else if(k==35)return 10; else if(k==39)return 11; else if(k==44)return 12; else if(k==47)return 13; else if(k==48)return 14; else if(k==59)return 15; else ASSERT(HERE, 0,"Illegal (k,p)%60 pair in CHECK_PKMOD60"); };
if(p==41){ if(k==0)return 16; else if(k== 3)return 1; else if(k== 4)return 2; else if(k==15)return 3; else if(k==16)return 4; else if(k==19)return 5; else if(k==24)return 6; else if(k==28)return 7; else if(k==31)return 8; else if(k==36)return 9; else if(k==39)return 10; else if(k==40)return 11; else if(k==43)return 12; else if(k==48)return 13; else if(k==51)return 14; else if(k==55)return 15; else ASSERT(HERE, 0,"Illegal (k,p)%60 pair in CHECK_PKMOD60"); };
if(p==43){ if(k==0)return 16; else if(k== 5)return 1; else if(k== 8)return 2; else if(k==12)return 3; else if(k==17)return 4; else if(k==20)return 5; else if(k==21)return 6; else if(k==32)return 7; else if(k==33)return 8; else if(k==36)return 9; else if(k==41)return 10; else if(k==45)return 11; else if(k==48)return 12; else if(k==53)return 13; else if(k==56)return 14; else if(k==57)return 15; else ASSERT(HERE, 0,"Illegal (k,p)%60 pair in CHECK_PKMOD60"); };
if(p==47){ if(k==0)return 16; else if(k== 4)return 1; else if(k== 9)return 2; else if(k==12)return 3; else if(k==13)return 4; else if(k==24)return 5; else if(k==25)return 6; else if(k==28)return 7; else if(k==33)return 8; else if(k==37)return 9; else if(k==40)return 10; else if(k==45)return 11; else if(k==48)return 12; else if(k==49)return 13; else if(k==52)return 14; else if(k==57)return 15; else ASSERT(HERE, 0,"Illegal (k,p)%60 pair in CHECK_PKMOD60"); };
if(p==49){ if(k==0)return 16; else if(k==11)return 1; else if(k==12)return 2; else if(k==15)return 3; else if(k==20)return 4; else if(k==24)return 5; else if(k==27)return 6; else if(k==32)return 7; else if(k==35)return 8; else if(k==36)return 9; else if(k==39)return 10; else if(k==44)return 11; else if(k==47)return 12; else if(k==51)return 13; else if(k==56)return 14; else if(k==59)return 15; else ASSERT(HERE, 0,"Illegal (k,p)%60 pair in CHECK_PKMOD60"); };
if(p==53){ if(k==0)return 16; else if(k== 3)return 1; else if(k== 7)return 2; else if(k==12)return 3; else if(k==15)return 4; else if(k==16)return 5; else if(k==27)return 6; else if(k==28)return 7; else if(k==31)return 8; else if(k==36)return 9; else if(k==40)return 10; else if(k==43)return 11; else if(k==48)return 12; else if(k==51)return 13; else if(k==52)return 14; else if(k==55)return 15; else ASSERT(HERE, 0,"Illegal (k,p)%60 pair in CHECK_PKMOD60"); };
if(p==59){ if(k==0)return 16; else if(k== 1)return 1; else if(k== 4)return 2; else if(k== 9)return 3; else if(k==12)return 4; else if(k==16)return 5; else if(k==21)return 6; else if(k==24)return 7; else if(k==25)return 8; else if(k==36)return 9; else if(k==37)return 10; else if(k==40)return 11; else if(k==45)return 12; else if(k==49)return 13; else if(k==52)return 14; else if(k==57)return 15; else ASSERT(HERE, 0,"Illegal (k,p)%60 pair in CHECK_PKMOD60"); };
return 0;
}

