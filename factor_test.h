/*******************************************************************************
*                                                                              *
*   (C) 1997-2012 by Ernst W. Mayer.                                           *
*                                                                              *
*  This program is free software; you can redistribute it and/or modify it     *
*  under the terms of the GNU General Public License as published by the       *
*  Free Software Foundation; either version 2 of the License, or (at your      *
*  option) any later version.                                                  *
*                                                                              *
*  This program is distributed in the hope that it will be useful, but WITHOUT *
*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or       *
*  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for   *
*  more details.                                                               *
*                                                                              *
*  You should have received a copy of the GNU General Public License along     *
*  with this program; see the file GPL.txt.  If not, you may view one at       *
*  http://www.fsf.org/licenses/licenses.html, or obtain one by writing to the  *
*  Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA     *
*  02111-1307, USA.                                                            *
*                                                                              *
*******************************************************************************/

/*** This file is designed to be directly included by factor.c ***/
/*
Perform factor self-tests.
*/
int test_fac()
{
	/* Testcases for factors up to 65 bits are in the form {exponent, factor} pairs where, for 65-bit factors, the q-entry
	of the struct is the lowest 64 bits of the true factor (i.e. if it's a 65-bit factor, we infer the leading ones bit.)

	Testcases for factors up to 96 bits store all bits of the factor in a uint96.
	*/
	struct testFac{
		uint32 p;
		uint64 q;
	};

	struct testFac96{
		uint32 p;
		uint32 d1;
		uint64 d0;
	};

	struct testFac128{
		uint32 p;
		uint64 d1;
		uint64 d0;
	};

	struct testFac128x2{
		uint64 phi;
		uint64 plo;
		uint64 d1;
		uint64 d0;
	};

	struct testFac160{
		uint32 p;
		uint64 d2;
		uint64 d1;
		uint64 d0;
	};

	struct testFac192{
		uint32 p;
		uint64 d2;
		uint64 d1;
		uint64 d0;
	};

	struct testFac256{
		char p[80];
		char q[80];
	};

	/* Exponent/factor pair arrays for self-tests of various bitlengths. Must pad each array with a trailing pair of zeros. */

	/* Testcases with factors < 2^63 = 9223372036854775808: */
	static const struct testFac fac63[] =
	{
		{16219289, 7464112771264190017ull},{16230061, 7074289273913679991ull},{16232017, 7411932855077041073ull},{16232537, 6692065114888767967ull},{16233463, 7281938355280163287ull},
		{16238797, 7160849857727202529ull},{16241383, 8321268976801733153ull},{16247081, 6851345661512506279ull},{16264097, 6651246518968801591ull},{16270871, 8750884836637970639ull},
		{16273021, 8530948234727688607ull},{16275769, 8656222760818941631ull},{16276951, 8420763231476654791ull},{16287319, 7856663174122645703ull},{16291313, 7319751180156635263ull},
		{16292609, 9092939873876576857ull},{16304579, 8962807897733335697ull},{16309159, 7820104075051972591ull},{16310741, 7118960435061194119ull},{16315669, 7962842793467390041ull},
		{16317043, 8806735752647806361ull},{16323829, 8450744492397916153ull},{16336891, 7155399841291768831ull},{16344187, 8776703566703469847ull},{16344221, 8505188423818202153ull},
		{16344301, 7953229808761833919ull},{16357703, 7108223032778653207ull},{16372787, 6619838028511456999ull},{16373947, 7438987258875431921ull},{16377859, 8096713054586341063ull},
		{16384493, 7028583389392946873ull},{16385287, 7046001957550504913ull},{16386353, 7907418222099564433ull},{16393847, 7396873540638046079ull},{16402271, 8752890924846173591ull},
		{16410893, 6781869984316584449ull},{16413157, 8150367549328875839ull},{16419283, 8379034208328962239ull},{16419373, 4590586513826579537ull},{16421459, 1904620098914423441ull},
		{16421773, 1919634559953409777ull},{16422079, 1617297709004215951ull},{16422143,  351667921325618969ull},{16422587,  347957656837497407ull},{16422607, 5079529025476239473ull},
		{16422617,  877523758063210759ull},{16422641, 1904594759403697657ull},{16423129,  639383433125674231ull},{16424033,  876833185557798433ull},{16425109, 6929484154075657241ull},
		{16425967, 4868798027321748281ull},{16426297,  664300343615680241ull},{16427093,  647622110489212231ull},{16430203, 5947021049954262703ull},{16430263,  531416416863478007ull},
		{16430567, 6714238248345211081ull},{16430759, 1040588024141145631ull},{16431221, 7515765841945454129ull},{16431301,  769260698510760751ull},{16432147, 2775802912966282649ull},
		{16432331, 4485830256538297097ull},{16432817, 7811250160082452639ull},{16433741,  373097143060190383ull},{16433777, 7025465442860330327ull},{16433867, 2122188836804569639ull},
		{16433881, 6274909219403483887ull},{16433887, 1178275771257792817ull},{16435187,  404893783099670863ull},{16435207, 5706498478502752097ull},{16436087, 1249687921657073809ull},
		{16436681, 5418270029220506569ull},{16437227,  880527514744739041ull},{16437803, 1050659558835031697ull},{16438349, 1152641923853707873ull},{16438459, 8494499222030730001ull},
		{16438733,  897957128490827369ull},{16438921,  355469347041668513ull},{16438931, 6363980290034318527ull},{16439183,  727804660219798193ull},{16439531,  381922949073827639ull},
		{16440629,  551592949703045713ull},{16441427,  514743839833790687ull},{16441723, 7826810543654605759ull},{16442941,  852026135819507489ull},{16443001,  680825060844814393ull},
		{16443893, 1277077523412980857ull},{16444399,  403946809003560737ull},{16445029, 1313020171506418103ull},{16445449, 4532532117087171361ull},{16445881,  314816963337354217ull},
		{16445999, 4000347492271511999ull},{16447793, 3909966094211431663ull},{16448987, 6702585753220580233ull},{16449113, 1395256032300764801ull},{16449187,  371179628750936801ull},
		{16449593, 1283294140172967047ull},{16449661,  382963805761197047ull},{16449827,  589484546028463361ull},{16450703, 8740277214666380953ull},{16451681, 2707820247743716409ull},
		{17715697, 2405285686624656961ull},{17716921, 7862694219641149649ull},{17725703, 1709828509468925647ull},{17729219, 1818195666940512361ull},{17732269, 4749139467781751281ull},
		{17732531, 8620020444320802169ull},{17741401, 1588232881627535471ull},{17741771, 2800144830835674079ull},{17743751, 2269674038404230343ull},{17747491, 8598509628823480727ull},
		{17748257, 9087140485434854489ull},{17750333, 7251833404705913977ull},{17751163, 3820553770628769199ull},{17752633, 4704959116091028679ull},{17753363, 7075257636385056583ull},
		{17754259, 7297159751574473761ull},{17758189, 4396811225247180479ull},{17760511, 4745090588707286561ull},{17760893, 2853041236643552393ull},{17765563, 1672908406048342823ull},
		{17765659, 4428560580432537343ull},{17767787, 1837671283556578471ull},{17770043, 3092513594545328617ull},{17770777,  779919558137764991ull},{17771933, 1217980041393079889ull},
		{17771989, 3683503882483319137ull},{17772103,  934951397486511551ull},{17773807, 2835009341000295337ull},{17774051, 1916127240891187847ull},{17774917, 6513143384743979257ull},
		{17776513, 1948595367612706247ull},{17777099, 3140841499126593247ull},{17777297, 6654525407953706177ull},{17778391, 2960846207983915487ull},{17779787, 8799635039454374711ull},
		{17780947, 1338327839026813807ull},{17786393, 2479692584449808633ull},{17786479, 3705119304553621399ull},{17788829, 4337975187311263769ull},{17793301, 3363405780011350313ull},
		{17796997,  644515749614290871ull},{17799139, 4850550556337408063ull},{17809373, 8858673253181631769ull},{17811337, 5616750395550952409ull},{17811853, 3227714233149548983ull},
		{17812411, 4684506166881580409ull},{17812589, 8674042470759946327ull},{17814707, 1181105980369035367ull},{17816543, 7023683719607349833ull},{17817647, 5482282061362804081ull},
		{17818763, 8358943986123319271ull},{17820659, 1666842203779044511ull},{17821913, 1622936916022631081ull},{17822183, 3907752947435394377ull},{17826299, 1329300478629304361ull},
		{17828047, 2423187390334065937ull},{17829613, 3369241733425614041ull},{17831083, 1477733878367589473ull},{17833499, 1531563491873924849ull},{17834923, 2190674486659724089ull},
		{17835149, 3271992840407563639ull},{17835347, 3564903515554180057ull},{17838193, 1741480327901108647ull},{17838697, 6672437126818019801ull},{17839741, 5448515813271799129ull},
		{17842001, 4652601937964804191ull},{17845909, 8815568571441254321ull},{17845969, 3553263474276793049ull},{17846581, 2048983536460732087ull},{17847689, 7778712127779173767ull},
		{17848387, 3907383057407439271ull},{17848933, 2464245591905914177ull},{17849053, 2150183260070870471ull},{17849191, 2407856202749932553ull},{17851157, 5888131719304374961ull},
		{17851307, 8439995926524285881ull},{17851741, 3407041535153554681ull},{17852273, 6051572822283142393ull},{17857379,  685402904791012417ull},{17861069, 5197640349369569873ull},
		{17861183, 2817440372348117777ull},{17861309, 2323778877594576001ull},{17861561, 7613389509871645681ull},{17862001, 1274705791716433303ull},{17863873, 3718381908400885441ull},
		{17867039, 2848730709312090247ull},{17868757, 4049709796007485271ull},{17869031, 7240853613770980279ull},{17870807, 3143753649823393489ull},{17870953, 1524830233471897897ull},
		{17875537, 1664465123229227681ull},{17876251, 2403629034158699383ull},{17878099,  712042873447678601ull},{17881309,  903201483228046399ull},{17883809, 8490501007003379807ull},
		{17888639, 2105629043627382127ull},{17890667, 5735679228382833647ull},{17891113, 2876396552211694177ull},{17891147, 3093927243161087143ull},{17891807, 2664231706296909673ull},
		{17892221, 1978238729073140969ull},{17893643, 5419863053469262121ull},{17895089, 1533338567834601023ull},{17895103, 5160136017722307967ull},{17896811, 7897800523391520407ull},
		{17897839, 3374272067429879321ull},{17898479,  749593692866362247ull},{17908691, 1327377814615443967ull},{17909531, 1685626660799023367ull},{17909929, 2057175048146017463ull},
		{17915189, 1502198297363289137ull},{17916007, 2548941981249916039ull},{17918779, 6250235537067221041ull},{17920313,  982796297387492737ull},{17920367,  616895704215165097ull},
		{17920663, 6556922280592103159ull},{17921363, 3344080983855421297ull},{17923667, 1310662441188923177ull},{17926043, 1112470599742175431ull},{17929829, 7790880448537146551ull},
		{17930141, 5488202995825707401ull},{17930449, 6804159664440658391ull},{17931607, 5283700822626454303ull},{17931803, 3700358431737961943ull},{17931853, 8959646386932483937ull},
		{17933089, 3094872653106269879ull},{17933821, 5805307060406953537ull},{17934187, 2146159967654259929ull},{17936447, 7823722696080620041ull},{17937497, 3514677418927413071ull},
		{17938157, 1231292317361854199ull},{17940749, 5059333168351045729ull},{17943293, 5993577327478456249ull},{17943533, 1388115696739083727ull},{17948417, 4732957426757595103ull},
		{17948851, 2394620018782987729ull},{17951159, 2058879430641527057ull},{17951729, 7474004052629873911ull},{17952611, 2516644147971176591ull},{17952917, 1864851701193217279ull},
		{17953073, 1007670704243820809ull},{17954081, 1301079621918711617ull},{17954891,  964648425701599319ull},{17957509, 6840963133271524111ull},{17957683, 3978152863479088207ull},
		{17959793, 4669330482742391657ull},{17960119, 6752560053788375471ull},{17960783, 1678745601392391911ull},{17960977, 1228182543339675761ull},{17961421, 1020658709440637711ull},
		{17961443, 2797636755196101839ull},{17961721, 9063572628875007847ull},{17963123,  815678591888801513ull},{17963287, 1686003604554390599ull},{17964007,  778257809046093137ull},
		{17964613, 3754431528196358599ull},{17964931, 6361663250068077871ull},{17965289, 4428736923932099951ull},{17970331, 8117285082720974767ull},{17970349, 3864521381056789633ull},
		{17970529, 1426577669200287553ull},{17970709, 4518264433954012039ull},{17971237, 5471173681460147033ull},{17971697, 3699375676644287231ull},{17972971, 1359645139272461927ull},
		{17974861, 1691952521705558759ull},{17975981, 5648969327860083959ull},{17977579, 3748493120761985231ull},{17977957,  627232853285495647ull},{17978243, 1736248171119512263ull},
		{17979613, 2620854359698631863ull},{17982973, 5845737077781621887ull},{17984053, 2256835105241380121ull},{17984179, 1036884414685348673ull},{17984509, 8476679719127171777ull},
		{17985281, 1810544315152389041ull},{17986021, 2437445911911384503ull},{17986523, 4599843559465033063ull},{17986949, 1748229558785170831ull},{17987491, 2032912769179543457ull},
		{17987941,  630951207087221641ull},{17990671, 4331370829474908449ull},{17990983, 3525084813671441983ull},{17991541,  815037019285024057ull},{17992063, 2834821057516610377ull},
		{17994631, 3640971086950719167ull},{17994709, 6165252858770522527ull},{17994841, 3699354237817492591ull},{17997229, 2985492437257596839ull},{17997613, 3058804716917440529ull},
		{17998921, 1382684188503730727ull},{17999239, 1500972887730833927ull},{18004897, 4759900927558675889ull},{18005509, 9172509111918008737ull},{18005881, 7736227950495029071ull},
		{18006683, 3063561940694759783ull},{18011219, 2390466914947953551ull},{18011557, 7366817463725456441ull},{18011771, 2226790528673362367ull},{18011809, 1503751987321572641ull},
		{18012307,  220881355348927807ull},{18013507,  940523625874376009ull},{18013889, 1510301576718077839ull},{18014389, 7538190749320752511ull},{18014839,  277820521370888999ull},
		{18015551, 2340902482533374311ull},{18015953,  190079508451330231ull},{18016001, 4348492870379062169ull},{18016049, 3626126767636896889ull},{18016189, 1208034199034769401ull},
		{18016223, 8227372396468321529ull},{18016267, 2470104015463296281ull},{18016837, 1161245128754030233ull},{18017513, 3253408194517706441ull},{18018349, 1101875138253273577ull},
		{18018467,  195863445150291847ull},{18019637,  253771669953795991ull},{18020077, 3094501034482670753ull},{18021217,  178202077941327599ull},{18021617, 1095316961454549121ull},
		{18022343, 1902723646205275703ull},{18022379, 6182940253225886719ull},{18022517,  669237263128794313ull},{18023483, 2819237485165040417ull},{18023543,  664891496674705343ull},
		{18024137, 3423810082502902159ull},{18024623, 1358245988590673033ull},{18024833, 2413382318575227841ull},{18025171, 4953558993717617273ull},{18025493, 4046226592751303561ull},
		{18026167, 7301081045496468719ull},{18026759,  347459848092058087ull},{18027403, 1390530689850382279ull},{18027613,  553667433157303321ull},{18027643,  804282151680440903ull},
		{18028457, 3410205068438600407ull},{18029237,  384382401233265737ull},{18030157, 1814163598947018881ull},{18030811,  218703143967921281ull},{18031129,  336284434526159191ull},
		{18031199, 1773675444104420711ull},{18031807,  449829212253045649ull},{18032213,  809991539314593359ull},{18032737, 5563212097056992351ull},{18033047, 4242124268372681071ull},
		{18033313,  892754292286804439ull},{18033559,  578363464774452089ull},{18033749,  649107982030132321ull},{18034129, 8411740586508222721ull},{18034153,  228575622232707121ull},
		{18034193, 1568046814620032273ull},{18034487, 6563374615048802527ull},{18034867,  585223207509348217ull},{18035107, 2402182266587944111ull},{18035789, 6855462942253804601ull},
		{18035819,  430643152681188121ull},{18036311, 1309864431794423207ull},{18036407,  634094963019467681ull},{18036539, 2764330705944299369ull},{18036751,  969575221888062233ull},
		{18037189, 4391462561032616009ull},{18037231, 6998278073234944297ull},{18038123,  234324071638369567ull},{18038299, 1034209390921824937ull},{18038689,  285195009201221039ull},
		{18038843, 8465335113608243977ull},{18039719,  939317313181647817ull},{18039821, 8483872917922747399ull},{18040051,  550135978585350383ull},{18040597,  369386639326138207ull},
		{18040691, 7437117407042207281ull},{18040751, 3007057566367235767ull},{18040969, 1440061135634909441ull},{18041173, 1801135275958123841ull},{18041251,  212667050862844247ull},
		{18041371, 1607487587321961431ull},{18041449,  331381074274740977ull},{18041531, 8155698232304113193ull},{18042161,  719516832900729697ull},{18042293, 4045697812716293801ull},
		{18042361, 1195388362488578681ull},{18042547, 2264048456405883071ull},{18042809, 1041025085117227487ull},{18042887,  820583244199534793ull},{18043657, 6698885379723509521ull},
		{18044771,  217751151498027799ull},{18045019,  886346438516147753ull},{18045553,  684060296358930769ull},{18045983, 1727756785397843353ull},{18046849,  344383295054587687ull},
		{18046937, 1582723876470302791ull},{18046957, 6265230556365760207ull},{18047851, 2794465755922650769ull},{18048769, 1272884020935274439ull},{18048869, 2687244032076582031ull},
		{18048967, 2882596357369915999ull},{18049021,  151593119343580553ull},{18049079,  146863140298552751ull},{18049279,  302279348097426983ull},{18049607, 1027073160738358417ull},
		{18049729,  170705412915485111ull},{18049783, 2193137766783224489ull},{18050027,  249763397783639767ull},{18050477, 9034549389428481287ull},{18051151, 8270716773764582561ull},
		{18052591,  213534006096423721ull},{18053131,  145637662655615297ull},{18053641, 3574744060404862439ull},{18053681, 3523102587334514273ull},{18053713, 1274525953140893983ull},
		{18053771,  179298408456414497ull},{18054019, 5649369575053961591ull},{18054229,  466796606374323649ull},{18054577, 2331242743843392751ull},{18055153,  964029306347175647ull},
		{18055781, 1131377662856950169ull},{18056021, 3306352774543498007ull},{18056341, 2199830028736195519ull},{18056959,  575696006576981399ull},{18057101, 1032151692346949719ull},
		{18057253,  700043530529500567ull},{18057257,  317329196933100529ull},{18057751, 3201031337245812953ull},{18057761, 1268134802832477257ull},{18058127,  975859961953336007ull},
		{18059207, 3648110332144819729ull},{18059857,  428772495755334047ull},{18060187,  239976875255863241ull},{18060257,  306692189293676009ull},{18061111,  161771569920155527ull},
		{18061223,  993238009496376041ull},{18061597,  531092340787785431ull},{18061721,  397467971850349511ull},{18061889,  170575814893989689ull},{18062197,  459009642330749087ull},
		{18062221, 4762721205492398143ull},{18063697,  155760394292528407ull},{18064261,  869279864055005729ull},{18064609,  902086647190626031ull},{18064663, 4326753552702418993ull},
		{18065473, 1016638870230715063ull},{18065573, 4980322140187853369ull},{18066827, 3041030515267231999ull},{18067013, 2965222136820402343ull},{18068201,  732115975825870919ull},
		{18068377, 2654786510720728759ull},{18068873,  382620704518269719ull},{18069367,  935330914958678617ull},{18069533,  439156261511080703ull},{18069851,  895513289517439447ull},
		{18070309,  169411595004322703ull},{18070981,  468402609294531217ull},{18071509,  619224414211506937ull},{18071783,  269279113553092543ull},{18071891, 2051286244830893879ull},
		{18072773, 5242009072298288161ull},{18072793, 8819126928139257361ull},{18073207,  303650943296322233ull},{18073613, 2204719604073948097ull},{18073843, 2123288934790210753ull},
		{18074057,  170868633716270417ull},{18074129,  231723590213766793ull},{18074531, 5617874574099630319ull},{18074869, 1313575677565859287ull},{18075227, 5966010148617767489ull},
		{18075413, 1072730263421826137ull},{18075469,  157453782618412799ull},{18075829, 3540387457043046913ull},{18075929, 1427015700350286601ull},{18076417,  350296688447252401ull},
		{18076753, 9106402842275874799ull},{18076987, 6513441085781826191ull},{18077041,  954866887065157361ull},{18077077,  156911835368516561ull},{18077509, 2858210469415838191ull},
		{18077539, 7409642155457441729ull},{18077849, 1727714706371758799ull},{18078019,  208075572945254543ull},{18078097,  809063907179527457ull},{18078773,  209054887364316841ull},
		{18079447, 2991325265195645407ull},{18079757,  469481662092691673ull},{18080059,  156437228555447297ull},{18080497,  265091087382571111ull},{18080773,  863973615071231263ull},
		{18081527,  629299790246739247ull},{18081593, 1569037754951646233ull},{18082327,  294136552344507503ull},{18082601, 7772927443359071831ull},{18083011,  764051439321188063ull},
		{18083851, 1093556287922395681ull},{18083941, 5005994961296695481ull},{18084103, 5396859190608684961ull},{18084511,  280218395260026287ull},{18085163, 3958373172235987537ull},
		{18085259, 2421951227499722447ull},{18085597, 1652097288619224871ull},{18085877, 5970055030215365329ull},{18086069, 5194261471992541321ull},{18086473,  175396807623692647ull},
		{18086837,  428007377950999711ull},{18086897, 2086916000630989369ull},{18086941,  507585516102880289ull},{18087053, 6736325484534062567ull},{18087241,  229349757904405031ull},
		{18088823,  348983282328464657ull},{18088997, 3817682373416327543ull},{18089221, 7717318284654310807ull},{18090749, 4400781849969539081ull},{18090829,  254929304698201369ull},
		{18091243, 2178950725735373921ull},{18091793, 5360440248670130159ull},{18091939, 2955370698546160567ull},{18092299,  189845745823406633ull},{18092729,  786834525027893201ull},
		{18093421, 2528677625598381841ull},{18094199, 7475161236393989161ull},{18094523,  500414590814444351ull},{18094829, 1692354721386162271ull},{18095381, 1488542967045098257ull},
		{18095489, 3474495571049451089ull},{18096017, 2381707920189331807ull},{18096829, 4298659432822913113ull},{18097117,  252582943145637983ull},{18097691, 1452486143800069319ull},
		{18097777, 3811727973559918463ull},{18098173, 4646682542258342239ull},{18098467, 2766600574338603679ull},{18098719,  498347184635824031ull},{18099317,  197887977417451367ull},
		{18099593,  692527271711510801ull},{18100351,  986858833532297393ull},{18100487, 5559545560067206831ull},{18101351, 5892698227386194249ull},{18101723,  330663381619973953ull},
		{18102113, 4108304515751346191ull},{18102169,  658093059110448113ull},{18102551,  278135947855081399ull},{18102827, 3614226096429255457ull},{18103049, 5669365061064864839ull},
		{18103699, 3418868997915619559ull},{18103961,  300843536605165847ull},{18104221,  382634038236483721ull},{18104369,  833152711474330081ull},{18105079, 2294178426436943801ull},
		{18105331,  200171358090730927ull},{18105929,  233146044693157391ull},{18106423, 9010404214242243343ull},{18106733,  240725289847112183ull},{18108067,  173634447567858457ull},
		{18108109, 2039429751651682297ull},{18108749, 8907523168165945903ull},{18109099, 1421698886573962441ull},{18109373, 1148928461554787041ull},{18109783,  219645083823801679ull},
		{18110101, 6356333444674501297ull},{18110329,  636409319403626969ull},{18110633, 5137754947683470257ull},{18110737, 6949931723478004673ull},{18112219, 1038596187216405943ull},
		{18113047, 2636979483956432687ull},{18113423, 5711003588895540041ull},{18113437, 7237656685324752551ull},{18113647, 3664424537447090401ull},{18113819,  644487044676701329ull},
		{18114329,  180937307436358751ull},{18114851,  191730898327800319ull},{18115219, 6967968772129631927ull},{18116167, 3284006162755109681ull},{18116473,  295911982481558263ull},
		{18116653,  905674446545077337ull},{18116933,  182298573362242793ull},{18117343,  179042324916860929ull},{18117611,  276403239447018521ull},{18117727,  265355157611625017ull},
		{18118589, 2100547192247488343ull},{18118813,  297889740791115089ull},{18118901, 2006169583836711151ull},{18118907, 1394872940423976479ull},{18119047, 3274845436157029897ull},
		{18119107,  149695768675358137ull},{18120203,  931416251824709527ull},{18120373,  326540082364905463ull},{18120517, 2475413327350678009ull},{18120733,  190253658549352231ull},
		{18121843, 6359751903252262831ull},{18122623, 4096620322163539519ull},{18123043, 4163005457310656519ull},{18123817, 7035605257132928143ull},{18123877,  841608666156857441ull},
		{18124969,  250169084767618031ull},{18125017,  185850489228528127ull},{18125089, 2115940694316175591ull},{18125573,  156569053638942983ull},{18126587,  160497608613885097ull},
		{18127093, 2729552475111634177ull},{18127631,  202972162459180159ull},{18129077,  826185140698051193ull},{18129103, 7756965693917461751ull},{18129487, 5710844170141724833ull},
		{18129953, 1026702811985035831ull},{18130379,  844753854261726401ull},{18132473,  508082638582175071ull},{18132703,  984788573937426871ull},{18133009, 4179248003537482327ull},
		{18134377,  353995670830449383ull},{18134561, 1644404173956643577ull},{18135521,  193091585683392047ull},{18135841, 1592191104201793057ull},{18136043,  164769434262411527ull},
		{18136087,  588583452577383391ull},{18136757,  942155756229059431ull},{18136897,  498022844181805609ull},{18137389, 2124101979953718983ull},{18137543, 1712231773162793983ull},
		{18137857,  306824264431376327ull},{18138451, 7582282194251423767ull},{18138649,  172912609859686919ull},{18138871, 3502704858995300303ull},{18138943,  246436192567308041ull},
		{18139543, 7285407584197933721ull},{18139549, 8194085954986376671ull},{18139601,  151382510178993257ull},{18139711, 2628003804944996063ull},{18139787,  426501575901789887ull},
		{18139909, 1046433785458137217ull},{18140159, 3453473050646226497ull},{18140273, 5713537045599308921ull},{18140971,  483292855669549327ull},{18141997, 3815540980096758137ull},
		{18142309, 8994056844398885153ull},{18144433, 7624512815589709681ull},{18144851,  910777532920154969ull},{18145009,  188541992445693137ull},{18146059,  510420446392176527ull},
		{18146173, 1077844070144357809ull},{18146389, 1542355791176058953ull},{18147403, 2286897497466736321ull},{18147457, 1717929434260216087ull},{18147923, 1863286297415992049ull},
		{18148337, 4530369323750308271ull},{18148799, 3297933472724493719ull},{18149039,  880845054646901471ull},{18149707, 1185286443100915081ull},{18149843,  916379742324037193ull},
		{18150389, 3822485160260893033ull},{18151093,  276821161702590647ull},{18151249, 3813458507193178439ull},{18151433,  504627225601545217ull},{18152203, 2250101091316519247ull},
		{18152227,  177869433900604409ull},{18152297,  624789460689330721ull},{18152833,  495113827785503497ull},{18152839,  885462025654928081ull},{18152861,  745935741309920879ull},
		{18153169, 3605232236719796351ull},{18153271, 3877198473695927321ull},{18154307,  849875488878394039ull},{18154781,  571926881349174353ull},{18154943,  155169642064458841ull},
		{18155341, 2105616473697176423ull},{18155399, 6043531412317122401ull},{18155939, 3895014398342628833ull},{18156067, 2786585146312304017ull},{18156139, 5200014469418315143ull},
		{18156353, 3580508484628476463ull},{18156517,  589464156813894023ull},{18156659,  606575457511111639ull},{18156767,  203157325643180927ull},{18157187,  397214103754615871ull},
		{18157303,  576095881253912743ull},{18157859, 6212058775368239569ull},{18157943,  159009663500900609ull},{18158879, 3046826399782247647ull},{18160739, 1834647890429700191ull},
		{18160949,  593999785117695553ull},{18161167,  515672149352372599ull},{18162563,  325095769929189751ull},{18162769,  803974127577401471ull},{18162913, 1357411268881729807ull},
		{18163111,  184841740940977937ull},{18163459, 2856141027727809919ull},{18163823, 2023000940646103897ull},{18164953, 6200977504829196521ull},{18164999,  209733008010133879ull},
		{18165449,  581632703556685577ull},{18165757, 8551912773780986681ull},{18166429, 5446844587056314327ull},{18166543, 2266665690147190831ull},{18166787,  284384707970416967ull},
		{18167431,  472166489464865399ull},{18167533,  454009591465948559ull},{18167563,  708026462172382921ull},{18168611,  249407869166136743ull},{18169201,  166259287297693223ull},
		{18169861,  443632828183509721ull},{18170197,  551075689667191967ull},{18170377,  495087521203707449ull},{18171443,  158909252898758617ull},{18171731, 1761088143471303481ull},
		{18171877,  193406421160001207ull},{18171949,  959021713174709729ull},{18171971,  212582186997306377ull},{18172283,  306340199670707177ull},{18173159, 2710192223805113503ull},
		{18173341, 2655893467840057759ull},{18173773, 5208297326830612199ull},{18173801, 2566037605552291639ull},{18173803, 7609123229331745631ull},{18174001,  280538571090706153ull},
		{18174461,  373169859737261921ull},{18174613, 3696057688567765441ull},{18175307, 4606467234303035863ull},{18175433, 1671941933015884697ull},{18175603,  358104212205598393ull},
		{18176129,  297748851152334433ull},{18176479, 1727768194505086439ull},{18176971,  580938966948809543ull},{18177721,  288661255622268247ull},{18178481, 1412900492698726673ull},
		{18178747, 1051870922187653719ull},{18179011, 4129359287631769799ull},{18179107, 6950769019465931417ull},{18179251,  209784776455622567ull},{18179339, 1071223273576351913ull},
		{18179743, 5450404147513203847ull},{18179747,  278846268444797423ull},{18179881,  579166105626521671ull},{18179963,  422004445218799519ull},{18180161, 6611758316647537577ull},
		{18180523, 3866032370946584039ull},{18180619, 3511515211683351449ull},{18180677, 2788648282376867167ull},{18180931, 6090731622611663591ull},{18181103,  639713485080233719ull},
		{18181591,  493845656085060953ull},{18181643, 6505947238121659543ull},{18182093,  148609684310517929ull},{18182149, 1421216450235542759ull},{18182257, 1446565977045436033ull},
		{18182933, 6599802010049618921ull},{18183043, 4557063360658169617ull},{18183713, 3243799555344182671ull},{18183853,  395470449031694161ull},{18184009, 5686173517548316087ull},
		{18184043,  373695005994685607ull},{18184417,  231657393871958423ull},{18185021,  500385408994477393ull},{18186167, 2137325682797422129ull},{18186403, 3705306186874921793ull},
		{18186653, 4636504888324534583ull},{18186919, 4487805898789947119ull},{18187153, 6983373698391292919ull},{18187291,  370733891538789481ull},{18187451,  556367250482015719ull},
		{18188207, 4575824555835552737ull},{18188347, 2947808031323356391ull},{18188897,  279655125154038481ull},{18189211,  682770116581096463ull},{18189239,  721353005779623391ull},
		{18189683,  284497605842290153ull},{18190547, 2366428611869035327ull},{18190633,  611552330470076887ull},{18190883, 3401415680513815457ull},{18191449,  335577525522872177ull},
		{18191869,  430855402541381393ull},{18192523, 3295002558186922673ull},{18193271,  719309171397378511ull},{18194773, 2206473614203878367ull},{18195173, 2198996002033853881ull},
		{18195563,  870871242175451887ull},{18195643, 6182575437692950537ull},{18196777,  244421485308650417ull},{18196807,  214838963113848809ull},{18198001, 3797160104673324583ull},
		{18198307, 3261313241635456673ull},{18198407,  908961388000467377ull},{18198611,  147117672508277161ull},{18198757, 1291057922497655201ull},{18198839, 7702578482357557921ull},
		{18199123,  627938298322402391ull},{18199243, 5715394251020166799ull},{18199319, 1751859472378580993ull},{18200447, 2241185363083369897ull},{18200453,  964234051444955183ull},
		{18200729,  226278029714621743ull},{18201653,  453572672024917831ull},{18201751,  177416839093993703ull},{18201977, 7556583206839917529ull},{18204647,  384711185932909679ull},
		{18202727,  324976325860139897ull},{18202763, 3619808293690777481ull},{18203599,  255716891729650409ull},{18204551, 1240325425602719639ull},{18206063, 6154427524543057841ull},
		{18204833, 5064367179117501257ull},{18205427,  171635048851402607ull},{18205567,  498049680871445783ull},{18205849,  420551620709984063ull},{18208871, 4825503957031353559ull},
		{18206707,  194980615976282599ull},{18206767,  598824763799582977ull},{18207751, 5450962935976347551ull},{18208459,  732071086083278041ull},{18210487, 7904260220388114433ull},
		{18209309,  421921108806185609ull},{18209663, 8914936054468409521ull},{18209677,  502857357742033897ull},{18210287, 3828673568316018007ull},{18212209, 8790088711977627727ull},
		{18210749, 2639089913010052231ull},{18210839, 1252897572756897161ull},{18210989, 5449720962043005161ull},{18211819, 1475550183670841617ull},{18215221,  326578760775994607ull},
		{18213947, 1836680918690277743ull},{18213967, 5459789331634736321ull},{18214393,  195882229760802737ull},{18214969,  908643053573127737ull},{18217841,  796311598662086929ull},
		{18216113, 2407520616714053377ull},{18216281, 1012316473329291833ull},{18217097, 7081648448968956167ull},{18217231, 7391482353834144271ull},{18219679, 7151731110031749079ull},
		{18218107, 1024998043469714399ull},{18218329, 4062483484914991183ull},{18218821, 1574151660610168777ull},{18219193,  465003359815917473ull},{18222047,  183179527238201713ull},
		{18220121, 1250742979702200079ull},{18220193, 6884674196094390961ull},{18220427, 7661835938013915577ull},{18221563,  355351420754789057ull},{18223081,  271683140874255079ull},
		{18222431, 1345721149104357527ull},{18222473, 3615247421609496839ull},{18222541, 4684088799094989457ull},{18222679, 8986103483467189951ull},{18226207, 2704015245587660479ull},
		{18223157, 5504989872766853537ull},{18224113,  337598450890815041ull},{18225239, 1774628704161652543ull},{18225947,  170795563856396191ull},{18227941,  378986137162265657ull},
		{18226259, 2649773119432899799ull},{18226573,  911655289398967943ull},{18226661,  445670037826519969ull},{18227501, 7493941152443672183ull},{18230129,  797093455655673119ull},
		{18228671, 9040364929018544423ull},{18229217, 6172674414859643609ull},{18229609,  226169112606204431ull},{18229957, 6222489105657968551ull},{18232183,  944222602441112623ull},
		{18230347,  189233265048197969ull},{18230479,  604328392674667081ull},{18231443,  147016546516653391ull},{18232063, 8986734322535829143ull},{18233221,  445148471262696793ull},
		{18232589, 4142114913805405951ull},{18232657,  178737507169092407ull},{18232861, 7113129966272258737ull},{18232873,  910196727414821809ull},{18235691,  164802005523725623ull},
		{18233599,  219626590199244689ull},{18233653, 3827298988308429593ull},{18234467, 5822485231311541927ull},{18235501,  392569969513211351ull},{18236741,  196115251171071497ull},
		{18235759,  634470290505529649ull},{18235829,  209128182032467463ull},{18236173, 1072782161927740559ull},{18236201,  790424566760147359ull},{18240023, 1145096636605819193ull},
		{18236807,  466544298281538161ull},{18237683,  150980093785031393ull},{18238039, 8257131768449278303ull},{18238439,  344896464741121177ull},{18241291, 6931896967949517449ull},
		{18240689,  575543924177829127ull},{18240707, 2551774584244094753ull},{18240791,  502038045619799519ull},{18240793, 1170545082309195503ull},{18244049, 6069262720224940337ull},
		{18242249, 5828183487410879561ull},{18242837,  329863222762232767ull},{18243541, 1145311999667281321ull},{18243691, 4730620580709702407ull},{18245393, 1756929621995499241ull},
		{18244397,  192953761876994009ull},{18244609,  693347914896424681ull},{18244871,  185263315342358527ull},{18244969,  313851947884446847ull},{18246359, 1724545012534814191ull},
		{18245431, 2427947115805275401ull},{18245483, 2236899860371720217ull},{18245489, 3135301377567517289ull},{18245911, 5185505342138518889ull},{18248129, 1889170052270492231ull},
		{18246493,  661645029293447761ull},{18246617,  282971109500942873ull},{18247231,  270517615508384401ull},{18247321,  159147066856219279ull},{18250627,  291592687904150233ull},
		{18248161, 7709695907107275271ull},{18248557, 3186743502444660737ull},{18248621, 4251433917700860097ull},{18249817,  493224469282714441ull},{18251957,  254280057031881247ull},
		{18250751,  254345153322583249ull},{18250927,  924384987729884311ull},{18251573, 8971192775529465359ull},{18251921,  818573016843409937ull},{18253201, 2107029553327261049ull},
		{18252413, 6276507976472527231ull},{18252439, 1382377176451739687ull},{18252473,  156153666341913271ull},{18252721,  955287304650810977ull},{18255473,  319847903150459953ull},
		{18254153,  967283619169722713ull},{18254179,  219243245853140479ull},{18254261,  426226079762262881ull},{18254713, 5193684555003623513ull},{18257809,  308089528042217839ull},
		{18256003, 5286812608446677431ull},{18256541, 2553532129640010329ull},{18257039,  448060853576070257ull},{18257563,  321458459567713471ull},{18261493,  531522059923681919ull},
		{18259859, 2803350460979415799ull},{18260069,  331082250694020607ull},{18261137,  154050640123958233ull},{18261491, 3702574820038690927ull},{18262639, 1209709784108600393ull},
		{18261953, 2806113676062110233ull},{18262523,  684985867125297457ull},{18262577, 2194723316765298271ull},{18262597,  320968254367629577ull},{18265301, 1346964077869385711ull},
		{18263249,  232092702284631449ull},{18263251,  333277109337857999ull},{18263629, 1713796095354485687ull},{18264707, 1832987592900191017ull},{18267541, 1496402839560725617ull},
		{18265801, 4423192174067168921ull},{18266051, 1547492141360310889ull},{18267031,  567432888774070073ull},{18267047, 5106988365977004847ull},{18268391,  305702301712820839ull},
		{18267679,  174693156677091359ull},{18267827,  622339054125734633ull},{18267869, 1029565792938412967ull},{18268213, 1567498750360311343ull},{18270283, 3267912895027409807ull},
		{18268609,  849946831856870551ull},{18268849, 3589933220064654217ull},{18269851,  187189076554887889ull},{18269941,  684132024494418671ull},{18272459,  185218879178598929ull},
		{18270697, 4883150130560297143ull},{18271153,  847597287242915641ull},{18271373, 2678811554504263327ull},{18271699, 1035077953363428593ull},{18273979,  163029569082413321ull},
		{18272867, 4292910235570102649ull},{18273131,  209741654531247401ull},{18273377, 2209176452708378567ull},{18273919, 2540283736047175687ull},{18275233,  615695688832633991ull},
		{18274357, 5250220205935681729ull},{18274603, 1651356375517532207ull},{18274769,  683353857184539559ull},{18274793,  358189838547272569ull},{18276473, 2368605654265044937ull},
		{18275489,  358780015246475209ull},{18275633,  714810154491785543ull},{18275671,  777591913390936481ull},{18276131,  407054061248703889ull},{18279707, 2260875022023462961ull},
		{18277121,  986369995008748303ull},{18277283,  228176384967746561ull},{18278233, 4556501041742873849ull},{18278863, 2454505365996506623ull},{18280693, 4432908001376646401ull},
		{18279997,  154021947782950943ull},{18280187, 4079581038301390247ull},{18280189,  878473513058879207ull},{18280319,  357247190862453119ull},{18282479,  211056575094586799ull},
		{18280897, 2014965098614430153ull},{18281111,  313018661846486831ull},{18281147, 1046495746119219161ull},{18282149, 1158393037316521873ull},{18284093, 8438246621794815367ull},
		{18282533, 2542230761454948857ull},{18282749,  252921162085242593ull},{18282833, 6228271224778947713ull},{18283879,  202167909800447377ull},{18287299,  699415163018787223ull},
		{18284107, 6555765084751538351ull},{18284437, 4596424749553843079ull},{18284887, 3864332598578495761ull},{18287099, 7075693236187789471ull},{18290131, 3505439438466316217ull},
		{18287447,  791184749579030377ull},{18287623, 7137233656547846431ull},{18288509, 1903735137621720479ull},{18289937,  219531327119618807ull},{18291743, 2873872397818760873ull},
		{18290411,  684228304469438089ull},{18290659,  563712281110395383ull},{18290927, 3424153274995352719ull},{18291583, 3062407520782516471ull},{18294047, 4139587137772912577ull},
		{18291773, 2657423207973350447ull},{18292039,  251983731817092089ull},{18293101, 6998952403324571639ull},{18293657,  751539795410988359ull},{18295987, 6428839976520012353ull},
		{18294259,  602428265212755713ull},{18294721, 7589034719689448759ull},{18295003,  530722364249779991ull},{18295183,  155518178941858441ull},{18296737, 1282191130922981113ull},
		{18297571, 3288951767406279151ull},{18299003, 4522165993393804423ull},{18299447, 1506874563020357233ull},{0,0ull}
	};

	/* Testcases with factors < 2^64 = 18446744073709551616: */
	static const struct testFac fac64[] =
	{
		{17922587,10500365774503436201ull},{17924587,15641779111884102847ull},{17927311,12915704346519849697ull},{17938027, 9287694977263609817ull},{17941211,10016045939325808271ull},
		{17942927,12928465186953089863ull},{17963653,10943084366908922353ull},{17964227,12431505097071887473ull},{17967659,15718414880628053417ull},{17971007,17130259977555383783ull},
		{17973443,17017539148249318519ull},{17981947,17331582637129315543ull},{17984683,17075071760459211223ull},{17988793,10651829289881962249ull},{17990153,13875348797185757897ull},
		{17990213, 9612328233936311881ull},{17996261,10983089768339907263ull},{18016303,11011193468080521223ull},{18019909,12625693644608762351ull},{18024151,10754411617748801759ull},
		{18024311,12013002667638145399ull},{18025781,12825068851465148441ull},{18032587,17170312062251360359ull},{18033511,12031568180050170481ull},{18037577,10566050601376248193ull},
		{18040663,14859011986541991007ull},{18047423,14989510186280279071ull},{18048313,16214445839716767361ull},{18051923,10598954534434896529ull},{18055627,14057592431325128593ull},
		{18056047,16560715604598816241ull},{18059039,12811182984027587681ull},{18064777,15539690406724276993ull},{18066073, 9985641878418216991ull},{18067711,11449566963261644983ull},
		{18075257,13764994941016683383ull},{18075791,16672552177382226647ull},{18077821,11623423906484739527ull},{18079043,17169614195768327983ull},{18079123,17990551511959203257ull},
		{18080273,12155150476665080887ull},{18090001, 9789648295780602191ull},{18091883,10985008068068673007ull},{18095521,12658180920879996367ull},{18107017,15044832325095723511ull},
		{18107351,14046232068642146993ull},{18119851,11179467653397253391ull},{18120799,11418381227787294353ull},{18121517, 9600311723751200999ull},{18121799,10641782461606146511ull},
		{18122101, 9238369956591864047ull},{18125911,14284214035586927489ull},{18130529,16132196293595357033ull},{18131303,12132533847075902297ull},{18133517,13711702151742952271ull},
		{18136529,13553802287542899791ull},{18138227, 9814223728786685249ull},{18138437,11664104294072220647ull},{18142753,11841941210452963607ull},{18143239,13495717684024316977ull},
		{18144733,11453374630895585671ull},{18146147,12409236261334108927ull},{18146309,13941936454603083961ull},{18151307,16695225546321153647ull},{18157823,15274150651947770057ull},
		{18159851,10670964685324409993ull},{18162883,13984615577478771737ull},{18166397,16478002069230680743ull},{18170359,11555285165538057473ull},{18173191,13017176322370888999ull},
		{18174743,10899353333633834737ull},{18174829,13082852309834271431ull},{18175387, 9469759966159211119ull},{18177011,16562044284339342287ull},{18181343,12857396115642922399ull},
		{18184013, 9771683082091843559ull},{18190691,13254207919455131647ull},{18190903,15437851890296633887ull},{18196709,16287562569554793953ull},{18196993, 9275136914779640273ull},
		{18198841,11025186727945055441ull},{18199583, 9854261882174597857ull},{18200849,15285818081668067519ull},{18202049,11180960576914148191ull},{18211309,14428852738137829687ull},
		{18211993,11752043400810302297ull},{18215051,15463714506600122897ull},{18220127,12907674385704768017ull},{18220999,11394039312173819999ull},{18224827,10366044942826856209ull},
		{18228937,17973037128357378841ull},{18231331,18328139888296813361ull},{18232931,10003907358728522969ull},{18235879,15548404807307836393ull},{18242963,16134040372770842257ull},
		{18245207,17112902589623655359ull},{18253589,13909553524167145703ull},{18255499,11109231768403310369ull},{18257399,10738982321410344871ull},{18258283,15374699987470193449ull},
		{18263647,13762137093959242159ull},{18266777,14732963741405224223ull},{18268189, 9989690110846448329ull},{18269219,16284666399547421921ull},{18275251,13620718892071208681ull},
		{18275263,11262843094267061911ull},{18275651,13846368038170428023ull},{18277607,10504362932070630521ull},{18280159,12772485980427473983ull},{18281927,12631296696930554257ull},
		{18286687,17931410955470787601ull},{18292013,12702828058463407919ull},{18296671,14627091909328461551ull},{33402073,13932143274652230937ull},{17719931,12646230872610358319ull},
		{17719993,17458131644489262929ull},{17734169,11268951794162923127ull},{17742793,16341053115349924417ull},{17771027,12007015401209325023ull},{17773141,15918852021480399527ull},
		{17774641, 9341752468258236431ull},{17775269,10013306797089936121ull},{17811401,16160582285842380959ull},{17812637,15811238096354839487ull},{17815169,12298642243571509687ull},
		{17820757,12597566906366358017ull},{17829943,18335410068788651849ull},{17831813,15899391255100053209ull},{17851397,16860276014915517791ull},{17853761,16072139673628398673ull},
		{17870731,12143859436446628321ull},{17889841,16375574063043584023ull},{17902987,16086636940765296889ull},{17905253,17558635633759926961ull},{17911027,14646809963723851673ull},
		{17913557,17895543665490669193ull},{17915981,16726174377018723457ull},{16100419,14461463666320960511ull},{16104013,13440101789246121791ull},{16105279,10991970915886596511ull},
		{16118143,11337011726859890543ull},{16120229,16582660415820077063ull},{16121711,15998585226804618071ull},{16131469,14271788618292432257ull},{16132931,10760230434599829143ull},
		{16132969,10730782077481732817ull},{16135981,14331950710727986663ull},{16136507,10961703930971884903ull},{16137271,15296117896318004719ull},{16138747,17040351390832159609ull},
		{16140287,14702865045484912391ull},{16140419,11533383163345547927ull},{16141121,12125342584232876329ull},{16141553,15810596930722833329ull},{16142201,16759807228908186473ull},
		{16142437,14680112878087367873ull},{16143041,10214864560585659127ull},{16152289,18111383456669963153ull},{16152901,11554056516029888111ull},{16153601,14102697559575163223ull},
		{16157303,10951036977490542007ull},{16161121,12068660979042357751ull},{16161923,13936597432397301953ull},{16167427,17741531859834789367ull},{16169077,13038897762986995439ull},
		{16172587,12923341570853700409ull},{16173133,12468959361471384367ull},{16173691,12146036035731849143ull},{16181381,17389980150980900167ull},{16181761,13632984658968284321ull},
		{16184771,12579003037333710127ull},{16185919,18017349281491722863ull},{16186981,16300711072026110783ull},{16187707,12837482707778126729ull},{16191941,14435333013673979377ull},
		{16194601,10362937015011578407ull},{16199899,14943059862662596097ull},{16201201,13083808953378894799ull},{16203571,10961371406875908433ull},{16203631,15948970413144688847ull},
		{16203851,11851486348839027743ull},{16213993,13617531092155742599ull},{16100213,16092742349020987151ull},{16100297,10748446445825061761ull},{16098127,13581925937697282097ull},
		{16098883,17001973141862761433ull},{16098931,18338048883043493801ull},{16099169,11445451093632964279ull},{16072711,11466372601071120199ull},{16076597,13435999004029409279ull},
		{16080049,18266526887928755321ull},{16081679,11868117613510431529ull},{16085071,14158058431764629761ull},{16086911,16826194113484414487ull},{16087829,14626742151491329369ull},
		{16091021,14224052887860439639ull},{16064149,13197622355391030409ull},{16065149,13545314040804294319ull},{16067243,14152269016994013583ull},{16068049,16067045133341942353ull},
		{16070969,15370375936060062839ull},{16071529,15059986833339178897ull},{16057751,17402936053714225153ull},{16056451,15488725481110429159ull},{16054043,12672311049187782367ull},
		{16052353,11593765511293358047ull},{16052657,11085431129434680449ull},{16050487,10218100740052053263ull},{16048763,14100978243368072207ull},{16045357,12183869854186459801ull},
		{16035809,11855169834318581681ull},{16035941,17649706665176130473ull},{16027681,16209706991529970753ull},{16026343,10440895312670202409ull},{16026499,14608723870843452887ull},
		{16022003,16542024904771148857ull},{15838057,13724050657344286793ull},{15798119,18033822787942121599ull},{15372727,13620902108656457471ull},{15370987,13141770251775333463ull},
		{16423567, 9593004739201446737ull},{16424743,11207409667480506167ull},{16426331, 9315521980684624207ull},{16427317,12920971770507553729ull},{16427401,16822696323471127217ull},
		{16431991,13793486024804669009ull},{16434511,13533131423401796863ull},{16438259, 9952502816461400807ull},{16438421,13236391347894754153ull},{16441151,18194162210171783167ull},
		{16446379, 9889326862010987471ull},{16421063,15295542430741533281ull},{16411141,14567378334050418241ull},{16408439,10288195248504974393ull},{16386497,10040647230145986479ull},
		{16379327,12344397890070085393ull},{16383739, 9942526727677974137ull},{16384727,12597569013851067049ull},{16369789,10288230960652346249ull},{16364419,10607814077757516457ull},
		{16359293,11028045969272017577ull},{16344319, 9803688218926567111ull},{16339627,10586347451730006521ull},{16323487,12699616391325608273ull},{16307677,10780482862846368239ull},
		{16286441,11747242053545138911ull},{16280959,10537253101166306807ull},{16269433,10520779020741875777ull},{16264579,10000450921799397911ull},{16263427,12056468544232052593ull},
		{16229383,10028147391258765553ull},{16218541,11886145592975848529ull},{16237721,11289182387241165217ull},{18202697, 9523705169798429639ull},{0,0ull},{0,0ull},{0,0ull},{0,0ull}
	};

	/* 65-bit factors. Only store the bottom 64 bits of each factor - 65th bit assumed == 1. */
	static const struct testFac fac65[] =
	{
		{16446217, 2580748063118626543ull},{16441037, 7159845698788165911ull},{16423243,16053932793878088265ull},{16422199,15449225178445266103ull},{12307619,  834960775198036465ull},
		{12891233,  320347219092137433ull},{13091369, 4490626336223492551ull},{13251437, 5252892907907759335ull},{13278611, 4992876320436398817ull},{14191367, 3043526892782259057ull},
		{15372433,  835012824499792921ull},{15378317, 1469384281496492841ull},{15381727, 3296686288473649015ull},{15716923, 1071681628997604121ull},{15792929, 4568661977477836713ull},
		{15829339, 1353718096095573831ull},{15857663, 1877275782840805977ull},{15896423, 2846280113165409217ull},{15389291,18328954321183659201ull},{15424001,14055059218732619601ull},
		{15649649,16271423290019634663ull},{15716923, 1071681628997604121ull},{15792079,14719270918611609657ull},{15792929, 4568661977477836713ull},{15829339, 1353718096095573831ull},
		{15857663, 1877275782840805977ull},{15888107, 9672885011805764433ull},{15896423, 2846280113165409217ull},{15896591,12753248453534549335ull},{15913669,10042894560178858561ull},
		{15919751, 9077968001905706863ull},{15935603,11440996883202164671ull},{15937421, 3477787277761589433ull},{15940453, 3293099948043389463ull},{15990151, 9384163689137796817ull},
		{16020359,15674564692213482777ull},{16020997,10583884050943532673ull},{16021231, 2457557263587737193ull},{16023079, 7172265904034801095ull},{16023647,12254780112882764065ull},
		{16026047, 2015612163892272583ull},{16030051,12636535017081930135ull},{16030981, 4533504886207341415ull},{16032113, 4098116656401037545ull},{16033373, 4283833442114036481ull},
		{16037731, 4669494584567097327ull},{16042031, 8521202797833889425ull},{16042363, 1118497044506213463ull},{16043689, 5061951072668619745ull},{16045877, 7034068819169950713ull},
		{16046413, 7970266257131337337ull},{16047763,17720298914808722185ull},{16049867, 2777504824160429671ull},{16051073,17305172545354635225ull},{16052317, 6141121158983034457ull},
		{16056541,10695684989098787847ull},{16061009, 1456724931068173687ull},{16063109,13596747992403972297ull},{16063357, 8295891058026308023ull},{16070227, 2132028069846281607ull},
		{16074001,  613796669972356527ull},{16078813, 6533829271585121673ull},{16085423,10209359921277170607ull},{16090609, 2161620649992862905ull},{16096469, 1554699406605092793ull},
		{16100053, 8795628605553802671ull},{16100347,13291493148042713257ull},{16103719, 1585997210388541833ull},{16109507,12512063892223428961ull},{16109749,  968325311857141351ull},
		{16113029,18313175825134571025ull},{16123907, 7411731869541221617ull},{16126067, 4236545548179355081ull},{16126601,13228754303985015511ull},{16135051, 5990895667432870231ull},
		{16135411,15090056596912858585ull},{16137103,10560319150004001961ull},{16141709,17519457444182672455ull},{16147013,11445706533097774785ull},{16147393, 2659601528506615945ull},
		{16148129,17675056835266093305ull},{16149409,  204949170576663745ull},{16149787,16731036664601428255ull},{16149803, 7545607839488943193ull},{16150331, 6874010104330448145ull},
		{16155731, 9207449049005699935ull},{16162171, 9369851092374283137ull},{16163359, 4539568180228208935ull},{16164581,18211837706550913441ull},{16165507,15412546995979766593ull},
		{16174409, 1732140531559079415ull},{16179661,10492475743208936665ull},{16180903,16145957810547426145ull},{16184957,15091206671754796143ull},{16186603,15907332645141087985ull},
		{16189127, 5212322745663667383ull},{16194487,10173479279066636175ull},{16195183,15192552222295211305ull},{16197113,13841445967322975943ull},{16197499,17050899974760590215ull},
		{16193159, 1385423280458214967ull},{16200641, 2828285506828385065ull},{16203211,11100172884046605975ull},{16205971, 9273740347421492193ull},{16206349,10694307907604074233ull},
		{16213033, 1614410328985344607ull},{16213187, 1954435271914117233ull},{16215149,16532972262340179657ull},{16215317, 1008121765686796233ull},{17801687,  128917458759517407ull},
		{17807753,  336494230971911497ull},{17716367,  905665796573663601ull},{17751211, 5618955195753508855ull},{17774759, 6014993229899159887ull},{17720089,13529342842575268383ull},
		{17760683,14990248056153767583ull},{17775391, 2350339510098510591ull},{17777197, 9571464417356251447ull},{17779403,18177477733292920041ull},{17779837, 7906895062697711601ull},
		{17789269,10001883951858619657ull},{17789957,18252033438277821393ull},{17820343,15700395625722743455ull},{17820353,15618585221939458585ull},{17822141, 3164553597118799223ull},
		{17829673,11147254248974845591ull},{17830871,11225984642974396225ull},{17835733,10023921494986403217ull},{17838259, 3260207741789404783ull},{17848801, 4875901499668317943ull},
		{17852519,15091062508870596217ull},{17852047,  601058353873004391ull},{17857373, 1701161678010384433ull},{17866621, 5208343099296284167ull},{17866657,13299976954651583865ull},
		{17869171,16676513047471408473ull},{17869783,  621259534838019577ull},{17870123,15084110248119306447ull},{17881901, 2826293090465457897ull},{17883293,13129524775288454065ull},
		{17893621, 5577207661761066993ull},{17898871,13731800934001310335ull},{17903773,15168446379627624537ull},{17903917,  840239117157541023ull},{17907991, 1108904181398829207ull},
		{17914537,14467964519448464401ull},{17924609,11950510395434416473ull},{17933621,14476051576170801127ull},{17933987,12271121888256658441ull},{17943683, 4871696868526692145ull},
		{17945779, 2390989063500577855ull},{17952059, 4526068326859465345ull},{17957671,11917441992759533751ull},{17955761, 7098876507611502201ull},{17960443, 1402663829241032233ull},
		{17968817,14222886584371031521ull},{17971001,15950977244893884273ull},{17972399, 3710008620325908985ull},{17972657, 7132236937769524687ull},{17975669, 7099626784541023537ull},
		{17979631, 4226380440331508463ull},{17979641,14785225336208575737ull},{17984581,  858523932063013273ull},{17987267, 6850516154583906681ull},{17987461,14388480591581056111ull},
		{17988371,12210936384520386513ull},{17994199, 2164882008197615161ull},{18005447,  166370812775332375ull},{18250433,  344598024120039225ull},{18224719,  553997798478189057ull},
		{18154817,   79872243127358095ull},{18150971,  655633122262579545ull},{18200599,   92076886106971825ull},{18284677, 1888915001773035865ull},{18051997, 1150367354656911321ull},
		{18238631, 1017245559490767655ull},{18206621, 1568022926158681023ull},{18100601, 2745906387390898953ull},{18245951, 2231815919872618561ull},{18014323, 2458848702076602991ull},
		{18023917, 2058241897646001985ull},{18110201, 2720723434949125423ull},{18282137, 2035603280846190463ull},{18133991, 2632171659342400255ull},{18123323, 3330516929914639263ull},
		{18006713, 3028904303953805257ull},{18229837, 3685053582537101961ull},{18287713, 4160915327054246911ull},{18053807, 4543935829736639911ull},{18290663, 4062712588739458377ull},
		{18076511, 4182270262765602793ull},{18066679, 4897645337609563137ull},{18072421, 5488276451463637903ull},{18144029, 5575221700433972071ull},{18144589, 5051459111074577343ull},
		{18151787, 5763204143979111753ull},{18035429, 6300514689716925561ull},{18224863, 6179587156579443145ull},{18262147, 6266978406726558697ull},{18287327, 6195008163268138447ull},
		{18210433, 6203752099699856671ull},{18050729, 6425811605110608777ull},{18143687, 6473267153150631561ull},{18174397, 6246898253762108191ull},{18062267, 6855361096834950297ull},
		{18292607, 6407061090330898495ull},{18248981, 7276207334850673095ull},{18207569, 7642254765211602895ull},{18091121, 8151237761253289881ull},{18054097, 8052096042537656761ull},
		{18200087, 8912314933991519977ull},{18055393, 8317264894231219935ull},{18249053, 8407382588101954711ull},{18189331, 8789539481715341863ull},{18043997, 8515722445328005785ull},
		{18011239, 8951373386839770463ull},{18298117, 8636556078317653257ull},{18271801, 8490243542019023553ull},{18202253, 8748336695715872857ull},{18100171, 8782994045353648191ull},
		{18191993, 8974531565168049591ull},{0,0ull}
	};

	/* Factors <= 96 bits: */
	static const struct testFac96 fac96[] =
	{
		{18276023,         1u, 9352652860056109297ull},{18169451,         1u, 9391223343761911353ull},{18101203,         1u, 9245198838244718175ull},{18200431,         1u, 9638047650792060207ull},{18153137,         1u, 9331979875586794647ull},
		{18286589,         1u, 9164964664217404903ull},{18087869,         1u,18404873023603575487ull},{18211181,         1u,10434605500782496975ull},{18211313,         1u,15746090072000275711ull},{18085237,         1u,10657076381559003585ull},
		{18210259,         1u,16355331429482797863ull},{18084967,         1u,12535841202704578975ull},{18084109,         1u,16470485288787225105ull},{18214087,         1u,10207338191440827513ull},{18214733,         1u,17740871572718924041ull},
		{18219479,         1u,18017792182604237361ull},{18066011,         1u,11376490360570509583ull},{18066007,         1u,11743936157345608143ull},{18242551,         1u,16695389546547233823ull},{18243733,         1u,13242634967295051207ull},
		{18051727,         1u,12764547214878403897ull},{18198319,         1u,14789209292635722871ull},{18252719,         1u,11949949204123386865ull},{18112553,         1u,14699169213035249007ull},{18188237,         1u,12547222997198167135ull},
		{18253273,         1u,15022424507268036615ull},{18177769,         1u,11181456191737830247ull},{18261431,         1u,12524685482980431153ull},{18263183,         1u,13717086022817448657ull},{18266477,         1u,13203156723265013793ull},
		{18165269,         1u,15387405357686244967ull},{18268543,         1u,10094150846373329745ull},{18134009,         1u,16150555121170358703ull},{18134147,         1u,12395351030116788801ull},{18134503,         1u,15773366615529206215ull},
		{18039589,         1u,12778558630672248943ull},{18276109,         1u,16390963948859540473ull},{18030241,         1u,15223465608795025207ull},{18285769,         1u,16970223144559381623ull},{18128549,         1u,15621768181131297471ull},
		{18285779,         1u,16993305172548993081ull},{18018739,         1u,14782732913885672961ull},{18295141,         1u,15005657306462735095ull},{18067589,         1u,13635840857860527775ull},{18295429,         2u,11468839311814080137ull},
		{18141763,         2u, 3092281768231311825ull},{18013091,         2u, 6772961738882249817ull},{18141511,         2u, 9576098065896122991ull},{18141127,         2u, 2247772876461344439ull},{18138203,         2u, 4695706118051975177ull},
		{18161641,         2u, 3950924079024657471ull},{18292093,         2u,12421322989569225951ull},{18123713,         2u,12125574039462479825ull},{18123709,         2u,10308047940655965639ull},{18173257,         2u,  207535002320717055ull},
		{18173983,         2u,14403605950085358951ull},{18120779,         2u, 9422223333804691761ull},{18019927,         2u,  408406707228848249ull},{18288797,         2u,17360156522995678599ull},{18177359,         2u,14832757638836506257ull},
		{18021973,         2u,13957432374640225095ull},{18025373,         2u,10098147461342295887ull},{18030193,         2u,15607091523248359911ull},{18118223,         2u, 2086356729639751937ull},{18185821,         2u, 1689334627499619465ull},
		{18117667,         2u,18215785349680460505ull},{18191837,         2u, 4493229489136679145ull},{18039271,         2u,16908805479784654401ull},{18281567,         2u,  933612760336845065ull},{18277937,         2u,10828438976824746849ull},
		{18039583,         2u,16417153962708385977ull},{18106591,         2u, 6626926712493143231ull},{18104287,         2u, 5723270436532623081ull},{18100177,         2u, 5071318343531010431ull},{18201467,         2u, 8160208643402298681ull},
		{18096061,         2u, 5937864839522586857ull},{18273883,         2u, 9773485756057249919ull},{18205183,         2u,15965092645879202447ull},{18272207,         2u,18262224097511217255ull},{18034481,         2u,13499269779109594391ull},
		{18206509,         2u, 8346049916247856479ull},{18093931,         2u, 9016815379266258047ull},{18270737,         2u,14523795906613507401ull},{18093689,         2u, 7580734199533821447ull},{18268721,         2u,11636683762416614271ull},
		{18092993,         2u, 3762951486187803561ull},{18089803,         2u,15886632766576700241ull},{18034843,         2u, 9087385776245663847ull},{18268303,         2u, 7107598341676734585ull},{18041711,         2u,10757635336355125415ull},
		{18080327,         2u, 4758087939326186009ull},{18264241,         2u,11059071541209885857ull},{18044431,         2u,12003164749400602311ull},{18259963,         2u,15572392068966635289ull},{18258577,         2u,10083568368046177095ull},
		{18076199,         2u, 1454254024310888471ull},{18067363,         2u, 6406596177417022745ull},{18050309,         2u,18266669341317591087ull},{18225367,         2u,  761543200176047729ull},{18066091,         2u, 4899820894457011847ull},
		{18233899,         2u,15827163809275823697ull},{18233951,         2u,12763352503716067857ull},{18050917,         2u,12630824986549901607ull},{18237679,         2u,  577537617363161615ull},{18051611,         2u,  926957969535303017ull},
		{18051823,         2u, 7818658096538148999ull},{18248603,         2u,16682557782845116569ull},{18064201,         2u, 4069052049914747889ull},{18060871,         2u,11707201997664612815ull},{18243989,         2u, 6890936471658773391ull},
		{18248441,         2u,17190543255548706647ull},{18246433,         2u,12208236782114945297ull},{18056369,         3u,17384615928981125225ull},{18239717,         3u,13146163309434854663ull},{18239423,         3u, 9830331743268882449ull},
		{18064247,         3u,12694290879965764249ull},{18051413,         3u,14413895596060013105ull},{18250439,         3u,10025619183380103271ull},{18237281,         3u, 9125012626367750681ull},{18224879,         3u,11767560264583516825ull},
		{18255343,         3u, 5870725649191146911ull},{18256097,         3u, 3190651672811461271ull},{18221701,         3u, 3582478237908082991ull},{18219983,         3u, 8327348782275241889ull},{18050233,         3u, 6535190184551801743ull},
		{18261623,         3u,17086528894147714391ull},{18048889,         3u,14630863141546358215ull},{18078727,         3u,15550160336321956111ull},{18217873,         3u, 3021804603112513103ull},{18082877,         3u,10987147732897659511ull},
		{18086017,         3u,12672060712653398353ull},{18088957,         3u, 2906408230830983393ull},{18208621,         3u, 9127697742932317439ull},{18207347,         3u, 6623005940415687023ull},{18206281,         3u,11960252621902730281ull},
		{18271933,         3u,12291953682343228271ull},{18205601,         3u,16600095605189677529ull},{18203707,         3u,18008003865578937049ull},{18039629,         3u, 9427695590083594375ull},{18198977,         3u, 3076193691622372985ull},
		{18110383,         3u,  185345134978204289ull},{18196499,         3u,11880812732795403521ull},{18111229,         3u,11071059034249992329ull},{18035989,         3u, 5539705418955744265ull},{18183743,         3u,11415352866482141719ull},
		{18028897,         3u, 3716387045703399295ull},{18285781,         3u, 9357102466781895559ull},{18180077,         3u,15536479403169204695ull},{18022649,         3u, 5654606217092758855ull},{18118489,         3u, 6394983796367039201ull},
		{18287957,         3u, 8752778334904342079ull},{18176321,         3u,17471759203966653145ull},{18175529,         3u, 2271464572669811305ull},{18163883,         3u, 3719255206030166033ull},{18019699,         3u, 4310391407591765215ull},
		{18151579,         3u, 1595301140365420159ull},{18142301,         3u,12867206532962105191ull},{18143519,         3u, 2481422238311117321ull},
		{ 7244507,  25571934u,17645344339951798897ull},{ 7414637,       164u, 4116711638593590185ull},{ 7723447,      5420u,12562746707691010049ull},
		{ 7818977,      1353u,  659102583034765273ull},{ 8029633,       831u, 7916220548900207543ull},{ 8053889,   2103436u, 1167145018735557081ull},{ 8086453,      1227u,17541595206117360217ull},{ 8095291,      1704u,13708852579508485207ull},
		{ 8168357,     87810u, 6610049516710328711ull},{ 8184557,        33u, 2763581858425117679ull},{ 8243537,       531u, 5525174834371803241ull},{ 8259871,        14u,  796855330669004183ull},{ 8272661,       380u,14241720166580408009ull},
		{ 8273437,  25987538u,14814742953278716353ull},{ 8283053,       161u,13929456041379261263ull},{ 8297321,   3034093u, 8730546825436233825ull},{ 8314843,   2684125u, 6454422580796036649ull},{ 8333579,       854u,13655594228639799257ull},
		{ 8361211,        12u, 8939076096818105929ull},{ 8390441,       595u, 4193551430717959153ull},{ 8422597,      1366u, 7870914753859973521ull},{ 8427803,      1474u,11450161366987292943ull},{ 8444941,      2885u,11827496755524969729ull},
		{ 8461697,        90u, 5398489150994146721ull},{ 8484347,         6u,12630454963470541663ull},{ 8489857,         8u,17355799175298876081ull},{ 8493427,       805u, 9747852211561597759ull},{ 8529877,       136u,16465808959478947065ull},
		{ 8592989,      1038u, 8509600750746547649ull},{ 8620109,         4u, 9079157166504874159ull},{ 8622461,         5u, 2437973634125785521ull},{ 8654389,         8u, 9482848212441108929ull},{ 8654579,        21u,11899068713858479361ull},
		{ 8656603,        93u,15062407632802667551ull},{ 8658217,        80u, 6325248917681739887ull},{ 8668423,        28u,18320769443016069721ull},{ 8674759,         7u,18284948339037548257ull},{ 8676287,        14u, 3843963214618658969ull},
		{ 8678947,      5396u, 2636802174995602407ull},{ 8681021,       401u, 4998736748668298991ull},{ 8681579,        30u,16135213582861992497ull},{ 8683729,         8u,11293259574337184559ull},{ 8688011,       145u, 9578503463191650391ull},
		{ 8692877,     36661u,18428023068529200991ull},{ 8697607,        17u,  870550676082897689ull},{ 8704219,     27999u,16201955968424701817ull},{ 8711159,        17u,11366350694546647641ull},{ 8719301,        88u,13672547084272167169ull},
		{ 8722339,      7423u,18156437144620420569ull},{ 8723123,    217954u, 6973216771046930049ull},{ 8725657,        63u, 2916601161951227239ull},{ 8725841,        25u,13195469447575389151ull},{ 8738729,         6u, 8170383313133995223ull},
		{ 8740939,       240u, 4617356654063117857ull},{ 8747819,    108516u, 9367350152656600871ull},{ 8749571,         9u,15657372839554601087ull},{ 8751563,         5u,13841889794965422657ull},{ 8755027,       593u,16519620384372861863ull},
		{ 8756101,      8284u, 6072693151654549537ull},{ 8763817,       119u, 6048599338562527617ull},{ 8767069,    257333u,15121360214969010561ull},{ 8776997,        64u,14339583161777897937ull},{ 8789447,       215u, 3202800343531181993ull},
		{ 8799389,       709u, 1702544524884741217ull},{ 8799529,     22022u, 3369348266587752401ull},{ 8800037,        17u, 1648884270309857487ull},{ 8801491,      3693u,16652078850798618551ull},{ 8802329,       419u,15755726911414877649ull},
		{ 8808773,       440u, 2473070962046579177ull},{ 8815151,        52u,  819707353106726625ull},{ 8816747,     92343u,16904660106867077831ull},{ 8823883,    520923u, 3776175324622247383ull},{ 8824301,       439u, 8808290111578886823ull},
		{ 8827319,   9331025u,10299995606463506351ull},{ 8839343,        93u,10232357004734229929ull},{ 8845349,     17999u,17028006110880085593ull},{ 8845399,       480u, 5232264661915708753ull},{ 8851631,       881u,11375193854275230591ull},
		{ 8852323,      3529u,13976988789038676439ull},{ 8879971,     55760u, 4065954677724111201ull},{ 8885839,    189157u,13972705208713530009ull},{ 8887667,     15650u, 3479161486544600081ull},{ 8891479,       281u, 3908734036550545881ull},
		{ 8892001,    399980u,  348160936584190151ull},{ 8895067,       659u,12293902350439178087ull},{ 8896403,    281473u, 4911135064261999521ull},{ 8907659,     28045u,14784606591196077103ull},{ 8910043,       821u, 5656531726894273265ull},
		{ 8914519,       949u, 4686244932662218297ull},{ 8925463,  34406392u, 6947221817440081257ull},{ 8928847,    280991u,18128549402387363145ull},{ 8941447,       170u, 7578823934664030161ull},{ 8942761,    285889u,12419432609440032345ull},
		{ 8943461,    268039u,15846513700731858799ull},{ 8947891,      1735u, 9265596559543333297ull},{ 8955143, 101273010u,12253893124535158577ull},{ 8980789,     22537u,13426157623604500687ull},{ 8982371,       101u,14022829103709041663ull},
		{ 9009229,     89356u,15359747832206463841ull},{ 9023117,      1296u, 9569964735123059105ull},{ 9331061,       203u, 1005489040573919343ull},{ 9360067,      7440u, 1016920852914327511ull},{11836397,        76u, 4753937900335225801ull},
		{12342461,      3185u, 1753345721477568209ull},{12682547,   4085607u,16926237622668427889ull},{12702857,     55435u,15473514712868330607ull},{12999053,   1235292u, 3762487385164613785ull},{14498369,    128237u,14526323552203604241ull},
		{15165389,       485u,  330179403340003319ull},{15190393,     13872u,11887173197900552719ull},{15267589,        74u,14963262145345516425ull},{15331573,     49730u, 4408178729149087001ull},{15421487,       921u, 8877756807240402497ull},
		{15626909,  11906539u, 4417661925555319825ull},{15729583,       186u,10717054419563574223ull},{15729827,1057892912u,14816318765732916257ull},{15829861,     19825u,15865309391356950409ull},{15904423,       110u, 4238645735120536409ull},
		{15983707,        48u, 4357300712211145471ull},{15991193,      3046u, 3680186924956910097ull},{15997109,       308u,15794942471928637713ull},{16051547,     11155u,15864453969212219103ull},{16129213,       392u, 3754198172882755785ull},
		{16131979,      6827u,10576842754565059055ull},{16172621,    191569u,  891829992192399319ull},{16204523,  18537874u,13853273991470839569ull},{16210483,        64u,11178113142365390047ull},{16218907,      3470u, 9365149503113345247ull},
		{16226809,      1100u, 7659583808777621319ull},{16296349,     74952u, 6789913543149950497ull},{16322297,       748u, 8822692284702673065ull},{16364057,       268u,10431176301742662465ull},{16377743,      3176u, 5972801908074189743ull},
		{16406363,     30172u,  253845389692387185ull},{16416161,     84184u, 8026903278674309185ull},{16444163,    123743u,13602749018509000529ull},{16445119, 199993173u, 2826719993506082993ull},{16462993,      1933u, 2246545941595562751ull},
		{16465439,    767792u, 7421856042576531887ull},{16468129,    672932u, 9193735353107684049ull},{16503173,      2024u, 9443492740464039183ull},{16521053,      4172u, 4215545972090492199ull},{16544719,   3532287u,15490834954328089129ull},
		{16608113,       993u,11973891496836029831ull},{16658221,    994392u, 9265003897988786177ull},{16662589,      5583u,10877104196614353761ull},{16669259,     37695u,14727883460246356457ull},{16685437,   9776194u, 6889969512162125377ull},
		{16723717,    212092u,14906504205635945761ull},{16727479,     14410u,18068882455710331257ull},{16785413,    129671u, 9903178178510980001ull},{16792663,      9703u,11105483931030878809ull},{16800587,     11130u,13650391737015148049ull},
		{16804847,   6500829u, 3533341371541809833ull},{16808453,      4936u, 7844623794952651617ull},{16809391,     29703u, 9869185788127161889ull},{16817747,   4387352u, 2015829708477243887ull},{16819343,    227351u,14577617651386377761ull},
		{16820549,  29259736u, 2579164402117877625ull},{16825007, 390682869u, 9671153211854428993ull},{16825889,      1645u, 5034090624360750817ull},{16826959,    394522u, 4262342457128545047ull},{16832939,   2283480u, 3499229584108421473ull},
		{16843219,1740637150u,16678575536200532911ull},{16843987,    892167u,11320504716025434577ull},{16861753,     27509u, 4966077503304358433ull},{16864429,   3472340u, 7383710753692858103ull},{16865557, 141107518u,12657461798830290009ull},
		{16872847,      7042u, 5664463976168682217ull},{16876267,    768500u, 2386605663683715839ull},{16877227,     26909u,16828458807433451793ull},{16878749,    347420u, 5530942263660718719ull},{16892789,     37499u,15689282913842113409ull},
		{16895803,   1532721u,18305119409047103975ull},{16897009,    317299u,   35208741571512609ull},{16900309,      2472u,13474962507039928007ull},{16910191,    170146u, 5170061300924029473ull},{16928419,      1489u, 5006545141137940057ull},
		{16930393,   9582022u,11727071280078615841ull},{16937773,      3510u, 9267789279716192833ull},{16938461,     77244u, 4261887363890383759ull},{16942561,    333713u,16416959992066943223ull},{16950361,      2580u,11177105512311418417ull},
		{16969409,     39842u,14393933843859339287ull},{16979441,    505755u,16434730466875831753ull},{16981427,     28066u, 9296044504676969833ull},{16983727,  94240809u,17752094683956384025ull},{16983983,     28059u,16091607843728445223ull},
		{16995779,      6661u, 7830143707771831545ull},{17025413,     10724u, 8148147940903146705ull},{17026687,     31859u, 6811989873351804369ull},{17034133,     20487u,17357576493083550241ull},{17039059,    122645u,11496188035198294967ull},
		{17048029,    285247u,13305518687973938281ull},{17056447,   2606122u,12574870762596486535ull},{17083237,   8461215u, 9905576412463209257ull},{17083777,     18430u,11428865434586521009ull},{17087557,     37215u,14875832505057766609ull},
		{17095889,   1323377u, 3717220050156882191ull},{17097389,1760731413u, 9843676629243088873ull},{17105299,     81371u, 1929162103058421135ull},{17109713,     51459u,17280464114564148169ull},{17110757,   2046067u, 8067475805035482625ull},
		{17112113,     52542u, 1517105784283888919ull},{17112191,     24884u,15515225620652684223ull},{17113253,      7250u,15583958528602828257ull},{17114791,     13155u,15934260513033726703ull},{17140177, 819404853u, 7737165812083468943ull},
		{17154157,   2917808u,14475130768968748289ull},{17168243,      1189u,14031023330502092233ull},{17174827,     20877u, 3116423579334084745ull},{17191459,    164012u,11124925933076103519ull},{17196229,    452235u,11155442872175691889ull},
		{17199473,     51825u, 6083166130595396831ull},{17213509,   1022179u,12911928712002520737ull},{17220101,   3214549u, 7363134224170851673ull},{17227849,    172183u,10847800035774997255ull},{17238307,  12542043u,15663835937396410441ull},
		{17251489,2144117919u,15480179807909042479ull},{17253517,  12309654u, 6025235993786279423ull},{17257879,    161418u, 1382566104163313935ull},{17260589, 115175336u,10283224490478819833ull},{17264011,   1744457u,  994697667365615745ull},
		{17268703,   2063251u, 9350765217636640455ull},{17269621,  13735949u,  673788709708729265ull},{17270191,    259556u,13644816076166641193ull},{17277367,    378545u,10258283237536366089ull},{17295857,    164529u,12996504031838402257ull},
		{17297321,    136045u, 3477326686230228009ull},{17300057,    485742u,10134593588474735065ull},{17309261,    131275u, 6030008496201936663ull},{17326747,   1611645u, 1921630189938798817ull},{17358763,   3232800u, 4928905537991785441ull},
		{17359063,  35383704u, 2015083763123199095ull},{17362099,     53690u, 9683541530822602193ull},{17385503,4046742644u,16856501793554568897ull},{17387893,  41374286u, 2560656520549446921ull},{17395817, 159852898u,16792033592198659863ull},
		{17427923,    188981u,  532633914835864385ull},{17433629,    695925u, 3505119555206483393ull},{17444443,    513163u, 5445979551755147943ull},{17450053,    157812u,18415231095804314545ull},{17456651,    551552u, 3880353390263834249ull},
		{17467139,    211059u,10062518427716833465ull},{17477639,    264827u, 6507519522524416335ull},{17503567,    319478u,15607288692565636353ull},{17506249,   7246235u,10929482532834898487ull},{17518877,   8867104u,11570050222122965689ull},
		{17527283, 136813947u, 3326024563062685825ull},{17536823,    440352u, 9878707771636535647ull},{17539007,   4354617u, 4406481822187523599ull},{17540879,    726756u, 1118113451897253593ull},{17555399,  35153812u, 4507443726068176209ull},
		{17566609,  21653383u, 7399444876854645393ull},{17569711, 479166769u,11868486932669699833ull},{17571031,    484527u, 7060215751726447079ull},{17616943,    114090u,14738812321054635817ull},{17622817,  13690398u, 4811636227715074249ull},
		{17647373,    103263u, 3189089353926248513ull},{17652469,   1244343u,  141431592584913433ull},{17675893,   4077389u,13651439017267265249ull},{17679919,   7872193u, 3894559783103852031ull},{17698939,     47810u, 7782021279990355767ull},
		{17711143,    640279u, 5303785660976639535ull},{17732801,   4103871u, 4583035766799531017ull},{17739133, 130747716u, 1947030475661309305ull},{17739583,     69157u,  539914343514113919ull},{17746877,   6306926u,13250449299753722625ull},
		{17783203,    128254u, 9322981120069197199ull},{17797207,    117994u, 6024425248459124193ull},{17807701,  16601701u, 2797681640543443633ull},{17814431,     59907u, 3165706124645613559ull},{17833331,    108749u,10677366860900144129ull},
		{17835473,    865553u, 8821789166368052975ull},{17841821,  16595068u, 2785009705636697065ull},{17858671,     83788u,11636762661956212849ull},{17860541,    127880u,11679412360494356457ull},{17871673, 899827073u, 4365981991822767335ull},
		{17883197, 171007919u,14112849719432819969ull},{17891383,  15314611u, 5494386947721296607ull},{17901223,  26483927u, 8759360566729963809ull},{17907917,   2699547u,15287649357901403887ull},{17920373,    117967u,14284930551950649009ull},
		{17941151,    135102u,13697963633382258847ull},{17953391,   4407462u, 3856268332031058257ull},{18015407,    823035u, 3863124271074440977ull},{18017383,   1360055u, 7566698478337249511ull},{18120731,    223471u, 3508167879733895305ull},
		{33227807,  14922325u, 2838567728392815481ull},{33233503,  12807462u, 3334091319432416681ull},{33241399,    166492u,12812515124938083865ull},{33250067,2182275258u, 8923029501170211169ull},{33251227,   6911594u,13590065507670693809ull},
		{33256609,   1818244u,  220871972264494263ull},{33259153,  38814254u,16386977130529408193ull},{33268253,  27991294u, 3898646068209270567ull},{33277301,    683360u, 4806541503703691279ull},{33280787,    282030u, 9924364295782824137ull},
		{33282257,     79056u, 8075902570930756103ull},{33284753,    111827u,15449457299209774881ull},{33286807,  81756638u, 2255231334031845305ull},{33290197,    189083u,14424443831930143785ull},{33291679,    367547u,18387530411978866559ull},
		{33299443,    776963u, 2636922682980779825ull},{33311869,    186338u, 1874415908399668103ull},{33337613,    323616u, 3695590210606875881ull},{33340963,     96949u,11960300797586306719ull},{33344947,    205119u,12785072524810844153ull},
		{33357251, 120482483u, 5734238336333966079ull},{33360631,    124712u, 6837598985057705985ull},{33364561,    247352u,17266053889495344551ull},{33369911,   6119593u, 2157811649735073519ull},{33379673,    500668u, 1793898280018450369ull},
		{33394931,    504443u,12345311626227159743ull},{33396289,    389902u,15587540931804441849ull},{33396457, 328283329u, 3027562459369760823ull},{33399761,    279642u, 9658553917939196047ull},{33406151,  57459294u,12082998895638046327ull},
		{33406621, 125212997u, 5566884921004692039ull},{33408533,    120922u,12235980571743216255ull},{33408943,   2787233u, 9527286207438248745ull},{33411487,   1062745u,12865415306884302993ull},{33422659,    403467u, 6257350676364808409ull},
		{33423319,     57634u,17459695061727397089ull},{2147483647,      13u, 2749942686469094193ull},{2147483647,    9650u,10298917214042272751ull},{19016461,3264525660u, 8603927029340062289ull},{0,0,0ull}
	};

	/* Factors > 96 but <= 128 bits. If desired, we can construct more test factors
	by multiplying together a 63/64-bit factor q1 of M(p1) and a 65/64-bit factor q2 of M(p2)
	and checking whether q1*q2 divides M(p1*p2).*/
	static const struct testFac128 fac128[] =
	{
		{     695,   12240518780192025ull, 1654746039858251761ull},
		{     845, 2923447923687422893ull,  353773459776294223ull},
		{    1113,     128099917305337ull, 7733695761441692271ull},
		{    1145,   10811609908058563ull, 5349936413307099433ull},
		{    1149,        700245770430ull,  701890237964104231ull},
		{     733,  756146046438660814ull, 7804835620876695225ull},
		{     737,  106450884062962221ull,17050154159176967743ull},
		{     871, 7448657723978021346ull,15223106393317212577ull},
		{     947,     644719741813452ull,16055621295463638505ull},
		{     953,      44696312570505ull, 4961431981940124743ull},
		{     989,   99970972632587991ull, 1738540175825943815ull},
		{    1081,         67677680549ull,13887741953162944095ull},
		{    1091,    5287390011750720ull, 2894679571106043497ull},
		{    1097,      11129117045170ull,10375766809019373543ull},
		{    1099,       1551337752834ull, 8321741389535251703ull},
		{    1133,  133834206206032981ull, 6586095673132787791ull},
		{    1141,       5747037125100ull, 2460710484528304153ull},
		{    1181,      10824073357153ull, 7361144750966677159ull},
		{    1189,   32559650929209964ull, 8212830436061989903ull},
		{   27691,   94004235929829273ull, 4235226679561594903ull},
		{  319057,        103337218078ull, 8676403300852410079ull},
		{17363977,      62897895526806ull,14211535226588354713ull},
		{10624093,          5492917609ull,14854696485656401105ull},
		{10698673,          5799457823ull,10285356664749312993ull},
		{20799431,          4303087381ull,16578386512849109713ull},
		{33652757,          5202063708ull,18263664019678288919ull},
		{21823211,          7785579841ull, 7607475409566672241ull},
		{22330859,          7593776864ull, 5630449305759171207ull},
		{11808917,         20308449831ull, 9058738039473012457ull},
		{20090969,         15531431134ull, 5034609389988515233ull},
		{20313967,         18216394609ull, 8291172543411688687ull},
		{20544481,         16259503442ull,15859685870849762975ull},
		{22217387,         20551559047ull,11995354231649723881ull},
		{10207999,         28364424832ull,15122069645900159367ull},
		{19964723,         34441477586ull, 9636073161914837921ull},
		{21145199,         30977655046ull, 1304857345634219175ull},
		{22030163,         43144178324ull, 4788416424359163737ull},
		{33562153,         45963786472ull, 2258783450670948535ull},
		{33693587,         66325700032ull,15262466751214122975ull},
		{11865241,         57210216387ull, 3082735332820781609ull},
		{21801929,         80355238912ull,15689518004012743009ull},
		{19951201,        109346652057ull,10819675441336938065ull},
		{20616781,      17534809723250ull,10329047311584913071ull},
		{20648443,       1221873279710ull, 2595613477835803991ull},
		{21250771,      12549422209078ull, 8612165677489771129ull},
		{21547787,        112416184026ull, 9015544550402598895ull},
		{21675733,        142220976614ull,11385509628023387489ull},
		{15714269,      14320762091913ull, 2773697912020767049ull},
		{19687561,       1996508583829ull, 7515490546312285159ull},
		{20152333,        365842230851ull, 2388855518206098663ull},
		{20510053,        261078947686ull,  465403687781705377ull},
		{20759821,     199835753775288ull,17079803649869853575ull},
		{20989043,        202355339943ull,15105677628487752455ull},
		{33713123,      18738454648009ull,16692905930976531153ull},
		{20542751,        412571049040ull,18170931828058363183ull},
		{20812849,     534505286298455ull, 2216600112648316881ull},
		{0,0,0ull}
	};

	/* Factors > 96 but <= 128 bits, with p > 64 bits - most of these are from my Jan 2003 runs of primes near 2^89: */
	static const struct testFac128x2 fac128x2[] =
	{
		{33554431ull,18446744073709551175ull,      30899672449023ull,18446744073303442655ull},
		{33554431ull,18446744073709551295ull,      85098334519295ull,18446744072895454529ull},
		{33554431ull,18446744073709551513ull,  430360347665235967ull,18446742752658555745ull},
		{33554431ull,18446744073709551513ull,  259661119604391935ull,18446743276643598623ull},
		{33554431ull,18446744073709551513ull,  293843670505881599ull,18446743171715500217ull},
		{33554431ull,18446744073709551567ull,   12593691025735679ull,18446744055318810857ull},
		{33554431ull,18446744073709551595ull,            67108863ull,18446744073709551575ull},
		{33554431ull,18446744073709551595ull,        631158865919ull,18446744073709156607ull},
		{33554432ull,                  89ull,      16384159383552ull,            43457455ull},
		{33554432ull,                 705ull, 7006880245689090048ull,     147219019329871ull},
		{33554432ull,                 741ull,        882615779328ull,            19491265ull},
		{33554432ull,                 741ull,     220386851553280ull,          4866917641ull},
		{33554432ull,                 767ull,     460834488713216ull,         10533930447ull},
		{33554432ull,                 837ull,    3613005073874944ull,         90124763455ull},
		{33554432ull,                 837ull,    1504315717976064ull,         37524469375ull},
		{33554432ull,                1059ull,            67108864ull,                2119ull},
		{33554432ull,                1275ull,          4898947072ull,              186151ull},
		/*{33554432ull,                1275ull,    1096248325046272ull,         41655201151ull},*/
		{33554432ull,                1337ull,      16333760626688ull,           650830209ull},
		{33554432ull,                1337ull,       1481763717120ull,            59041921ull},
		{33554432ull,                1521ull,   19343955296518144ull,        876848578633ull},
		{33554432ull,                1547ull,          2147483648ull,               99009ull},
		{33554432ull,                1917ull,    1124806032359424ull,         64261351945ull},
		/*{33554432ull,                1917ull,    2192593957945344ull,        125265199465ull},*/
		{33554432ull,                1917ull,         22749904896ull,             1299727ull},
		{33554432ull,                2097ull,      34829164871680ull,          2176665031ull},
		{33554432ull,                2585ull,      37028188127232ull,          2852614711ull},
		/*{33554432ull,                2585ull,    1096267786616832ull,         84455377711ull},*/
		{33554432ull,                2661ull,          2080374784ull,              164983ull},
		{33554432ull,                2675ull,           805306368ull,               64201ull},
		{33554432ull,                2729ull,      42057326395392ull,          3420544975ull},
		{33554432ull,                2729ull,       4876868255744ull,           396638319ull},
		{33554432ull,                2907ull,         22615687168ull,             1959319ull},
		{33554432ull,                3045ull,    1301649700159488ull,        118122200281ull},
		{33554432ull,                3045ull,         99321118720ull,             9013201ull},
		{33554432ull,                3155ull,      26011932557312ull,          2445806481ull},
		{33554432ull,                3159ull,        413994582016ull,            38975743ull},
		{33554432ull,                3507ull,        250450280448ull,            26176249ull},
		{33554432ull,                4155ull,   62084915730055168ull,       7687891270471ull},
		{33554432ull,                4451ull,          7851737088ull,             1041535ull},
		{33554432ull,                4485ull,        434328567808ull,            58053841ull},
		{33554432ull,                4745ull,         82678120448ull,            11691681ull},
		{33554432ull,                4745ull,         71672266752ull,            10135321ull},
		{33554432ull,                5121ull,        143814295552ull,            21948607ull},
		{33554432ull,                5247ull,            67108864ull,               10495ull},
		{33554432ull,                5411ull,     544322411823104ull,         87777631593ull},
		{33554432ull,                5499ull,    1739631741632512ull,        285096017935ull},
		{33554432ull,                5735ull,      10563740499968ull,          1805515641ull},
		{33554432ull,                5837ull,       7317214986240ull,          1272874591ull},
		{0ull,0ull,0ull,0ull}
	};

	/* Factors > 128 but <= 160 bits. If desired, we can construct more test factors
	by multiplying together a 64-bit factor q1 of M(p1) and a 96-bit factor q2 of M(p2)
	and checking whether q1*q2 divides M(p1*p2).*/
	static const struct testFac160 fac160[] =
	{
		{     629,       133ull,11545660419510266595ull,15875370168207932041ull},
		{     631,      1394ull,15571349859840161706ull,  509892144742137431ull},
		{     673,    121320ull, 4492854135134704005ull,14226674137430228263ull},
		{     695,2649519282ull,14842833464112563611ull,10174116463236461383ull},
		{     731, 655903171ull,17652352551621896287ull, 7660429456444636239ull},
		{     805,1083827012ull,18314245293386716597ull, 2219421057460140527ull},
		{     877,  13161208ull,18225246095436784582ull,12343089078196252631ull},
		{     957,      4730ull,14663183769241509326ull, 8097149896429635207ull},
		{     967,    215159ull,  881920578744577810ull,17184239148975426263ull},
		{    1017, 212724356ull, 9900144438119899815ull,17733134473107607967ull},
		{    1033,       261ull, 5238930328752646394ull, 2803405107698253561ull},
		{    1087,         1ull, 4415476118538293365ull,16346425147370540471ull},
		{    1087,     70130ull,11905462972019801043ull, 6167785434693019223ull},
		{    1131,   5800574ull,18429773635221665090ull,17951008765075981215ull},
		{    1157,  22381525ull,14500669099417213747ull,15903397166638806257ull},
		{    1283,        14ull, 3291757557782450881ull, 3893270457587058239ull},
		{    1319,      1552ull, 1390029428449091172ull,14288981644299514807ull},
		{    1483,      2674ull,14802171160149427175ull, 5085420234315110585ull},
		{    6659,       664ull,14291576310931480037ull, 4949688733053552967ull},
		{    8191,    617742ull, 6334326874596939334ull,11405337619840706193ull},
		{18031451,      2122ull, 5198971222801411122ull,12425019173815339143ull},	/* Note: composite factor! */
		{0,0ull,0ull,0ull}
	};

	/* Factors > 160 but <= 192 bits. We can construct more test factors by multiplying
	together smaller factors of M(p) with multiple factors, or for exponents p1, p2, p3, ...
	and corresponding factors q1, q2, q3, ... , checking whether q1*q2*q3*...
	divides M(p1*p2*p3*...). */
	static const struct testFac192 fac192[] =
	{
		{     677,     157590042578912ull,10558642444782195772ull,  329809049266961143ull},
		{     773,       9118322195022ull, 1933308633079010416ull,17814616685598394119ull},
		{     971,      70286054459973ull,17012949627558354271ull, 3547755741880899889ull},
		{     997,  492416983078691417ull, 8040689323464953445ull,16007877010440112335ull},
		{    1001,         59364131986ull, 9565712986615012496ull,10050950882119470361ull},
		{0,0ull,0ull,0ull}
	};

	/* 256-bit Factors are easier to give in character-string form: */
	/* EWM: These are from my April 2006 shakedown runs of the P4WORD functionality -
	ran ??? 64-65-digit test exponents up to k = 10^10; ??? had factors below this bound,
	compared to ??? predicted by theory (Dickman's function).
	*/
	static const struct testFac256 fac256[] =
	{
		{"1000000000000000000000000000000000000000000000000000000001059"			,"40000000000000000000000000000000000000000000000000000000042361"					},	/* k =          20 */
		{"12160287649628674460477464915995054973742562690104903778198683593"		,"543592246870442485937175551111623340804481341938942752102988291735322287319"		},	/* k = 22351126163 */
		{"20992192221842725502542568876717904946016534668049886272327917860857843"	,"41984384443685451005085137753435809892033069336099772544655835721715687"			},	/* k =           1 */
		{"24247014121478057345510500801908699603302763478708108175450119307"		,"2079083331892761004876676951418337621569030224230467189523407626117207889809"		},	/* k = 42872976472 */
		{"3082533446850352619311881710100031378387528865875332083814206171"			,"6165066893700705238623763420200062756775057731750664167628412343"					},	/* k =           1 */
		{"32046927906821207388377814233562823608963208068222468012248261177"		,"192281567440927244330266885401376941653779248409334808073489567063"				},	/* k =           3 */
		{"32046927906821207388377814233562823608963208068222468012248261177"		,"7261513394406617382132528927183000201554973316178529026895333500096431"			},	/* k =      113295 */
		{"3444030707469211201913020330380197621101100449293215160842444859637669"	,"53389364027187712052055641161553823522309259164943421423379580214103144839"		},	/* k =        7751 */
		{"3600113305305488204665213841469519415116094330572703657595919530921861"	,"1605650534166247739280685373295405659141778071435425831287780110791150007"		},	/* k =         223 */
		{"3852254995466672782398645659611635488623057745649803559363456817432411"	,"22788707831582286845380020155651359827337650244785629920055214225748565104481"	},	/* k =     2957840 */
		{"3873455283316355076479185358932261854896321329330898570642046752590709"	,"2921297999392661936999377930740968974773127205440094407601101388055871276457"		},	/* k =      377092 */
		{"4088350865739177150968288747826569959957449066175834413752239709"			,"532990125664685046817433867476654272539732719859211180852051986382913"			},	/* k =       65184 */
		{"41927056387293174872332083760112302991136793862708943879936201629"		,"586978789422104448212649172641572241875915114077925214319106822807"				},	/* k =           7 */
		{"53710507922796892589235420199561121290219608640344181598136297747713099"	,"107421015845593785178470840399122242580439217280688363196272595495426199"			},	/* k =           1 */
		{"54973742562690104903778198683593814657412680492564879855614537234786733"	,"769632395877661468652894781570313405203777526895908317978603521287014263"			},	/* k =           7 */
		{"5509792592309907965473761255176567513575178296664547791745011299"			,"742776869444172678136618913571387191947269048779332840473151581151737887"			},	/* k =    67405157 */
		{"570658748822569815793678976697422057505968344086973502014102067"			,"322107495328491256282531776450837995333351643082236449882652963072723913"			},	/* k =   282224268 */
		{"62735676303544776280350450777235547105859548702790814356240145171"		,"19573531006705970199469340642497490697028179195270734079146925293353"				},	/* k =         156 */
		{"62749567351885752724891227938183011949129833673362440656643086021"		,"6902452408707432799738035073200131314404281704069868472230739462311"				},	/* k =          55 */
		{"6402474964732639141992726042699227967823547816360093417216412199"			,"59547637466852043611708058111909725657028150812842162510646420336832110759"		},	/* k =  4650360821 */
		{"7195429162991930645537799140373404328752628889639958794757291746426357"	,"957164768977838582192020192849031737427989705415465878713793977276619713569"		},	/* k =       66512 */
		{"7095890455635792122103334669749923563025494780249011419521238281"			,"93538027986191011753566157616643492407802072193242468532128963020143"				},	/* k =        6591 */
		{"83011949129833673362440656643086021394946395224737190702179860943"		,"2473258012374264464160556924024104921441032899325819859780746776935743"			},	/* k =       14897 */
		{"85102283345085048608250393021332197155184306354550076682829493041"		,"23658434769933643513093609259930350809141237166564921317826599065399"				},	/* k =         139 */
		{"9104140792886215078424516709087000699282120660418371806535567252532567"	,"207009953348646758453216660931220221900276859576592938137005728188085508447"		},	/* k =       11369 */
		{"9729971208443357326548938239119325974636673058360414281388303203"			,"215547993800818444194894669517580993600170370441819907413109392526239783"			},	/* k =    11076497 */
		{""	,""		},	/* k =             */
		{""	,""		},	/* k =             */
		{""	,""		},	/* k =             */
		{""	,""		},	/* k =             */
		{""	,""		},	/* k =             */
		{""	,""		},	/* k =             */
		{""	,""		},	/* k =             */
		{"",""}
	};

	uint32	ntest63,ntest64,ntest65,ntest96,ntest128,ntest128x2,ntest160,ntest192,ntest256;
	uint64	p64,q64,res64 ;
	uint96 q96,res96;
	uint128 p128,pinv128,q128,x128,res128;
	uint192 p192,q192,x192,y192;
#if(defined(P2WORD) || defined(P3WORD) || defined(P4WORD))
	uint128 two_p128;
#endif
#if(defined(P3WORD) || defined(P4WORD) || defined(NWORD))
	uint192 two_p192,res192;
	uint256 p256,two_p256,q256,x256,res256;
#endif
#if(defined(P4WORD))
#endif
	const uint64 two64mod60 = 16;
	uint64 two64modp;
	uint64 k, sum1=0, sum2=0;
	uint32 i,j,l;
#ifdef USE_FLOAT
	double dbl,rnd;
#endif
	uint32 pm60,km60;
	uint64 hi64,lo64;
#if FAC_DEBUG && (defined(P2WORD) || defined(P3WORD) || defined(P4WORD))
	uint32 i2,i3,i4,ii,jj;
#endif
	char cbuf0[STR_MAX_LEN], cbuf1[STR_MAX_LEN], cbuf2[STR_MAX_LEN];
	uint64 *p = 0x0, *q = 0x0, *q2 = 0x0, *two_p = 0x0, *u64_arr = 0x0;

/****12/12/05: check p%4==3 / q%60 correlations: *****/
	uint32 pqmod60arr[60][60] = {{0}};
/*****************************************************/

	/* 3/29/2006: by way of testing the 256-bit factoring routines, find all 70-digit base-2
	probable primes occurring in the first few thousand digits of Pi: */
#if TEST_256
	uint64 tmp64;
	/* Here are the first 10000 or so digits of Pi: */
	char Pi[10240] = "";
	const uint32 primelen = 64;

	/* To avoid compiler limits on character literal length, copy digits into Pi[] in 1Kbyte chunks: */
	strcpy(cbuf0, "314159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912983367336244065664308602139494639522473719070217986094370277053921717629317675238467481846766940513200056812714526356082778577134275778960917363717872146844090122495343014654958537105079227968925892354201995611212902196086403441815981362977477130996051870721134999999837297804995105973173281609631859502445945534690830264252230825334468503526193118817101000313783875288658753320838142061717766914730359825349042875546873115956286388235378759375195778185778053217122680661300192787661119590921642019893809525720106548586327");
	strcat(Pi, cbuf0);
	strcpy(cbuf0, "886593615338182796823030195203530185296899577362259941389124972177528347913151557485724245415069595082953311686172785588907509838175463746493931925506040092770167113900984882401285836160356370766010471018194295559619894676783744944825537977472684710404753464620804668425906949129331367702898915210475216205696602405803815019351125338243003558764024749647326391419927260426992279678235478163600934172164121992458631503028618297455570674983850549458858692699569092721079750930295532116534498720275596023648066549911988183479775356636980742654252786255181841757467289097777279380008164706001614524919217321721477235014144197356854816136115735255213347574184946843852332390739414333454776241686251898356948556209921922218427255025425688767179049460165346680498862723279178608578438382796797668145410095388378636095068006422512520511739298489608412848862694560424196528502221066118630674427862203919494504712371378696095636437191728746776465757396241389086583264599581339047802759009946576407895126946839835259570982582262052248");
	strcat(Pi, cbuf0);
	strcpy(cbuf0, "940772671947826848260147699090264013639443745530506820349625245174939965143142980919065925093722169646151570985838741059788595977297549893016175392846813826868386894277415599185592524595395943104997252468084598727364469584865383673622262609912460805124388439045124413654976278079771569143599770012961608944169486855584840635342207222582848864815845602850601684273945226746767889525213852254995466672782398645659611635488623057745649803559363456817432411251507606947945109659609402522887971089314566913686722874894056010150330861792868092087476091782493858900971490967598526136554978189312978482168299894872265880485756401427047755513237964145152374623436454285844479526586782105114135473573952311342716610213596953623144295248493718711014576540359027993440374200731057853906219838744780847848968332144571386875194350643021845319104848100537061468067491927819119793995206141966342875444064374512371819217999839101591956181467514269123974894090718649423196156794520809514655022523160388193014209376213785595663893778708303906");
	strcat(Pi, cbuf0);
	strcpy(cbuf0, "979207734672218256259966150142150306803844773454920260541466592520149744285073251866600213243408819071048633173464965145390579626856100550810665879699816357473638405257145910289706414011097120628043903975951567715770042033786993600723055876317635942187312514712053292819182618612586732157919841484882916447060957527069572209175671167229109816909152801735067127485832228718352093539657251210835791513698820914442100675103346711031412671113699086585163983150197016515116851714376576183515565088490998985998238734552833163550764791853589322618548963213293308985706420467525907091548141654985946163718027098199430992448895757128289059232332609729971208443357326548938239119325974636673058360414281388303203824903758985243744170291327656180937734440307074692112019130203303801976211011004492932151608424448596376698389522868478312355265821314495768572624334418930396864262434107732269780280731891544110104468232527162010526522721116603966655730925471105578537634668206531098965269186205647693125705863566201855810072936065987648");
	strcat(Pi, cbuf0);
	strcpy(cbuf0, "611791045334885034611365768675324944166803962657978771855608455296541266540853061434443185867697514566140680070023787765913440171274947042056223053899456131407112700040785473326993908145466464588079727082668306343285878569830523580893306575740679545716377525420211495576158140025012622859413021647155097925923099079654737612551765675135751782966645477917450112996148903046399471329621073404375189573596145890193897131117904297828564750320319869151402870808599048010941214722131794764777262241425485454033215718530614228813758504306332175182979866223717215916077166925474873898665494945011465406284336639379003976926567214638530673609657120918076383271664162748888007869256029022847210403172118608204190004229661711963779213375751149595015660496318629472654736425230817703675159067350235072835405670403867435136222247715891504953098444893330963408780769325993978054193414473774418426312986080998886874132604721569516239658645730216315981931951673538129741677294786724229246543668009806769282382806899640048243540370141631496");
	strcat(Pi, cbuf0);
	strcpy(cbuf0, "589794092432378969070697794223625082216889573837986230015937764716512289357860158816175578297352334460428151262720373431465319777741603199066554187639792933441952154134189948544473456738316249934191318148092777710386387734317720754565453220777092120190516609628049092636019759882816133231666365286193266863360627356763035447762803504507772355471058595487027908143562401451718062464362679456127531813407833033625423278394497538243720583531147711992606381334677687969597030983391307710987040859133746414428227726346594704745878477872019277152807317679077071572134447306057007334924369311383504931631284042512192565179806941135280131470130478164378851852909285452011658393419656213491434159562586586557055269049652098580338507224264829397285847831630577775606888764462482468579260395352773480304802900587607582510474709164396136267604492562742042083208566119062545433721315359584506877246029016187667952406163425225771954291629919306455377991403734043287526288896399587947572917464263574552540790914513571113694109119393251910");
	strcat(Pi, cbuf0);
	strcpy(cbuf0, "760208252026187985318877058429725916778131496990090192116971737278476847268608490033770242429165130050051683233643503895170298939223345172201381280696501178440874519601212285993716231301711444846409038906449544400619869075485160263275052983491874078668088183385102283345085048608250393021332197155184306354550076682829493041377655279397517546139539846833936383047461199665385815384205685338621867252334028308711232827892125077126294632295639898989358211674562701021835646220134967151881909730381198004973407239610368540664319395097901906996395524530054505806855019567302292191393391856803449039820595510022635353619204199474553859381023439554495977837790237421617271117236434354394782218185286240851400666044332588856986705431547069657474585503323233421073015459405165537906866273337995851156257843229882737231989875714159578111963583300594087306812160287649628674460477464915995054973742562690104903778198683593814657412680492564879855614537234786733039046883834363465537949864192705638729317487233208376011230299113679386");
	strcat(Pi, cbuf0);
	strcpy(cbuf0, "270894387993620162951541337142489283072201269014754668476535761647737946752004907571555278196536213239264061601363581559074220202031872776052772190055614842555187925303435139844253223415762336106425063904975008656271095359194658975141310348227693062474353632569160781547818115284366795706110861533150445212747392454494542368288606134084148637767009612071512491404302725386076482363414334623518975766452164137679690314950191085759844239198629164219399490723623464684411739403265918404437805133389452574239950829659122850855582157250310712570126683024029295252201187267675622041542051618416348475651699981161410100299607838690929160302884002691041407928862150784245167090870006992821206604183718065355672525325675328612910424877618258297651579598470356222629348600341587229805349896502262917487882027342092222453398562647669149055628425039127577102840279980663658254889264880254566101729670266407655904290994568150652653053718294127033693137851786090407086671149655834343476933857817113864558736781230145876871266034891390956");
	strcat(Pi, cbuf0);
	strcpy(cbuf0, "200993936103102916161528813843790990423174733639480457593149314052976347574811935670911013775172100803155902485309066920376719220332290943346768514221447737939375170344366199104033751117354719185504644902636551281622882446257591633303910722538374218214088350865739177150968288747826569959957449066175834413752239709683408005355984917541738188399944697486762655165827658483588453142775687900290951702835297163445621296404352311760066510124120065975585127617858382920419748442360800719304576189323492292796501987518721272675079812554709589045563579212210333466974992356302549478024901141952123828153091140790738602515227429958180724716259166854513331239480494707911915326734302824418604142636395480004480026704962482017928964766975831832713142517029692348896276684403232609275249603579964692565049368183609003238092934595889706953653494060340216654437558900456328822505452556405644824651518754711962184439658253375438856909411303150952617937800297412076651479394259029896959469955657612186561967337862362561252163208628692221");
	strcat(Pi, cbuf0);
	strcpy(cbuf0, "032748892186543648022967807057656151446320469279068212073883778142335628236089632080682224680122482611771858963814091839036736722208883215137556003727983940041529700287830766709444745601345564172543709069793961225714298946715435784687886144458123145935719849225284716050492212424701412147805734551050080190869960330276347870810817545011930714122339086639383395294257869050764310063835198343893415961318543475464955697810382930971646514384070070736041123735998434522516105070270562352660127648483084076118301305279320542746286540360367453286510570658748822569815793678976697422057505968344086973502014102067235850200724522563265134105592401902742162484391403599895353945909440704691209140938700126456001623742880210927645793106579229552498872758461012648369998922569596881592056001016552563756785667227966198857827948488558343975187445455129656344348039664205579829368043522027709842942325330225763418070394769941597915945300697521482933665556615678736400536665641654732170439035213295435291694145990416087532018683793702348");
	strcat(Pi, cbuf0);

//	printf("First %d digits of Pi = %s\n", strlen(Pi), Pi);

	strcpy(cbuf0,"\0");
	for(i = 0; i < 10240; i++)
	{
		// If less than (primelen) digits remaining, quit:
		if(strlen(Pi+i) < primelen)
		{
			break;
		}

		strncpy(cbuf0, Pi+i, primelen);
		// Make sure surrent digit string ends after (primelen) digits:
		cbuf0[primelen] = '\0';
		p256 = convert_base10_char_uint256(cbuf0);
		/* Only test odds: */
		// Workaround for an MSVC compiler bug:
		//printf("p.d0 = %s\n", &cbuf1[convert_uint64_base10_char(cbuf1, p256.d0)]);
		tmp64 = p256.d0 & (uint64)0x0000000000000001ull;
		if(tmp64 == 0)
		{
			continue;
		}
		SUB256(p256,ONE256,q256);
		x256 = twopmodq256(q256,p256);
		if(CMPEQ256(x256,ONE256))
			printf("%s is a base-2 probable prime\n", cbuf0);
	}
#endif

#ifdef FACTOR_STANDALONE
	printf("Mfactor build flags:\n");

	/* TRYQ: */
	#ifndef TRYQ
		printf("TRYQ not defined\n");
		/* This flag is required: */
		ASSERT(HERE, 0,"defined(TRYQ)");
	#else
		i = TRYQ;
		printf("TRYQ = %u\n", i);
	#endif

	/* THREE_OP128: */
	#ifndef THREE_OP128
		printf("THREE_OP128 not defined\n");
	#elif(THREE_OP128 == 0)
		printf("THREE_OP128 = FALSE\n");
	#else
		i = THREE_OP128;
		printf("THREE_OP128 = %u\n", i);
		/* iF NONZERO, Must = 1 : */
		ASSERT(HERE, (THREE_OP128 == 1),"THREE_OP128 Must = 0 or 1!");
		/* Only relevant for TRYQ = 4 or 8: */
		#if(TRYQ != 4 && TRYQ != 8)
			#error	THREE_OP128 Only relevant for TRYQ = 4 or 8!
		#endif
		/* Only relevant for factoring up to 128 bits: */
		#if(defined(P3WORD) || defined(P4WORD))
			#error	THREE_OP128 Only relevant for factoring up to 128 bits!
		#endif
		/* Only relevant if using fully 128-bit modmul routines: */
		#if(defined(USE_128x96) && USE_128x96 != 0)
			#error	THREE_OP128 Only relevant if using fully 128-bit modmul routines - undef USE_128x96 or set = 0!
		#endif
	#endif

	/* NUM_SIEVING_PRIME: */
	#ifndef NUM_SIEVING_PRIME
		printf("NUM_SIEVING_PRIME not defined\n");
		/* This flag is required: */
		ASSERT(HERE, 0,"defined(NUM_SIEVING_PRIME)");
	#else
		i = NUM_SIEVING_PRIME;
		printf("NUM_SIEVING_PRIME = %u\n", i);
	#endif

	/* MUL_LOHI64_SUBROUTINE: */
	#ifndef MUL_LOHI64_SUBROUTINE
		printf("MUL_LOHI64_SUBROUTINE not defined\n");
	#else
		printf("MUL_LOHI64_SUBROUTINE = true\n");
	#endif

	/* MULH64_FAST: */
	#ifndef MULH64_FAST
		printf("MULH64_FAST not defined\n");
	#else
		printf("MULH64_FAST = true\n");
	#endif

	/* USE_FLOAT: */
	#ifndef USE_FLOAT
		printf("USE_FLOAT not defined\n");
	#else
		printf("USE_FLOAT = true\n");
	#endif

	/* USE_FMADD: */
	#ifndef USE_FMADD
		printf("USE_FMADD not defined\n");
	#else
		printf("USE_FMADD = true\n");
	#endif

	/* FACTOR_STANDALONE: */
	#ifndef FACTOR_STANDALONE
		printf("FACTOR_STANDALONE not defined\n");
	#else
		printf("FACTOR_STANDALONE = true\n");
	#endif

	/* FAC_DEBUG: */
	#if(!defined(FAC_DEBUG) || !FAC_DEBUG)
		printf("FAC_DEBUG = 0\n");
	#else
		printf("FAC_DEBUG = %u\n", (uint32)FAC_DEBUG);
	#endif

	/* DBG_SIEVE: */
	#ifndef DBG_SIEVE
		printf("DBG_SIEVE not defined\n");
	#else
		i = DBG_SIEVE;
		printf("DBG_SIEVE = true\n");
	#endif

	/* NOBRANCH: */
	#ifndef NOBRANCH
		printf("NOBRANCH not defined\n");
	#else
		printf("NOBRANCH = true\n");
	#endif

	/* QUIT_WHEN_FACTOR_FOUND: */
	#ifndef QUIT_WHEN_FACTOR_FOUND
		printf("QUIT_WHEN_FACTOR_FOUND not defined\n");
	#else
		printf("QUIT_WHEN_FACTOR_FOUND = true\n");
	#endif

	/* USE_65BIT: */
	#ifndef USE_65BIT
		printf("USE_65BIT not defined\n");
	#else
		printf("USE_65BIT = true\n");
	#endif

	/* USE_128x96: */
	#ifndef USE_128x96
		printf("USE_128x96 not defined\n");
	#else
		printf("USE_128x96 = true\n");
		/* Only relevant for factoring up to 128 bits: */
		#if(defined(P3WORD) || defined(P4WORD))
			#error	USE_128x96 Only relevant for factoring up to 128 bits!
		#endif
	#endif

	/* P2WORD: */
	#ifndef P2WORD
		printf("P2WORD not defined\n");
	#else
		printf("P2WORD = true\n");

		#ifndef USE_128x96
			printf("    USE_128x96 not defined\n");
		#else
			printf("    USE_128x96 = %u\n", USE_128x96);
		#endif

	#endif

	/* P3WORD: */
	#ifndef P3WORD
		printf("P3WORD not defined\n");
	#else
		printf("P3WORD = true\n");

		#ifndef PIPELINE_MUL192
			printf("    PIPELINE_MUL192 not defined\n");
		#else
			printf("    PIPELINE_MUL192 = %u\n", PIPELINE_MUL192);
		#endif

	#endif

	/* P4WORD: */
	#ifndef P4WORD
		printf("P4WORD not defined\n");
	#else
		printf("P4WORD = true\n");
	#endif
#endif

#ifdef FACTOR_STANDALONE
	printf("Mfactor self-tests:\n");
#endif

	// Basic tests of the mi64 vector-int package:
	j = 607;
	l = (j + 63)>>6;	// #64-bit words needed
	q     = (uint64 *)calloc(l, sizeof(uint64));
	q2    = (uint64 *)calloc(l, sizeof(uint64));
	mi64_nega(q,q,l);
	ASSERT(HERE, mi64_iszero(q,l), "mi64 -0 == 0 check fails!");
	q[0] = 1;	mi64_nega(q,q,l);
	mi64_add_scalar(q,1,q,l);
	ASSERT(HERE, mi64_iszero(q,l), "mi64 -1 + 1 == 0 check fails!");
	/* Init the RNG: */
	rng_isaac_init(TRUE);
	for(i = 0; i < l; i++)
	{
		q[i]  = rng_isaac_rand();
		q2[i] = q[i];
	}
	mi64_nega(q,q,l);
	mi64_negl(q2,q2,l);
	mi64_add_scalar(q2,1,q2,l);
	ASSERT(HERE, mi64_cmp_eq(q,q2,l), "mi64 -q == ~q+1 check fails!");
	free((void*)q);	free((void*)q2);
	q = q2 = 0x0;

	/* 06/18/2012: Test out new, streamlined version of mi64_mul_vector_hi_qmmp routine with
	Ex.: q = 2.k.M(127) + 1 with k = 7143819210136784550, i.e.
	q = 2430915709680614116949754105299803650411408301848040235701 ;
	y =  915005412744957807408012591600653057424688130286064771258 = y0 + 2^64*y1 + 2^128*y2,
	with y0 = 2294959606785646778; y1 = 10167084567166165345; y2 = 2688959234133783535 .
[Note that
2^192 = 6277101735386680763835789423207666416102355444464034512896 .
]
	Exact result:

		UMULH_192(q,y) = 354351598245602020483095922210514413558224553895064094733 = u0 + 2^64*u1 + 2^128*u2,
		with u0 = 141525868296128525, u1 = 4269430960237156763, u2 = 1041345754856384950 .
	*/
	k = 7143819210136784550;	p64 = 127;
	p192.d0 = 2294959606785646778ull; p192.d1 = 10167084567166165345ull; p192.d2 = 2688959234133783535ull;
	mi64_mul_vector_hi_qmmp((uint64*)&p192, p64, k, (uint64*)&q192, 192);
	ASSERT(HERE, q192.d0 == 141525868296128525ull && q192.d1 == 4269430960237156763ull && q192.d2 == 1041345754856384950ull, "mi64_mul_vector_hi_qmmp test fails!");

	/* 01/09/2008: mi64_div bug debug: */
	p = convert_base10_char_mi64("531137992816767098689588206552468627329593117727031923199444138200403559860852242739162502265229285668889329486246501015346579337652707239409519978766587351943831270835393219031728127", &i);
	two_p = (uint64 *)calloc(i, sizeof(uint64));
	mi64_add(p,p,two_p,i);
	q = convert_base10_char_mi64("4969289881134175801642878989330437804491760137935869781219375395913301677808943323410612629818326630668131744420258226244511522022525093242408710254941677603671849301746980479735516135243111", &j);
	ASSERT(HERE, i==j,"0");
	q2      = (uint64 *)calloc(i, sizeof(uint64));
	u64_arr = (uint64 *)calloc(i, sizeof(uint64));
	mi64_div(q,two_p,i,i,q2,u64_arr);
	ASSERT(HERE, mi64_getlen(q2, i) == 1 , "k must be 64-bit!");
	if(!mi64_cmp_eq_scalar(u64_arr, 1ull, i))
	{
		fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",
					&cbuf0[convert_mi64_base10_char(cbuf0,p,i)],
					&cbuf1[convert_mi64_base10_char(cbuf1, q, i)],
					&cbuf2[convert_mi64_base10_char(cbuf2, u64_arr, i)]);
		ASSERT(HERE, 0,"0");
	}
	else
	{
		fprintf(stderr,"mi64_div quicktest passes.\n");
	}
	free((void*)p); free((void*)q); free((void*)q2); free((void*)two_p); free((void*)u64_arr);
	p = 0x0; q = 0x0; q2 = 0x0; two_p = 0x0; u64_arr = 0x0;

	// 4/19/2012: mi64 gives bad result for e.g. the following M607 printout when built optimized in GCC...after adding
	// this test code, however, even the opt-build passes - weird:
	j = convert_base10_char_uint64("607");
	i = (j + 63)>>6;	// #64-bit words needed
	p     = (uint64 *)calloc(i, sizeof(uint64));
	q     = (uint64 *)calloc(i, sizeof(uint64));

	p[0] = 1;	mi64_shl(p,p,j,i);	// 2^607
	mi64_sub_scalar(p,1,p,i);	// p = 2^607 - 1;
	convert_mi64_base10_char(cbuf0, p, i);
	ASSERT(HERE, STREQ(cbuf0, "531137992816767098689588206552468627329593117727031923199444138200403559860852242739162502265229285668889329486246501015346579337652707239409519978766587351943831270835393219031728127"), "MM607 string-conversion test failed!");
	mi64_set_eq    (q, p, i);
	mi64_sub_scalar(q ,1ull,q ,i);	// q = p-1
	ASSERT(HERE, mi64_twopmodq(q, i, 0, p, i, 0x0) == 1, "M607 base-2 PRP test failed!");
	free((void*)p);	free((void*)q);
	p = q = 0x0;

	/* 4/20/2012: Did a test TF run of mm607 to k = 3e7, printing debug data about sample factor candidates
	for every [2^14]th q which passes the first-10000-small-primes sieve (primes <= 104743). All 96 such
	sample-q are flagged by my mi64 modpow routine as composite (via base-2 Fermat PRP test). Rechecked
	using Pari/GP to both test for small factors (none showed any factors < sievelimit, but increasing the
	the sieving depth to 2^32 factors 50 of the 96 candidates) ... more importantly Pari indicates one of the
	96 candidates, with k = 28115877, is in fact prime. That warrants getting added to the self-test suite:
	*/
	j = 607;
	i = (j + 63)>>6;	// #64-bit words needed
	q     = (uint64 *)calloc(i, sizeof(uint64));
	q2    = (uint64 *)calloc(i, sizeof(uint64));
	q[0] = 1;	mi64_shl(q,q,j,i);	// 2^607
	mi64_sub_scalar(q,1,q,i);		// p = 2^607 - 1;
	// Mul by any scalar < 2^33 should have no carry out of the 10th 64-bit word
	ASSERT(HERE, 0 == mi64_mul_scalar(q,2*28115877,q,i), "2.k.M607 (k = 28115877) illegal carryout on scalar-mul!");
	mi64_set_eq    (q2, q, i);		// q2 = q-1
	mi64_add_scalar(q ,1ull,q ,i);	// q = 2.k.p + 1
	convert_mi64_base10_char(cbuf0, q, i);
	ASSERT(HERE, STREQ(cbuf0, "29866820952126214568806646392159603944715357116119498255498035716027095678819717544056871993402815945328710228895559628455719074056369970920495232704087963394016941839123205985860254232344759"), "q = 2.k.M607+1 (k = 28115877) string-conversion test failed!");
	ASSERT(HERE, mi64_twopmodq(q2, i, 0, q, i, 0x0) == 1, "q = 2.k.M607+1 (k = 28115877) base-2 PRP test failed!");
	free((void*)q);	free((void*)q2);
	q = q2 = 0x0;

	/* Test fast MM(p)-factor-candidate-specific hi-mul algorithm.
	NB: p = 1231 not an M-prime exponent, but 1279 too close to 1280 = 64*20 for our purposes.
	*/
	// 2nd multiplicand is just leading digits of Pi, sans decimal point:
	q2 = convert_base10_char_mi64("3141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724587006606315588174881520920962829254091715364367892590360011330530548820466521", &j);
	ASSERT(HERE, j == 20, "vector lengths should be 20!");
	q     = (uint64 *)calloc(j, sizeof(uint64));	// output array
	mi64_mul_vector_hi_qmmp(q2, 1231, 60773088284, q, (j<<6));	// q = 2.k.M(p) + 1 with k = 60773088284
	convert_mi64_base10_char(cbuf0, q, j);
	ASSERT(HERE, STREQ(cbuf0, "678299328487875406787553667584424766193319571425229812042632483796223090743976740829512533956144441574815272835626612961160454952708658437402700559999225654073147100413573556498251710301510338504761109128343850675314104893353603303495634850631971760134667616782442458276408663375682004856646999060481786800862572039635523841600325205075025327991817191734342347965082117753555537"), "mi64_mul_vector_hi_qmmp test failed!");
	free((void*)q);	free((void*)q2);
	q = q2 = 0x0;

	/* 7/21/2005 bugfix test: */
	q192.d2=506560280167ull; q192.d1=18446744073709551615ull; q192.d0=18446743060588991281ull;
	p192 = q192; p192.d0 -= 1;
	x192 = twopmodq192(p192,q192);
	ASSERT(HERE, CMPEQ192(x192, ONE192),"Bad twopmodq192 output");

	/* 12/23/2008: Use this to help debug the mi64 powering routine: */
	ASSERT(HERE, mi64_twopmodq(&p192.d0, 3, 0, &q192.d0, 3, 0x0), "mi64_twopmodq != 1");

	/* 1/23/2004 bugfix test (cf. def. of MULH192 in imul_macro.h for details):

	X =                   14*2^128 +  3291757557782450881*2^64 +  3893270457587058239;
	Y = 14334090244500356821*2^128 + 14839649155872891980*2^64 + 12743646208794279936;
	! and w3 = 2846153632803221901, rather than the true w2 = 0 and w3 = 2846153632803221902.
	!
	! However, this kind of thing is only likely to happen in the one q*(qinv << shift) multiply
	! that we do just prior to entering the modmul-based powering loop. So we could define two
	! versions of the MULH routine: an exact one which will be used only for the initial mul,
	! and one which approximates the (presumably quasirandom) lower bits of the mul so as to get
	! the proper carry into the upper half with very high probability, which we use everywhere else.
	! ****TODO???****

	*/
	p192.d2=                  14ull; p192.d1= 3291757557782450881ull; p192.d0= 3893270457587058239ull;
	q192.d2=14334090244500356821ull; q192.d1=14839649155872891980ull; q192.d0=12743646208794279936ull;
	MULH192(p192,q192,x192);
	MULH192_TRUNC(p192,q192,0ull,y192);	// Expected value of 64-bit carry layer at top of low-half product = 0
	/* Reference value to compare to: */
	q192.d2=                  11ull; q192.d1=  320947345442520101ull; q192.d0= 2846153632803221902ull;
	ASSERT(HERE, CMPEQ192(x192, q192),"MULH192       fails!");
	ASSERT(HERE, CMPEQ192(y192, q192),"MULH192_TRUNC fails!");

	/* Count the # of test q's of the various sizes: */
	for(ntest63    = 0; fac63   [ntest63   ].p          != 0; ++ntest63   ){}
	for(ntest64    = 0; fac64   [ntest64   ].p          != 0; ++ntest64   ){}
	for(ntest65    = 0; fac65   [ntest65   ].p          != 0; ++ntest65   ){}
	for(ntest96    = 0; fac96   [ntest96   ].p          != 0; ++ntest96   ){}
	for(ntest128   = 0; fac128  [ntest128  ].p          != 0; ++ntest128  ){}
	for(ntest128x2 = 0; fac128x2[ntest128x2].plo        != 0; ++ntest128x2){}
	for(ntest160   = 0; fac160  [ntest160  ].p          != 0; ++ntest160  ){}
	for(ntest192   = 0; fac192  [ntest192  ].p          != 0; ++ntest192  ){}
	for(ntest256   = 0; STRNEQ(fac256[ntest256].p, "")		; ++ntest256  ){}

	/* Test 63-bit factors using the 63, 64 and 96-bit modmul routines */
#ifdef FACTOR_STANDALONE
	printf("Testing 63-bit factors...\n");
#endif
	for(i = 0; fac63[i].p != 0; i++)
	{
		p64 = fac63[i].p; q64 = fac63[i].q;
		/* Make sure the MSB = 0: */
		ASSERT(HERE, ( int64)p64 > 0, "test_fac : ( int64)p64 > 0");
		ASSERT(HERE, q64%(2*p64) ==1, "test_fac : q64%(2*p64) ==1");

		k = (q64-1)/(2*p64);
		pm60 = p64%60;
		km60 = k  %60;
		/* Since we know q%60 != 0, use the zero column to store the total count of q's for each p%60 value */
		++pqmod60arr[pm60][0];
		++pqmod60arr[pm60][q64%60];

		/* This property only applies for prime exponents, so use a quick base-2 Fermat
		compositeness test as an exponent filter: */
		if(twopmodq64(p64-1, p64) == 1ull && !CHECK_PKMOD60(pm60, km60))
		{
			fprintf(stderr,"Illegal (p,k) mod 60 pair: p,p mod 60, k,k mod 60 = %llu %4u %llu %4u\n",p64,pm60,k,km60);
			ASSERT(HERE, 0,"0");
		}

		if((res64 = twopmodq63(p64, q64)) != 1ull)
		{
			fprintf(stderr,"ERROR: twopmodq63(%llu, k = %llu) returns non-unity result %u\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
		if((res64 = twopmodq64(p64, q64)) != 1ull)
		{
			fprintf(stderr,"ERROR: twopmodq64(%llu, k = %llu) returns non-unity result %u\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}

	#ifdef USE_FLOAT
		k = (q64-1)/(2*p64);
		res64 = twopmodq78_3WORD_DOUBLE(&sum1, &sum2, p64, k);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE(%llu, k = %llu) returns non-unity result %u\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}

		p192.d0 = p64; p192.d1 = p192.d2 = 0;
		x256 = twopmodq200_8WORD_DOUBLE(&sum1, &sum2, (uint64*)&p192, k);	res64 = !x256.d3 && (uint64)CMPEQ192(x256, ONE192);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq200_8WORD_DOUBLE(%llu, k = %llu) returns non-unity result %u\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif

		res96 = twopmodq96(&sum1, &sum2, p64, k);
		if(!CMPEQ96(ONE96,res96))
		{
			fprintf(stderr,"ERROR: twopmodq96(%llu, k = %llu) returns non-unity result %s\n",p64,k,
					&cbuf2[convert_uint96_base10_char(cbuf2, res96)]);
			ASSERT(HERE, 0,"0");
		}

		res64 = twopmodq128_96(&sum1, &sum2, p64, k);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq128_96(%llu, k = %llu) returns non-unity result %u\n",p64,k, (uint32)res64);
		}

	#ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE(p64, k);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE(%llu, k = %llu) returns non-unity result %u\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif

		/* Also test the multiple-q versions of the modular exponentiation routines: */
	#if(TRYQ == 2)
	  #ifdef USE_FLOAT
		res64 = twopmodq78_3WORD_DOUBLE_q2(&sum1, &sum2, p64,k,k);
		if(res64 != 3)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q2( %llu, k = %llu x 2 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
	  #ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE_q2(&sum1, &sum2, p64,k,k);
		if(res64 != 3)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE_q2( %llu, k = %llu x 2 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
	#elif(TRYQ == 4)
		res64 = twopmodq63_q4(&sum1, &sum2, p64,k,k,k,k);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq63_q4( %llu, k = %llu x 4 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #ifdef USE_FLOAT
		res64 = twopmodq78_3WORD_DOUBLE_q4(&sum1, &sum2, p64, k,k,k,k);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q4( %llu, k = %llu x 4 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
	  #ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE_q4(p64,k,k,k,k);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE_q4( %llu, k = %llu x 4 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif

		res64 = twopmodq96_q4(&sum1, &sum2, p64,k,k,k,k);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq96_q4( %llu, k = %llu x 4 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
		res64 = twopmodq128_96_q4(&sum1, &sum2, p64,k,k,k,k);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq128_96_q4( %llu, k = %llu x 4 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#elif(TRYQ == 8)
		res64 = twopmodq63_q8(&sum1, &sum2, p64,k,k,k,k,k,k,k,k);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq63_q8( %llu, k = %llu x 8 ) failed to find factor, res = 0x%2X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #if defined(USE_FLOAT) && defined(COMPILER_TYPE_GCC) && (OS_BITS == 64)
		res64 = twopmodq78_3WORD_DOUBLE_q8(&sum1, &sum2, p64, k,k,k,k,k,k,k,k);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q8( %llu, k = %llu x 8 ) failed to find factor, res = 0x%2X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
		res64 = twopmodq96_q8(&sum1, &sum2, p64,k,k,k,k,k,k,k,k);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq96_q8( %llu, k = %llu x 8 ) failed to find factor, res = 0x%2X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
		res64 = twopmodq128_96_q8(&sum1, &sum2, p64,k,k,k,k,k,k,k,k);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq128_96_q8( %llu, k = %llu x 8 ) failed to find factor, res = 0x%2X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif
	}

	/* Test 64-bit factors using the 64 and 96-bit modmul routines */
#ifdef FACTOR_STANDALONE
	printf("Testing 64-bit factors...\n");
#endif
	for(i = 0; fac64[i].p != 0; i++)
	{
		p64 = fac64[i].p; q64 = fac64[i].q;

		ASSERT(HERE, q64%(2*p64)==1, "test_fac : q64%(2*p64)==1");

		k = (q64-1)/(2*p64);
		pm60 = p64%60;
		km60 = k  %60;
		/* Since we know q%60 != 0, use the zero column to store the total count of q's for each p%60 value */
		++pqmod60arr[pm60][0];
		++pqmod60arr[pm60][q64%60];

		/* This property only applies for prime exponents, so use a quick base-2 Fermat
		compositeness test as an exponent filter: */
		if(twopmodq64(p64-1, p64) == 1ull && !CHECK_PKMOD60(pm60, km60))
		{
			fprintf(stderr,"Illegal (p,k) mod 60 pair: p,p mod 60, k,k mod 60 = %llu %4u %llu %4u\n",p64,pm60,k,km60);
			ASSERT(HERE, 0,"0");
		}

		if(q64%(2*p64) != 1)
		{
			fprintf(stderr,"ERROR : (p, q) = ( %llu, %llu ) : q mod (2p) = %llu != 1!\n",p64,q64, q64%(2*p64));
			ASSERT(HERE, 0,"0");
		}

		if((res64 = twopmodq64(p64, q64)) != 1ull)
		{
			fprintf(stderr,"ERROR: twopmodq64(%llu, k = %llu) returns non-unity result %u\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}

	#ifdef USE_FLOAT
		k = (q64-1)/(2*p64);
		res64 = twopmodq78_3WORD_DOUBLE(&sum1, &sum2, p64, k);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE(%llu, k = %llu) returns non-unity result %u\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif

		res96 = twopmodq96(&sum1, &sum2, p64, k);
		if(!CMPEQ96(ONE96,res96))
		{
			fprintf(stderr,"ERROR: twopmodq96(%llu, k = %llu) returns non-unity result %s\n",p64,k,
					&cbuf2[convert_uint96_base10_char(cbuf2, res96)]);
			ASSERT(HERE, 0,"0");
		}

		res64 = twopmodq128_96(&sum1, &sum2, p64,k);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq128_96(%llu, k = %llu) returns non-unity result %u\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}

	#ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE(&sum1, &sum2, p64,k);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE(%llu, %llu) returns non-unity result %u\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}

	#endif

		/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
	#if(TRYQ == 2)
	  #ifdef USE_FLOAT
		res64 = twopmodq78_3WORD_DOUBLE_q2(&sum1, &sum2, p64, k,k);
		if(res64 != 3)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q2( %llu, k = %llu x 2 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
	  #ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE_q2(&sum1, &sum2, p64, k,k);
		if(res64 != 3)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE_q2( %llu, %llu x 2 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
	#elif(TRYQ == 4)
		res64 = twopmodq64_q4(&sum1, &sum2, p64,k,k,k,k);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq64_q4( %llu, %llu x 4 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #ifdef USE_FLOAT
		res64 = twopmodq78_3WORD_DOUBLE_q4(&sum1, &sum2, p64, k,k,k,k);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q4( %llu, %llu x 4 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
	  #ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE_q4(&sum1, &sum2, p64,k,k,k,k);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE_q4( %llu, %llu x 4 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
		res64 = twopmodq96_q4(&sum1, &sum2, p64,k,k,k,k);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq96_q4( %llu, %llu x 4 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
		res64 = twopmodq128_96_q4(&sum1, &sum2, p64,k,k,k,k);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq128_96_q4( %llu, %llu x 4 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#elif(TRYQ == 8)
		res64 = twopmodq64_q8(&sum1, &sum2, p64,k,k,k,k,k,k,k,k);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq64_q8( %llu, %llu x 8 ) failed to find factor, res = 0x%2X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #if defined(USE_FLOAT) && defined(COMPILER_TYPE_GCC) && (OS_BITS == 64)
		res64 = twopmodq78_3WORD_DOUBLE_q8(&sum1, &sum2, p64, k,k,k,k,k,k,k,k);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q8( %llu, %llu x 4 ) failed to find factor, res = 0x%2X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
		res64 = twopmodq96_q8(&sum1, &sum2, p64,k,k,k,k,k,k,k,k);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq96_q8( %llu, %llu x 8 ) failed to find factor, res = 0x%2X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
		res64 = twopmodq128_96_q8(&sum1, &sum2, p64,k,k,k,k,k,k,k,k);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq128_96_q8( %llu, %llu x 8 ) failed to find factor, res = 0x%2X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif
	}

	/* Test 65-bit factors using the 65 and 96-bit modmul routines */
#ifdef FACTOR_STANDALONE
	printf("Testing 65-bit factors...\n");
#endif
	for(i = 0; fac65[i].p != 0; i++)
	{
		p64 = fac65[i].p; q64 = fac65[i].q;
		q128.d1 = (uint64)1; q128.d0 = q64;

		/* Modify this so it'll work with 65-bit q's: */
		ASSERT(HERE, ((q64-1)/2 + 0x8000000000000000ull)%p64==0, "test_fac : ((q64-1)/2 + 0x8000000000000000ull)%p64==0");

		k = ((q64-1)/2 + 0x8000000000000000ull)/p64;
		pm60 = p64%60;
		km60 = k  %60;

		/* This property only applies for prime exponents, so use a quick base-2 Fermat
		compositeness test as an exponent filter: */
		if(twopmodq64(p64-1, p64) == 1ull && !CHECK_PKMOD60(pm60, km60))
		{
			fprintf(stderr,"Illegal (p,k) mod 60 pair: p,p mod 60, k,k mod 60 = %llu %4u %llu %4u\n",p64,pm60,k,km60);
			ASSERT(HERE, 0,"0");
		}
		if((res64 = twopmodq65(&sum1, &sum2, p64,k)) != 1)
		{
			fprintf(stderr,"ERROR: twopmodq65(%llu, %llu) returns non-unity result %u\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}

	#ifdef USE_FLOAT
		res64 = twopmodq78_3WORD_DOUBLE(&sum1, &sum2, p64, k);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE(%llu, %llu) returns non-unity result %u\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif

		res96 = twopmodq96(&sum1, &sum2, p64, k);
		if(!CMPEQ96(ONE96,res96))
		{
			fprintf(stderr,"ERROR: twopmodq96(%llu, k = %llu) returns non-unity result %s\n",p64,k,
					&cbuf2[convert_uint96_base10_char(cbuf2, res96)]);
			ASSERT(HERE, 0,"0");
		}

		res64 = twopmodq128_96(&sum1, &sum2, p64,k);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq128_96(%llu, %llu) returns non-unity result %u\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}

	#ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE(&sum1, &sum2, p64, k);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE(%llu, %llu) returns non-unity result %u\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif

		/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
	#if(TRYQ == 2)
	  #ifdef USE_FLOAT
		res64 = twopmodq78_3WORD_DOUBLE_q2(&sum1, &sum2, p64, k,k);
		if(res64 != 3)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q2( %llu, %llu x 2 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
	  #ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE_q2(&sum1, &sum2, p64, k,k);
		if(res64 != 3)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE_q2( %llu, %llu x 2 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
	#elif(TRYQ == 4)
		res64 = twopmodq65_q4(&sum1, &sum2, p64,k,k,k,k);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq65_q4( %llu, %llu x 4 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #ifdef USE_FLOAT
		res64 = twopmodq78_3WORD_DOUBLE_q4(&sum1, &sum2, p64, k,k,k,k);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q4( %llu, %llu x 4 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
	  #ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE_q4(&sum1, &sum2, p64,k,k,k,k);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE_q4( %llu, %llu x 4 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
		res64 = twopmodq96_q4(&sum1, &sum2, p64,k,k,k,k);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq96_q4( %llu, %llu x 4 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
		res64 = twopmodq128_96_q4(&sum1, &sum2, p64,k,k,k,k);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq128_96_q4( %llu, %llu x 4 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#elif(TRYQ == 8)
		res64 = twopmodq65_q8(&sum1, &sum2, p64,k,k,k,k,k,k,k,k);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq65_q8( %llu, %llu x 8 ) failed to find factor, res = 0x%2X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #if defined(USE_FLOAT) && defined(COMPILER_TYPE_GCC) && (OS_BITS == 64)
		res64 = twopmodq78_3WORD_DOUBLE_q8(&sum1, &sum2, p64, k,k,k,k,k,k,k,k);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q8( %llu, %llu x 4 ) failed to find factor, res = 0x%2X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif
		res64 = twopmodq96_q8(&sum1, &sum2, p64,k,k,k,k,k,k,k,k);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq96_q8( %llu, %llu x 8 ) failed to find factor, res = 0x%2X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
		res64 = twopmodq128_96_q8(&sum1, &sum2, p64,k,k,k,k,k,k,k,k);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq128_96_q8( %llu, %llu x 8 ) failed to find factor, res = 0x%2X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif
	}

	/* Test 96-bit factors using the 96 and 128-bit modmul routines */
#ifdef FACTOR_STANDALONE
	printf("Testing 96-bit factors...\n");
#endif
	for(i = 0; fac96[i].p != 0; i++)
	{
		p64 = fac96[i].p;
		q128.d1 = (uint64)fac96[i].d1; q128.d0 = fac96[i].d0;

		/* Modify this so it'll work with 96-bit q's: */
		two64modp = 0x8000000000000000ull%p64;
		two64modp = (two64modp + two64modp)%p64;
		res64 = (q128.d1*two64modp + q128.d0%p64)%p64;
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",
					&cbuf0[convert_uint64_base10_char (cbuf0, p64)],
					&cbuf1[convert_uint128_base10_char(cbuf1, q128)],
					&cbuf2[convert_uint64_base10_char (cbuf2, res64)]);
			ASSERT(HERE, 0,"0");
		}

		/* To find the quotient k = (q-1)/(2*p), which may be > 64 bits, use mod-inverse with base 2^128 arithmetic.
		Since the Newtonian mod-inverse algorithm only works for odd inputs, instead of finding (q-1)/(2*p), we find ((q-1)/2)/p.
		First, find inverse (mod 2^128) of p in preparation for modular multiply. See twopmodq128 for an explanation of this:
		*/
		pinv128.d0 = (p64 + p64 + p64) ^ (uint64)2;	pinv128.d1 = (uint64)0;
		for(j = 0; j < 4; j++)
		{
			hi64 = p64*pinv128.d0;
			pinv128.d0 = pinv128.d0*((uint64)2 - hi64);
		}
		/* pinv128 has 128 bits, but only the upper 64 get modified here. */
	#ifdef MUL_LOHI64_SUBROUTINE
		pinv128.d1 = -pinv128.d0*__MULH64(p64, pinv128.d0);
	#else
		MULH64(p64, pinv128.d0, hi64);
		pinv128.d1 = -pinv128.d0*hi64;
	#endif
		/* k is simply the bottom 128 bits of ((q-1)/2)*pinv128: */
		x128.d0	= ((q128.d0-1) >> 1) + (q128.d1 << 63);	x128.d1	= (q128.d1 >> 1);	/* (q-1)/2. */
		MULL128(x128, pinv128, x128);
	#if 0
		fprintf(stderr,"(p, q) = ( %s, %s ) : k = %s\n",
					&cbuf0[convert_uint64_base10_char (cbuf0, p64)],
					&cbuf1[convert_uint128_base10_char(cbuf1, q128)],
					&cbuf2[convert_uint128_base10_char(cbuf2, x128)]);
	#endif
		pm60 = p64%60;
		km60 = (x128.d1*two64mod60 + x128.d0%60)%60;

		/* This property only applies for prime exponents, so use a quick base-2 Fermat
		compositeness test as an exponent filter: */
		if(twopmodq64(p64-1, p64) == 1ull && !CHECK_PKMOD60(pm60, km60))
		{
			fprintf(stderr,"Illegal (p,k) mod 60 pair: p,p mod 60, k,k mod 60 = %llu %4u %s %4u\n",p64,pm60,
					&cbuf1[convert_uint128_base10_char(cbuf1, x128)],km60);
			ASSERT(HERE, 0,"0");
		}

	/* Here use full 96-bit q in both floating and 96-bit modmul, so compute for both: */
		q96.d1 = (uint64)fac96[i].d1; q96.d0 = fac96[i].d0;
		/* For twopmodq*() versions taking p and k-args, need to ensure high 64 bits of k (stored in x128.d1) zero: */
		k = x128.d0;
	#ifdef USE_FLOAT
	  if((q96.d1 >> 14) == 0)
	  {
		/* Integer-truncation-on-store should obviate the need to subtract 1 from q, and (double)q is only accurate to 53 bits to begin with): */
		ASSERT(HERE, x128.d1 == 0, "High half of exactly-computed k nonzero!");
		dbl = (double)q96.d0 + (double)q96.d1*TWO64FLOAT;
		dbl /= (2.0*p64);
		rnd = DNINT(dbl);
		k = (uint64)rnd;
		ASSERT(HERE, x128.d0 == k, "Approx and exactly-computed k differ!");
		res64 = twopmodq78_3WORD_DOUBLE(&sum1, &sum2, p64, k);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE(%llu, %llu) returns non-unity result %u\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  }
	#endif
	if(x128.d1 == 0) {	// x128 holds k
		res96 = twopmodq96(&sum1, &sum2, p64, k);
		if(!CMPEQ96(ONE96,res96))
		{
			fprintf(stderr,"ERROR: twopmodq96(%llu, k = %llu) returns non-unity result %s\n",p64,k,
					&cbuf2[convert_uint96_base10_char(cbuf2, res96)]);
			ASSERT(HERE, 0,"0");
		}

		res64 = twopmodq128_96(&sum1, &sum2, p64, k);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq128_96(%llu, %llu ) returns non-unity result %u\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	}
		p128.d0 = p64; p128.d1 = 0;
		res128 = twopmodq128(p128, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR: twopmodq128(%s, %s ) returns non-unity result %s\n",
					&cbuf0[convert_uint64_base10_char (cbuf0, p64)],
					&cbuf1[convert_uint128_base10_char(cbuf1, q128)],
					&cbuf2[convert_uint128_base10_char(cbuf2, res128)]);
			ASSERT(HERE, 0,"0");
		}

	if(x128.d1 == 0) {
		res64 = twopmodq128x2(&sum1, &sum2, (uint64 *)&p128, k);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq128x2(%llu, %llu ) returns non-unity result %u\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	}

	#ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE(p64, q128);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE(%llu, %llu) returns non-unity result %u\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif

		/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
	#if(TRYQ == 2)
	  #ifdef USE_FLOAT
		if((q96.d1 >> 14) == 0 && (x128.d1 == 0))
		{
			res64 = twopmodq78_3WORD_DOUBLE_q2(&sum1, &sum2, p64, k,k);
			if(res64 != 3)
			{
				fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q2( %llu, %llu x 2 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
				ASSERT(HERE, 0,"0");
			}
		}
	  #endif
	  #ifdef USE_FMADD
		/* Test any FMADD-based modmul routines, if def'd: */
		res64 = twopmodq100_2WORD_DOUBLE_q2(p64, k,k);
		if(res64 != 3)
		{
			fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE_q2( %llu, %llu x 2 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  #endif

	#elif(TRYQ == 4)

		if(x128.d1 == 0)	// k must be 64-bit
		{
		#ifdef USE_FLOAT
			if((q96.d1 >> 14) == 0)
			{
				res64 = twopmodq78_3WORD_DOUBLE_q4(&sum1, &sum2, p64, k,k,k,k);
				if(res64 != 15)
				{
					fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q4( %llu, %llu x 4 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
					ASSERT(HERE, 0,"0");
				}
			}
		#endif
		#ifdef USE_FMADD
			/* Test any FMADD-based modmul routines, if def'd: */
			res64 = twopmodq100_2WORD_DOUBLE_q4(p64,k,k,k,k);
			if(res64 != 15)
			{
				fprintf(stderr,"ERROR: twopmodq100_2WORD_DOUBLE_q4( %llu, %llu x 4 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
				ASSERT(HERE, 0,"0");
			}
		#endif
			res64 = twopmodq96_q4(&sum1, &sum2, p64,k,k,k,k);
			if(res64 != 15)
			{
				fprintf(stderr,"ERROR: twopmodq96_q4( %llu, %llu x 4 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
				ASSERT(HERE, 0,"0");
			}
			res64 = twopmodq128_96_q4(&sum1, &sum2, p64,k,k,k,k);
			if(res64 != 15)
			{
				fprintf(stderr,"ERROR: twopmodq128_96_q4( %llu, %llu x 4 ) failed to find factor, res = 0x%1X.\n",p64,k, (uint32)res64);
				ASSERT(HERE, 0,"0");
			}
		}	// k must be 64-bit

	#elif(TRYQ == 8)

		if(x128.d1 == 0)	// k must be 64-bit
		{
		#if defined(USE_FLOAT) && defined(COMPILER_TYPE_GCC) && (OS_BITS == 64)
			if((q96.d1 >> 14) == 0)
			{
				res64 = twopmodq78_3WORD_DOUBLE_q8(&sum1, &sum2, p64, k,k,k,k,k,k,k,k);
				if(res64 != 255)
				{
					fprintf(stderr,"ERROR: twopmodq78_3WORD_DOUBLE_q8( %llu, %llu x 4 ) failed to find factor, res = 0x%2X.\n",p64,k, (uint32)res64);
					ASSERT(HERE, 0,"0");
				}
			}
		#endif
			res64 = twopmodq96_q8(&sum1, &sum2, p64,k,k,k,k,k,k,k,k);
			if(res64 != 255)
			{
				fprintf(stderr,"ERROR: twopmodq96_q8( %llu, %llu x 8 ) failed to find factor, res = 0x%2X.\n",p64,k, (uint32)res64);
				ASSERT(HERE, 0,"0");
			}
			res64 = twopmodq128_96_q8(&sum1, &sum2, p64,k,k,k,k,k,k,k,k);
			if(res64 != 255)
			{
				fprintf(stderr,"ERROR: twopmodq128_96_q8( %llu, %llu x 8 ) failed to find factor, res = 0x%2X.\n",p64,k, (uint32)res64);
				ASSERT(HERE, 0,"0");
			}
			res64 = twopmodq128_q8(&sum1, &sum2, (uint64 *)&p128,k,k,k,k,k,k,k,k);
			if(res64 != 255)
			{
				fprintf(stderr,"ERROR: twopmodq128_q8( %s, %s x 8 ) failed to find factor, res = 0x%1X.\n",
					&cbuf0[convert_uint128_base10_char(cbuf0,p128)],
					&cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
				ASSERT(HERE, 0,"0");
			}
		}	// k must be 64-bit

	#endif	// TRYQ
	}

#if(defined(P2WORD) || defined(P3WORD) || defined(P4WORD))

	/* Test 128-bit factors using the 128-bit modmul routines. */
  #ifdef FACTOR_STANDALONE
	printf("Testing 128-bit factors...\n");
  #endif
	/* 128_A: Factors > 96 but <= 128 bits. */
	for(i = 0; fac128[i].p != 0; i++)
	{
/* Comment out the left-justified continue's below to enable factor reconstruction code. */
		p64 = fac128[i].p;
		q128.d1 = fac128[i].d1; q128.d0 = fac128[i].d0;

		/* Modify this so it'll work with 128-bit q's: */
		two64modp = 0x8000000000000000ull%p64;
		two64modp = (two64modp + two64modp)%p64;
		/* Really large factors may have high part sufficiently large that q128.d1*two64modp
		overflows 64 bits, so stick an extra mod-p in there:
		*/
		res64 = ((q128.d1%p64)*two64modp + q128.d0%p64)%p64;
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",
					&cbuf0[convert_uint64_base10_char (cbuf0, p64)],
					&cbuf1[convert_uint128_base10_char(cbuf1, q128)],
					&cbuf2[convert_uint64_base10_char (cbuf2, res64)]);
			ASSERT(HERE, 0,"0");
		}

		/* This uses the generic 128-bit mod function to calculate q%(2*p): */
		p128.d0 = p64; p128.d1 = 0;
		ADD128(p128, p128, two_p128);
		x128 = xmody128(q128, two_p128);
		if(!CMPEQ128(x128, ONE128))
		{
			fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",
					&cbuf0[convert_uint128_base10_char(cbuf0, p128)],
					&cbuf1[convert_uint128_base10_char(cbuf1, q128)],
					&cbuf2[convert_uint128_base10_char(cbuf2, x128)]);
			ASSERT(HERE, 0,"0");
		}

		/* To find the quotient k = (q-1)/(2*p), which may be > 64 bits, use mod-inverse with base 2^128 arithmetic.
		Since the Newtonian mod-inverse algorithm only works for odd inputs, instead of finding (q-1)/(2*p), we find ((q-1)/2)/p.
		First, find inverse (mod 2^128) of p in preparation for modularmultiply. See twopmodq128 for an explanation of this:
		*/
		pinv128.d0 = (p64 + p64 + p64) ^ (uint64)2;  pinv128.d1 = (uint64)0;
		for(j = 0; j < 4; j++)
		{
			hi64 = p64*pinv128.d0;
			pinv128.d0 = pinv128.d0*((uint64)2 - hi64);
		}
		/* pinv128 has 128 bits, but only the upper 64 get modified here. */
		#ifdef MUL_LOHI64_SUBROUTINE
			pinv128.d1 = -pinv128.d0*__MULH64(p64, pinv128.d0);
		#else
			MULH64(p64, pinv128.d0, hi64);
			pinv128.d1 = -pinv128.d0*hi64;
		#endif
		/* k is simply the bottom 128 bits of ((q-1)/2)*pinv128: */
		x128.d0 = ((q128.d0-1) >> 1) + (q128.d1 << 63); x128.d1 = (q128.d1 >> 1);       /* (q-1)/2. */
		MULL128(x128, pinv128, x128);
		pm60 = p64%60;
		/* For twopmodq*() versions taking p and k-args, need to ensure high 64 bits of k (stored in x128.d1) zero: */
		k = x128.d0;
		km60 = (x128.d1*two64mod60 + x128.d0%60)%60;

		/* This property only applies for prime exponents, so use a quick base-2 Fermat
		compositeness test as an exponent filter: */
		if(twopmodq64(p64-1, p64) == 1ull && !CHECK_PKMOD60(pm60, km60))
		{
			fprintf(stderr,"ERROR: Illegal (p,k) mod 60 pair: p, p mod 60, q128, k mod 60 = %s %4u %s %4u\n",
					&cbuf0[convert_uint64_base10_char (cbuf0,  p64)], pm60,
					&cbuf1[convert_uint128_base10_char(cbuf1, q128)], km60);
			ASSERT(HERE, 0,"0");
		}

		res128 = twopmodq128(p128, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR: twopmodq128(%s, %s ) returns non-unity result %s\n",
					&cbuf0[convert_uint64_base10_char (cbuf0, p64)],
					&cbuf1[convert_uint128_base10_char(cbuf1, q128)],
					&cbuf2[convert_uint128_base10_char(cbuf2, res128)]);
			ASSERT(HERE, 0,"0");

		#if 0
			/* 10^31 in binary form - need this to reconstruct large factors that were truncated at 30 digits in the PrimeNet report printout: */
			const uint128 ten31 = {542101086242ull, 13875954555633532928ull};
			/* In case this is a factor sufficiently large (> 10^31) that it was truncated (low-order digits lost)
			at 30 digits in the PrimeNet report printout, attempt to reconstruct the lower portion of the factor
			by repeatedly multiplying the retained 30-upper-digit-portion by 10 and filling in the vacated lower decimal digits:
			*/
			printf("Attempting to reconstruct lower digits of the factor: 10^\n");

		    k = 1;
		    for(idx = 1; idx < 10; idx++)       /* Reconstruct up to 9 lower decimal digits */
		    {
				printf("...%d\n", idx);
				k *= 10;

				/* Multiply the reported factor by 10^idx, unless that would cause the result to overflow: */
				if(k > ((uint32)1 << leadz64(q128.d1)))
					goto CONT128;

				MUL_LOHI64(q128.d0, k, x128.d0, x128.d1);
				x128.d1 += k*q128.d1;
				/* Subtract whatever small constant is needed to make the initial candidate == 1 mod p: */
				j = x128.d1%p64;
				j = (j*two64modp)%p64;
				j += x128.d0%p64;
				j = j%p64 - 1;
				res64 = x128.d0 - j;
				x128.d1 -= (res64 > x128.d0);     /* Borrow from high word is checked here. */
				x128.d0 = res64;
				/*printf("   Subtracting %s  gives %s \n",
					&cbuf0[convert_uint64_base10_char (cbuf0, j)],
					&cbuf1[convert_uint128_base10_char(cbuf1, x128)]);*/

				kmax = k/p64;
				for(j = 0; j <= kmax; j++)
				{
					x128.d0 += p64;	x128.d1 += (x128.d0 < p64);

					/* As a quick filter, only try the candidate if it == +- 1 (mod 8): */
					res64 = x128.d0 & (uint64)7;
					if(res64 == 3 || res64 == 5)
						continue;
					/*
					// 2) Is not divisible by 3,5,7,11,13,17,19:
					// Use that 2^64 == 1 mod  3, i.e. x128 %  3 = (   x128.d1+x128.d0)% 3:
					//	  2^64 == 1 mod  5, i.e. x128 %  5 = (   x128.d1+x128.d0)% 5:
					//	  2^64 == 2 mod  7, i.e. x128 %  7 = ( 2*x128.d1+x128.d0)% 7:
					//	  2^64 == 5 mod 11, i.e. x128 % 11 = ( 5*x128.d1+x128.d0)%11:
					//	  2^64 == 3 mod 13, i.e. x128 % 13 = ( 3*x128.d1+x128.d0)%13:
					//	  2^64 == 1 mod 17, i.e. x128 % 17 = (   x128.d1+x128.d0)%17:
					//	  2^64 ==17 mod 19, i.e. x128 % 19 = (17*x128.d1+x128.d0)%19:
					res64 = x128.d1+x128.d0;
					if(res64%3 == 0 || res64%5 == 0 || res64%17 == 0)
						continue;

					res64 += x128.d1;
					if(res64%7 == 0)
						continue;

					res64 += x128.d1;
					if(res64%13 == 0)
						continue;

					res64 += (x128.d1 << 1);
					if(res64%11 == 0)
						continue;

					res64 += (x128.d1 << 1);
					if(res64%11 == 0)
						continue;
					*/
					/* 3) Satisfies the (p,k)%60 rules: */
					lo.d0   = ((x128.d0-1) >> 1) + (x128.d1 << 63);	lo.d1   = (x128.d1 >> 1);       /* (q-1)/2. */
					MULL128(lo, pinv128, lo);
					km60 = (lo.d1*two64mod60 + lo.d0%60)%60;
					if(!CHECK_PKMOD60(pm60, km60))
						continue;

					if(twopmodq128(p64, x128) == 1)
					{
						q128 = x128;
						printf("***Reconstructed factor: Q =  %s \n",
					&cbuf0[convert_uint128_base10_char(cbuf0, q128)]);
						goto CONT128;
					}
				}
		    }

			/* Attempt to reconstruct the upper portion by repeatedly adding 10^31 and retrying: */
			printf("Attempting to reconstruct upper digits of the factor...\n");
			x128 = q128;
			for(j = 0; j < 0x10000000; j++)
			{
				ADD128(ten31, x128, x128);

				/* As a quick filter, only try the candidate if it satisfies the (p,k)%60 rules: */
				lo.d0   = ((x128.d0-1) >> 1) + (x128.d1 << 63);lo.d1   = (x128.d1 >> 1);       /* (q-1)/2. */
				MULL128(lo, pinv128, lo);
				km60 = (lo.d1*two64mod60 + lo.d0%60)%60;

				if(!CHECK_PKMOD60(pm60, km60))
				{
					continue;
				}

				if(twopmodq128(p64, x128) == 1)
				{
					q128 = x128;
					printf("***Reconstructed factor: Q =  %s \n",
					&cbuf0[convert_uint128_base10_char(cbuf0, q128)]);
					break;
				}
			}
		CONT128:
			continue;

		#endif	/* if(0) */
		}

		/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
		if(x128.d1 == 0)	// k must be 64-bit
		{
			p128.d0 = p64; p128.d1 = 0;
			res64 = twopmodq128x2(&sum1, &sum2, (uint64 *)&p128, k);
			if(res64 != 1)
			{
				fprintf(stderr,"ERROR: twopmodq128x2(%llu, %llu ) returns non-unity result %u\n",p64,k, (uint32)res64);
				ASSERT(HERE, 0,"0");
			}

		#if(TRYQ == 4)
			res64 = twopmodq128_q4(&sum1, &sum2, (uint64 *)&p128,k,k,k,k);
			if(res64 != 15)
			{
				fprintf(stderr,"ERROR: twopmodq128_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",
					&cbuf0[convert_uint128_base10_char(cbuf0,p128)],
					&cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
				ASSERT(HERE, 0,"0");
			}
		#elif(TRYQ == 8)
			res64 = twopmodq128_q8(&sum1, &sum2, (uint64 *)&p128,k,k,k,k,k,k,k,k);
			if(res64 != 255)
			{
				fprintf(stderr,"ERROR: twopmodq128_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",
					&cbuf0[convert_uint128_base10_char(cbuf0,p128)],
					&cbuf1[convert_uint128_base10_char(cbuf1,q128)], (uint32)res64);
				ASSERT(HERE, 0,"0");
			}
		#endif
		}	// k must be 64-bit
	}

#endif	/* #endif(defined(P2WORD) || defined(P3WORD) || defined(P4WORD)) */

#if(defined(P2WORD))

	/*** Only do this time-consuming series of 128-bit factor tests in debug mode: ***/
  #if(FAC_DEBUG)
	/* 128_B: Construct more 128-bit test factors by multiplying together
	a 63-bit factor q1 of M(p1) and a 64-bit factor q2 of M(p2)
	and checking whether q1*q2 divides M(p1*p2).
	*/
   #ifdef FACTOR_STANDALONE
	printf("Testing 63*64-bit factors...I=");
   #endif
	/*for(i = 0; fac63[i].p != 0; i++)*/
	for(i = 0; i < 100; i++)
	{
   #ifdef FACTOR_STANDALONE
	printf("%u...",i);
   #endif
	  for(i2 = 0; fac64[i2].p != 0; i2++)
	  {
		if(fac63[i].p == fac64[i2].p)
			continue;

		p64 = (uint64)fac63[i].p * (uint64)fac64[i2].p;
	#ifdef MUL_LOHI64_SUBROUTINE
		MUL_LOHI64(fac63[i].q, fac64[i2].q,&q128.d0,&q128.d1);
	#else
		MUL_LOHI64(fac63[i].q, fac64[i2].q, q128.d0, q128.d1);
	#endif

		/* Skip the q%(2*p) == 1 and (p%60,q%60) checks, as they don't apply
		to composite factors which are a product of prime factors of
		different-exponent M(p)'s. */

		res128 = twopmodq128(p128, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR_63x64[%u][%u]: twopmodq128(%u*%u, %s*%s ) returns non-unity result %s\n",
					i,i2, fac63[i].p, fac64[i2].p,
					&cbuf0[convert_uint64_base10_char (cbuf0, fac63[i].q)],
					&cbuf1[convert_uint64_base10_char (cbuf1, fac64[i2].q)],
					&cbuf2[convert_uint128_base10_char(cbuf2, q128)]);
			ASSERT(HERE, 0,"0");
		}

		p128.d0 = p64; p128.d1 = 0;
		res64 = twopmodq128x2(&sum1, &sum2, (uint64*)&p128, q128);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR63x64[%u][%u]: twopmodq128x2(%u*%u, %s*%s ) returns non-unity result %u\n",
					i,i2, fac63[i].p, fac64[i2].p,
					&cbuf0[convert_uint64_base10_char (cbuf0, fac63[i].q)],
					&cbuf1[convert_uint64_base10_char (cbuf1, fac64[i2].q)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  }
	}
   #ifdef FACTOR_STANDALONE
	printf("\n");
   #endif

	/* 128_C: Construct more 128-bit test factors by multiplying together
	a 64-bit factor q1 of M(p1) and a 64-bit factor q2 of M(p2) (p1 != p2)
	and checking whether q1*q2 divides M(p1*p2).
	*/
   #ifdef FACTOR_STANDALONE
	printf("Testing 64*64-bit factors...I=");
   #endif
	/*for(i = 0; fac64[i].p != 0; i++)*/
	for(i = 0; i < 100; i++)
	{
   #ifdef FACTOR_STANDALONE
	printf("%u...",i);
   #endif
	  for(i2 = 0; fac64[i2].p != 0; i2++)
	  {
		if(fac64[i].p == fac64[i2].p)
			continue;

		p64 = (uint64)fac64[i].p * (uint64)fac64[i2].p;
	#ifdef MUL_LOHI64_SUBROUTINE
		MUL_LOHI64(fac64[i].q, fac64[i2].q,&q128.d0,&q128.d1);
	#else
		MUL_LOHI64(fac64[i].q, fac64[i2].q, q128.d0, q128.d1);
	#endif

		/* Skip the q%(2*p) == 1 and (p%60,q%60) checks, as they don't apply
		to composite factors which are a product of prime factors of
		different-exponent M(p)'s. */

		p128.d0 = p64; p128.d1 = 0;
		res128 = twopmodq128(p64, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR_64x64[%u][%u]: twopmodq128(%u*%u, %s*%s ) returns non-unity result %s\n",
					i,i2, fac64[i].p, fac64[i2].p,
					&cbuf0[convert_uint64_base10_char (cbuf0, fac64[i].q)],
					&cbuf1[convert_uint64_base10_char (cbuf1, fac64[i2].q)],
					&cbuf2[convert_uint128_base10_char(cbuf2, q128)]);
			ASSERT(HERE, 0,"0");
		}

		res64 = twopmodq128x2(&sum1, &sum2, (uint64*)&p128, q128);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR64x64[%u][%u]: twopmodq128x2(%u*%u, %s*%s ) returns non-unity result %u\n",
					i,i2, fac64[i].p, fac64[i2].p,
					&cbuf0[convert_uint64_base10_char (cbuf0, fac64[i].q)],
					&cbuf1[convert_uint64_base10_char (cbuf1, fac64[i2].q)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  }
	}
   #ifdef FACTOR_STANDALONE
	printf("\n");
   #endif

	/* 128_D: Construct more 128-bit test factors by multiplying together
	a 63-bit factor q1 of M(p1) and a 65-bit factor q2 of M(p2)
	and checking whether q1*q2 divides M(p1*p2).
	*/
   #ifdef FACTOR_STANDALONE
	printf("Testing 63*65-bit factors...I=");
   #endif
	/*for(i = 0; fac63[i].p != 0; i++)*/
	for(i = 0; i < 100; i++)
	{
	#ifdef FACTOR_STANDALONE
	  printf("%u...",i);
	#endif
	  for(i2 = 0; fac65[i2].p != 0; i2++)
	  {
		if(fac63[i].p == fac65[i2].p)
			continue;

		p64 = (uint64)fac63[i].p * (uint64)fac65[i2].p;
		x128.d0 = fac65[i2].q;	x128.d1 = 1;	/* Store full q65 in a 128-bit temp for printing purposes */
	#ifdef MUL_LOHI64_SUBROUTINE
		MUL_LOHI64(fac63[i].q, fac65[i2].q,&q128.d0,&q128.d1);
	#else
		MUL_LOHI64(fac63[i].q, fac65[i2].q, q128.d0, q128.d1);
	#endif
		/* fac65.q's assumed to have (hidden) 65th bit = 1, so need
		to add 2^64*fac63.q to the output of MUL_LOHI64 here: */
		q128.d1 += fac63[i].q;
		if(q128.d1 <= fac63[i].q)
		{
			fprintf(stderr,"ERROR_63x65[%u][%u]: (p1*p2, q1*q2) = (%u*%u, %s*%s )\n",
					i,i2, fac63[i].p, fac65[i2].p,
					&cbuf0[convert_uint64_base10_char (cbuf0, fac63[i].q)],
					&cbuf1[convert_uint128_base10_char(cbuf1, x128)]);
			fprintf(stderr," q128.d1 += fac63[i].q overflows!\n");
			ASSERT(HERE, q128.d1 > fac63[i].q,"q128.d1 > fac63[i].q");	/* Make sure sum didn't overflow */
		}

		/* Skip the q%(2*p) == 1 and (p%60,q%60) checks, as they don't apply
		to composite factors which are a product of prime factors of
		different-exponent M(p)'s. */

		p128.d0 = p64; p128.d1 = 0;
		res128 = twopmodq128(p128, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR_63x65[%u][%u]: twopmodq128(%u*%u, %s*%s ) returns non-unity result %s\n",
					i,i2, fac63[i].p, fac65[i2].p,
					&cbuf0[convert_uint64_base10_char (cbuf0, fac63[i].q)],
					&cbuf1[convert_uint128_base10_char(cbuf1, x128)],
					&cbuf2[convert_uint128_base10_char(cbuf2, res128)]);
			ASSERT(HERE, 0,"0");
		}

		res64 = twopmodq128x2(&sum1, &sum2, (uint64*)&p128, q128);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR63x65[%u][%u]: twopmodq128x2(%u*%u, %s*%s ) returns non-unity result %u\n",
					i,i2, fac63[i].p, fac65[i2].p,
					&cbuf0[convert_uint64_base10_char (cbuf0, fac63[i].q)],
					&cbuf1[convert_uint128_base10_char(cbuf1, x128)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	  }
	}
   #ifdef FACTOR_STANDALONE
	printf("\n");
   #endif
  #endif	/* #if FAC_DEBUG */

#ifdef FACTOR_STANDALONE
	printf("Testing 128x2-bit factors...\n");
#endif
	for(i = 0; fac128x2[i].plo != 0; i++)
	{
		p128.d1 = fac128x2[i].phi;	p128.d0 = fac128x2[i].plo;
		q128.d1 = fac128x2[i].d1;	q128.d0 = fac128x2[i].d0;

		/* This uses the generic -bit mod function to calculate q%(2*p): */
		ADD128(p128, p128, two_p128);
		x128 = xmody128(q128, two_p128);
		if(!CMPEQ128(x128, ONE128))
		{
			fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",
					&cbuf0[convert_uint128_base10_char(cbuf0, p128)],
					&cbuf1[convert_uint128_base10_char(cbuf1, q128)],
					&cbuf2[convert_uint128_base10_char(cbuf2, x128)]);
			ASSERT(HERE, 0,"0");
		}

		res128 = twopmodq128(p128, q128);
		if(!CMPEQ128(ONE128,res128))
		{
			fprintf(stderr,"ERROR: twopmodq128( %s, %s ) returns non-unity result %s\n",
					&cbuf0[convert_uint128_base10_char(cbuf0, p128)],
					&cbuf1[convert_uint128_base10_char(cbuf1, q128)],
					&cbuf2[convert_uint128_base10_char(cbuf2, res128)]);
			ASSERT(HERE, 0,"0");
		}
	}

#endif	/* #endif(defined(P2WORD)) */

#if(defined(P3WORD) || defined(P4WORD))

	/* Test 128-bit factors using the 160 and 192-bit modmul routines */
#ifdef FACTOR_STANDALONE
	printf("Testing 128x2-bit factors using 160 and 192-bit modmul routines...\n");
#endif
	for(i = 0; fac128x2[i].plo != 0; i++)
	{
		p192.d2 = 0; p192.d1 = fac128x2[i].phi;	p192.d0 = fac128x2[i].plo;
		q192.d2 = 0; q192.d1 = fac128x2[i].d1;	q192.d0 = fac128x2[i].d0;

		/* This uses the generic -bit mod function to calculate q%(2*p): */
		ADD192(p192, p192, two_p192);
		x192 = xmody192(q192, two_p192, 0x0);
		if(!CMPEQ192(x192, ONE192))
		{
			fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",
					&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
					&cbuf1[convert_uint192_base10_char(cbuf1, q192)],
					&cbuf2[convert_uint192_base10_char(cbuf2, x192)]);
			ASSERT(HERE, 0,"0");
		}

		// Now compute k = (q-1)/2p, while verifying that q%2p = 1:
		mi64_div((uint64*)&q192, (uint64*)&two_p192, 3,3, (uint64*)&x192, (uint64*)&res192);	// x192 contains k
		ASSERT(HERE, x192.d2 == 0 && x192.d1 == 0,"k > 2^64!");
		if(!CMPEQ192(res192, ONE192))
		{
			fprintf(stderr,"ERROR: twopmodq192( %s, %s ) returns non-unity result!\n",
					&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
					&cbuf1[convert_uint192_base10_char(cbuf1, q192)]);
			ASSERT(HERE, 0,"0");
		}

		/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
	#if(TRYQ == 4)
/*
		res64 = twopmodq160_q4(p192,q192,q192,q192,q192);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq160_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",
					&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
					&cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
*/
		res64 = twopmodq192_q4(&sum1, &sum2, (uint64*)&p192,x192.d0,x192.d0,x192.d0,x192.d0);
		if(res64 != 15)
		{
			fprintf(stderr,"ERROR: twopmodq192_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",
					&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
					&cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
			ASSERT(HERE, 0,"0");	// *** disable this to allow fast-UMULH192 timing-testing ***
		}
	#elif(TRYQ == 8)
/*
		res64 = twopmodq160_q8(p192,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq160_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",
					&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
					&cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
*/
		res64 = twopmodq192_q8(&sum1, &sum2, p192,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0);
		if(res64 != 255)
		{
			fprintf(stderr,"ERROR: twopmodq192_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",
					&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
					&cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
			ASSERT(HERE, 0,"0");
		}
	#endif
	}

	/* Test 160-bit factors using the 160 and 192-bit modmul routines */
#ifdef FACTOR_STANDALONE
	printf("Testing 160-bit factors using 160 and 192-bit modmul routines...\n");
#endif
	for(i = 0; fac160[i].p != 0; i++)
	{
		p64 = fac160[i].p;
		q192.d2 = fac160[i].d2; q192.d1 = fac160[i].d1; q192.d0 = fac160[i].d0;
		p192.d0 = p64;	p192.d1 = p192.d2 = 0;		ADD192(p192, p192, two_p192);

		two64modp = 0x8000000000000000ull%p64;
		two64modp = (two64modp + two64modp)%p64;
		/* Really large factors may have high part sufficiently large that q.d2*two64modp
		overflows 64 bits, so stick an extra mod-p in there: */
		if((((q192.d2%p64)*two64modp + q192.d1%p64)*two64modp + q192.d0%p64)%p64 != 1)
		{
			fprintf(stderr,"ERROR: q != 1 modulo p for M( %s ), q = %s \n",
					&cbuf0[convert_uint64_base10_char (cbuf0, p64)],
					&cbuf1[convert_uint192_base10_char(cbuf1, q192)]);
			ASSERT(HERE, 0,"0");
		}

		// Now compute k = (q-1)/2p, while verifying that q%2p = 1:
		mi64_div((uint64*)&q192, (uint64*)&two_p192, 3,3, (uint64*)&x192, (uint64*)&res192);	// x192 contains k
		if(!CMPEQ192(res192, ONE192))
		{
			fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",
					&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
					&cbuf1[convert_uint192_base10_char(cbuf1, q192)],
					&cbuf2[convert_uint192_base10_char(cbuf2, res192)]);
			ASSERT(HERE, 0,"0");
		}
/*
		res192 = twopmodq160(p192, q192);
		if(!CMPEQ192(ONE192,res192))
		{
			fprintf(stderr,"ERROR: twopmodq160( %s, %s ) returns non-unity result %s\n",
					&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
					&cbuf1[convert_uint192_base10_char(cbuf1, q192)],
					&cbuf2[convert_uint192_base10_char(cbuf2, res192)]);
			ASSERT(HERE, 0,"0");
		}
*/
		res192 = twopmodq192(p192, q192);
		if(!CMPEQ192(res192, ONE192))
		{
			fprintf(stderr,"ERROR: twopmodq192( %s, %s ) returns non-unity result %s\n",
					&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
					&cbuf1[convert_uint192_base10_char(cbuf1, q192)],
					&cbuf2[convert_uint192_base10_char(cbuf2, res192)]);
			ASSERT(HERE, 0,"0");
		}

		/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
	#if(TRYQ == 4)
		if(x192.d2 == 0 && x192.d1 == 0)	// k must be 64-bit for these
		{
		/*
			res64 = twopmodq160_q4(p192,x192.d0,x192.d0,x192.d0,x192.d0);
			if(res64 != 15)
			{
				fprintf(stderr,"ERROR: twopmodq160_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",
						&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
						&cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
				ASSERT(HERE, 0,"0");
			}
		*/
			res64 = twopmodq192_q4(&sum1, &sum2, (uint64*)&p192,x192.d0,x192.d0,x192.d0,x192.d0);
			if(res64 != 15)
			{
				fprintf(stderr,"ERROR: twopmodq192_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",
						&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
						&cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
				ASSERT(HERE, 0,"0");
			}
		}
	#elif(TRYQ == 8)
		if(x192.d2 == 0 && x192.d1 == 0)	// k must be 64-bit for these
		{
		/*
			res64 = twopmodq160_q8(p192,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0);
			if(res64 != 255)
			{
				fprintf(stderr,"ERROR: twopmodq160_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",
						&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
						&cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
				ASSERT(HERE, 0,"0");
			}
		*/
			res64 = twopmodq192_q8(&sum1, &sum2, p192,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0);
			if(res64 != 255)
			{
				fprintf(stderr,"ERROR: twopmodq192_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",
						&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
						&cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
				ASSERT(HERE, 0,"0");
			}
		}
	#endif
	}

#endif	/* #if(defined(P3WORD) || defined(P4WORD)) */

#if(defined(P3WORD) || defined(P4WORD))

	/* Test 192-bit factors using the 192 and 256-bit modmul routines */
	/* 192_A: prime factors < 2^192: */
#ifdef FACTOR_STANDALONE
	printf("Testing 192-bit factors using the 192 and 256-bit modmul routines...\n");
#endif
	for(i = 0; fac192[i].p != 0; i++)
	{
		p64 = fac192[i].p;
		q192.d2 = fac192[i].d2; q192.d1 = fac192[i].d1; q192.d0 = fac192[i].d0;
		p192.d0 = p64;	p192.d1 = p192.d2 = 0;		ADD192(p192, p192, two_p192);

		two64modp = 0x8000000000000000ull%p64;
		two64modp = (two64modp + two64modp)%p64;
		/* Really large factors may have high part sufficiently large that q.d2*two64modp
		overflows 64 bits, so stick an extra mod-p in there: */
		if((((q192.d2%p64)*two64modp + q192.d1%p64)*two64modp + q192.d0%p64)%p64 != 1)
		{
			fprintf(stderr,"ERROR: q != 1 modulo p for M( %s ), q = %s \n",
					&cbuf0[convert_uint64_base10_char (cbuf0, p64)],
					&cbuf1[convert_uint192_base10_char(cbuf1, q192)]);
			ASSERT(HERE, 0,"0");
		}

		// Now compute k = (q-1)/2p, while verifying that q%2p = 1:
		mi64_div((uint64*)&q192, (uint64*)&two_p192, 3,3, (uint64*)&x192, (uint64*)&res192);	// x192 contains k
		if(!CMPEQ192(res192, ONE192))
		{
			fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",
					&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
					&cbuf1[convert_uint192_base10_char(cbuf1, q192)],
					&cbuf2[convert_uint192_base10_char(cbuf2, res192)]);
			ASSERT(HERE, 0,"0");
		}

		res192 = twopmodq192(p192, q192);
		if(!CMPEQ192(res192, ONE192))
		{
			fprintf(stderr,"ERROR: twopmodq192( %s, %s ) returns non-unity result %s\n",
					&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
					&cbuf1[convert_uint192_base10_char(cbuf1, q192)],
					&cbuf2[convert_uint192_base10_char(cbuf2, res192)]);
			ASSERT(HERE, 0,"0");
		}

		/* Floating-double-based impl. allows q up to 200 bits: */
		if(x192.d1 == 0 && x192.d2 == 0) {
			x256 = twopmodq200_8WORD_DOUBLE(&sum1, &sum2, (uint64*)&p192, x192.d0);	res64 = !x256.d3 && (uint64)CMPEQ192(x256, ONE192);
			if(res64 != 1)
			{
				fprintf(stderr,"ERROR: twopmodq200( %s, %s ) returns non-unity result %llu\n",
					&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
					&cbuf1[convert_uint192_base10_char(cbuf1, q192)], res64);
				ASSERT(HERE, 0,"0");
			}
		}

		/* This uses the generic 256-bit mod function to calculate q%(2*p): */
		p256.d0 = p64;	p256.d1 = p256.d2 = p256.d3 = 0;
		q256.d0 = q192.d0;
		q256.d1 = q192.d1;
		q256.d2 = q192.d2;
		q256.d3 =       0;
		ADD256(p256, p256, two_p256);
		x256 = xmody256(q256, two_p256, 0x0);
		if(!CMPEQ256(x256, ONE256))
		{
			fprintf(stderr,"ERROR : (p, q) = ( %s, %s ) : q mod (2p) = %s != 1!\n",
					&cbuf0[convert_uint256_base10_char(cbuf0, p256)],
					&cbuf1[convert_uint256_base10_char(cbuf1, q256)],
					&cbuf2[convert_uint256_base10_char(cbuf2, x256)]);
			ASSERT(HERE, 0,"0");
		}

		res256 = twopmodq256(p256, q256);
		if(!CMPEQ256(ONE256,res256))
		{
			fprintf(stderr,"ERROR: twopmodq256( %s, %s ) returns non-unity result %s\n",
					&cbuf0[convert_uint256_base10_char(cbuf0, p256)],
					&cbuf1[convert_uint256_base10_char(cbuf1, q256)],
					&cbuf2[convert_uint256_base10_char(cbuf2, res256)]);
			ASSERT(HERE, 0,"0");
		}

		/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
	#if(TRYQ == 4)
		if(x192.d2 == 0 && x192.d1 == 0)	// k must be 64-bit for these
		{
			res64 = twopmodq192_q4(&sum1, &sum2, (uint64*)&p192,x192.d0,x192.d0,x192.d0,x192.d0);
			if(res64 != 15)
			{
				fprintf(stderr,"ERROR: twopmodq192_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",
						&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
						&cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
				ASSERT(HERE, 0,"0");
			}
		}
	#elif(TRYQ == 8)
		if(x192.d2 == 0 && x192.d1 == 0)	// k must be 64-bit for these
		{
			res64 = twopmodq192_q8(&sum1, &sum2, p192,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0,x192.d0);
			if(res64 != 255)
			{
				fprintf(stderr,"ERROR: twopmodq192_q8( %s, %s x 8 ) failed to find factor, res = 0x%2X.\n",
						&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
						&cbuf1[convert_uint192_base10_char(cbuf1, q192)], (uint32)res64);
				ASSERT(HERE, 0,"0");
			}
		}
	#endif
	}

#endif

#if(0)//defined(P3WORD))

	/*** Only do this time-consuming series of 192-bit factor tests in debug mode: ***/
  #if(FAC_DEBUG)
	/* 192_B: Construct more 192-bit test factors by multiplying together
	a 63-bit factor q1 of M(p1), a 64-bit factor q2 of M(p2) and a
	65-bit factor q3 of M(p3) and checking whether q1*q2*q3 divides M(p1*p2*p3).
	*/
   #ifdef FACTOR_STANDALONE
	printf("Testing 63*64*65-bit factors: I = ");
   #endif
	/*for(i = 0; fac63[i].p != 0; i++)*/
	for(i = 0; i < 5; i++)
	{
   #ifdef FACTOR_STANDALONE
	printf("%u...",i);
   #endif
	  /*for(i2 = 0; fac65[i2].p != 0; i2++)*/
	  for(i2 = 0; i2 < 100; i2++)
	  {
		if(fac63[i].p == fac65[i2].p)
			continue;

		p64 = (uint64)fac63[i].p * (uint64)fac65[i2].p;
		x128.d0 = fac65[i2].q;	x128.d1 = 1;	/* Store full q65 in a 128-bit temp for printing purposes */
	#ifdef MUL_LOHI64_SUBROUTINE
		MUL_LOHI64(fac63[i].q, fac65[i2].q,&q128.d0,&q128.d1);
	#else
		MUL_LOHI64(fac63[i].q, fac65[i2].q, q128.d0, q128.d1);
	#endif
		/* fac65.q's assumed to have (hidden) 65th bit = 1, so need
		to add 2^64*fac63.q to the output of MUL_LOHI64 here: */
		q128.d1 += fac63[i].q;
		if(q128.d1 <= fac63[i].q)
		{
			fprintf(stderr,"ERROR192_63x65[%u][%u]: (p1*p2, q1*q2) = (%u*%u, %s*%s )\n", i,i2, fac63[i].p, fac65[i2].p,
					&cbuf0[convert_uint64_base10_char (cbuf0, fac63[i].q)],
					&cbuf1[convert_uint128_base10_char(cbuf1, x128)]);
			fprintf(stderr," q128.d1 += fac63[i].q overflows!\n");
			ASSERT(HERE, q128.d1 > fac63[i].q,"q128.d1 > fac63[i].q");	/* Make sure sum didn't overflow */
		}

		/* Now multiply the 128-bit 63x65-bit factor product by each 64-bit test factor in turn. */
		/*for(i3 = 0; fac64[i3].p != 0; i3++)*/
		for(i3 = 0; i3 < 100; i3++)
		{
			if(fac64[i3].p == fac63[i].p || fac64[i3].p == fac65[i2].p)
				continue;

			/* Since the product of three test exponents will generally
			overflow 64-bits, store that in the lower 2 words of the p192 variable:
			*/
		#ifdef MUL_LOHI64_SUBROUTINE
			/* Multiply to get 3-exponent product: */
			MUL_LOHI64(p64, fac64[i3].p,&p192.d0,&p192.d1);	p192.d2 = 0;
			/* Low  128 bits of the 192-bit 3-factor product: */
			MUL_LOHI64(q128.d0,fac64[i3].q,&q192.d0,&q192.d1);
			/* High 128 bits of the 192-bit 3-factor product: */
			MUL_LOHI64(q128.d1,fac64[i3].q,  &tmp64,&q192.d2);	q192.d1 += tmp64;	q192.d2 += (q192.d1 < tmp64);
		#else
			/* Multiply to get 3-exponent product: */
			MUL_LOHI64(p64, fac64[i3].p, p192.d0, p192.d1);	p192.d2 = 0;
			/* Low  128 bits of the 192-bit 3-factor product: */
			MUL_LOHI64(q128.d0,fac64[i3].q, q192.d0, q192.d1);
			/* High 128 bits of the 192-bit 3-factor product: */
			MUL_LOHI64(q128.d1,fac64[i3].q,   tmp64, q192.d2);	q192.d1 += tmp64;	q192.d2 += (q192.d1 < tmp64);
		#endif

			/* Skip the q%(2*p) == 1 and (p%60,q%60) checks, as they don't apply
			to composite factors which are a product of prime factors of
			different-exponent M(p)'s. */

			res192 = twopmodq192(p192, q192);
			if(!CMPEQ192(res192, ONE192))
			{
				fprintf(stderr,"ERROR_63x65x64[%u][%u][%u]: twopmodq192(%u*%u*%u = %s, %s*%s*%s = %s) returns non-unity result %s\n", i,i2,i3, fac63[i].p, fac65[i2].p, fac64[i3].p,
					&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
					&cbuf1[convert_uint64_base10_char (cbuf1, fac63[i].q)],
					&cbuf2[convert_uint128_base10_char(cbuf2, x128)],
					&cbuf3[convert_uint64_base10_char (cbuf3, fac64[i3].q)],
					&cbuf4[convert_uint192_base10_char(cbuf4, q192)]);
				ASSERT(HERE, 0,"0");
			}

			p256.d0 = p192.d0;	q256.d0 = q192.d0;
			p256.d1 = p192.d1;	q256.d1 = q192.d1;
			p256.d2 = p192.d2;	q256.d2 = q192.d2;
			p256.d3 =       0;	q256.d3 =       0;
			res256 = twopmodq256(p256, q256);
			if(!CMPEQ256(ONE256,res256))
			{
				fprintf(stderr,"ERROR_63x65x64[%u][%u][%u]: twopmodq256(%u*%u*%u = %s, %s*%s*%s = %s) returns non-unity result %s\n", i,i2,i3, fac63[i].p, fac65[i2].p, fac64[i3].p,
						&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
						&cbuf1[convert_uint64_base10_char (cbuf1, fac63[i].q)],
						&cbuf2[convert_uint128_base10_char(cbuf2, x128)],
						&cbuf3[convert_uint64_base10_char (cbuf3, fac64[i3].q)],
						&cbuf4[convert_uint256_base10_char(cbuf4, q256)],
						&cbuf5[convert_uint256_base10_char(cbuf5, res256)]);
				ASSERT(HERE, 0,"0");
			}

			/* In debug mode, also test the multiple-q versions of the modular exponentiation routines: */
		#if(TRYQ == 4)
			res64 = twopmodq192_q4(&sum1, &sum2, p192,q192,q192,q192,q192);
			if(res64 != 15)
			{
				fprintf(stderr,"ERROR_63x65x64[%u][%u][%u]: (p1*p2*p3, q1*q2*q3) = (%u*%u*%u, %s*%s*%s )\n", i,i2,i3, fac63[i].p, fac65[i2].p, fac64[i3].p,
					&cbuf1[convert_uint64_base10_char (cbuf1, fac63[i].q)],
					&cbuf2[convert_uint128_base10_char(cbuf2, x128)],
					&cbuf3[convert_uint64_base10_char (cbuf3, fac64[i3].q)]);
				fprintf(stderr,"ERROR: twopmodq192_q4( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",
					&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
					&cbuf1[convert_uint192_base10_char(cbuf1,q192)], (uint32)res64);
				ASSERT(HERE, 0,"0");
			}
		#elif(TRYQ == 8)
			res64 = twopmodq192_q8(&sum1, &sum2, p192,q192,q192,q192,q192,q192,q192,q192,q192);
			if(res64 != 255)
			{
				fprintf(stderr,"ERROR_63x65x64[%u][%u][%u]: (p1*p2*p3, q1*q2*q3) = (%u*%u*%u, %s*%s*%s )\n", i,i2,i3, fac63[i].p, fac65[i2].p, fac64[i3].p,
					&cbuf1[convert_uint64_base10_char (cbuf1, fac63[i].q)],
					&cbuf2[convert_uint128_base10_char(cbuf2, x128)],
					&cbuf3[convert_uint64_base10_char (cbuf3, fac64[i3].q)]);
				fprintf(stderr,"ERROR: twopmodq192_q8( %s, %s x 4 ) failed to find factor, res = 0x%1X.\n",
					&cbuf0[convert_uint192_base10_char(cbuf0, p192)],
					&cbuf1[convert_uint192_base10_char(cbuf1,q192)], (uint32)res64);
				ASSERT(HERE, 0,"0");
			}
		#endif
		}
	  }
	}
   #ifdef FACTOR_STANDALONE
	printf("\n");
   #endif
  #endif	/* #if FAC_DEBUG */

#endif	/* #if(defined(P3WORD)) */

#if(defined(P4WORD))

  #ifdef FACTOR_STANDALONE
	printf("Testing 256-bit factors...\n");
  #endif
	for(i = 0; i < ntest256; i++)
	{
		p256 = convert_base10_char_uint256(fac256[i].p);	ADD256(p256,p256,two_p256);
		q256 = convert_base10_char_uint256(fac256[i].q);
		ASSERT(HERE, CMPEQ256(xmody256(q256, two_p256, &x256), ONE256), "ERROR: q%(2p) != 1");
		res256 = twopmodq256(p256, q256);
		if(!CMPEQ256(res256, ONE256))
		{
			fprintf(stderr,"ERROR: twopmodq256( %s, %s ) returns non-unity result %s\n",
					&cbuf0[convert_uint256_base10_char(cbuf0, p256)],
					&cbuf1[convert_uint256_base10_char(cbuf1, q256)],
					&cbuf2[convert_uint256_base10_char(cbuf2, res256)]);
			ASSERT(HERE, 0,"0");
		}
	#if 0	/************* need to use k-based for FP200! **********/
	  /* Floating-double-based impl. allows p up to 128 bits, k up to 64 bits: */
	  if((q256.d3 == 0 && q256.d2 == 0 && q256.d1 == 0) && (x256.d3 == 0 && x256.d2 == 0 && x256.d1 == 0))
	  {
		p128.d0 = p192.d0;
		p128.d1 = p192.d1;
	printf("twopmodq200, p = %s, k = %llu\n", fac256->p, x256.d0);
		x256 = twopmodq200_8WORD_DOUBLE(&sum1, &sum2, p128, x256.d0);	res64 = !x256.d3 && (uint64)CMPEQ192(x256, ONE192);
		if(res64 != 1)
		{
			fprintf(stderr,"ERROR: twopmodq200( %s, %s ) returns non-unity result %llu\n",
					&cbuf0[convert_uint256_base10_char(cbuf0, p256)],
					&cbuf1[convert_uint256_base10_char(cbuf1, q256)], res64);
			ASSERT(HERE, 0,"0");
		}
	  }
	#endif
	}

	/*** Only do this time-consuming series of 256-bit factor tests in debug mode: ***/
  #if(FAC_DEBUG)
	/* Construct 256-bit test factors by multiplying together a randomly chosen quartet
	consisting of a 63-bit factor q1 of M(p1), 2 (distinct) 64-bit factors q2 of M(p2) and q3 of M(p3)
	and a 65-bit factor q4 of M(p3) and checking whether q1*q2*q3*q4 divides M(p1*p2*p3*p4).
	*/
	#define NTEST256	1000000

   #ifdef FACTOR_STANDALONE
	printf("Testing 63*64*64*65-bit factors: I = ");
   #endif
	/*for(i = 0; fac63[i].p != 0; i++)*/
	for(i = 0; i < 5; i++)
	{
   #ifdef FACTOR_STANDALONE
	printf("%u...",i);
   #endif
	  /*for(i2 = 0; fac65[i2].p != 0; i2++)*/
	  for(i2 = 0; i2 < 100; i2++)
	  {
		if(fac63[i].p == fac65[i2].p)
			continue;

		p63 = (uint64)fac63[i].p * (uint64)fac65[i2].p;
		x128.d0 = fac65[i2].q;	x128.d1 = 1;	/* Store full q65 in a 128-bit temp for printing purposes */
	#ifdef MUL_LOHI64_SUBROUTINE
		MUL_LOHI64(fac63[i].q, fac65[i2].q,&q128.d0,&q128.d1);
	#else
		MUL_LOHI64(fac63[i].q, fac65[i2].q, q128.d0, q128.d1);
	#endif
		/* fac65.q's assumed to have (hidden) 65th bit = 1, so need
		to add 2^64*fac63.q to the output of MUL_LOHI64 here: */
		q128.d1 += fac63[i].q;
		if(q128.d1 <= fac63[i].q)
		{
			fprintf(stderr,"ERROR128_63x65[%u][%u]: (p1*p2, q1*q2) = (%u*%u, %s*%s )\n", i,i2, fac63[i].p, fac65[i2].p,
					&cbuf0[convert_uint64_base10_char (cbuf0, fac63[i].q)],
					&cbuf1[convert_uint128_base10_char(cbuf1, x128)]);
			fprintf(stderr," q128.d1 += fac63[i].q overflows!\n");
			ASSERT(HERE, q128.d1 > fac63[i].q,"q128.d1 > fac63[i].q");	/* Make sure sum didn't overflow */
		}

		/* Now multiply the 128-bit 63x65-bit factor product by the product of each pair of 64-bit test factors in turn. */
		srand(1);	/* Init stdlib RNG */
		/*for(i3 = 0; fac64[i3].p != 0; i3++)*/
		for(i3 = 0; i3 < 30; i3++)
		{
			ii = rand()%100;
			if(fac64[ii].p == fac63[i].p || fac64[ii].p == fac65[i2].p)
				continue;

			for(i4 = 0; i4 < 30; i4++)
			{
				jj = rand()%100;
				if(fac64[jj].p == fac64[ii].p)
					continue;

				p64 = (uint64)fac64[ii].p * (uint64)fac64[jj].p;
				/* Multiply the two 2-exponent products (p63 and p64) to get 4-exponent product: */
				MUL_LOHI64(p63,p64,&p256.d0,&p256.d1);	p256.d3 = p256.d2 = 0;

				/* Now do a pair of 64-bit scalar*vector MULs to build the 256-bit factor product: */
				q256.d2 = mi64_mul_scalar(&q128.d0, fac64[ii].q, &q256.d0, 2);
				q256.d3 = mi64_mul_scalar(&q256.d0, fac64[jj].q, &q256.d0, 3);

				res256 = twopmodq256(p256, q256);
				if(!CMPEQ256(ONE256,res256))
				{
					fprintf(stderr,"ERROR_63x65x64x64[%u][%u][%u][%u]: twopmodq256(%u*%u*%u*%u = %s, %s*%s*%s*%s = %s) returns non-unity result %s\n", i,i2,i3,i4, fac63[i].p, fac65[i2].p, fac64[ii].p, fac64[jj].p,
					&cbuf0[convert_uint256_base10_char(cbuf0, p256)],
					&cbuf1[convert_uint64_base10_char (cbuf1, fac63[i].q)],
					&cbuf2[convert_uint128_base10_char(cbuf2, x128)],
					&cbuf3[convert_uint64_base10_char (cbuf3, fac64[ii].q)],
					&cbuf4[convert_uint64_base10_char (cbuf4, fac64[jj].q)],
					&cbuf5[convert_uint256_base10_char(cbuf5, q256)],
					&cbuf6[convert_uint256_base10_char(cbuf6, res256)]);
					ASSERT(HERE, 0,"0");
				}
			}
		}
	  }
	}
   #ifdef FACTOR_STANDALONE
	printf("\n");
   #endif
  #endif	/* #if FAC_DEBUG */

#endif	/* #if(defined(P4WORD)) */

#ifdef FACTOR_STANDALONE
	printf("Factoring self-tests completed successfully.\n");
#endif
	return 0;
}

